{"version":3,"file":"js/86e244c34778a905573b.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;AAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,sBAAsB,eAAU;AAChC;AACA;AACA,8CAA8C,UAAK,6BAA6B,UAAK;AACrF,sBAAsB,eAAU;AAChC;AACA;AACA;AACA;;;ACnEiG;AAC3B;AACE;AAC1B;AACvC,0BAA0B,cAAK,CAAC,eAAU;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,aAAQ,UAAU,wBAAwB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,+BAAI,iBAAiB,+BAAI;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sFAAsF,kCAAO;AAC7F;AACA;AACA;AACA,2DAA2D,mCAAQ,aAAa,cAAc;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;AACA,sBAAsB,eAAU,CAAC,UAAK;AACtC;AACA,4CAA4C,kCAAO;AACnD;AACA;AACA;AACA,gDAAgD,mCAAQ,UAAU,cAAc;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,eAAU;AAC5B;AACA;AACA,uBAAuB,UAAK,GAAG,cAAc,iBAAO,cAAc;AAClE;AACA;AACA,oBAAoB,qBAAqB;AACzC,uBAAuB,UAAK,GAAG,cAAc,iBAAO,+BAA+B;AACnF;AACA,kBAAkB,eAAU,CAAC,UAAK;AAClC;AACA;AACA;AACA;AACA,kBAAkB,eAAU;AAC5B;AACA;AACA;AACA;AACA,8BAA8B,UAAK,GAAG,cAAc,iBAAO,+CAA+C;AAC1G,uBAAuB,gBAAW;AAClC;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA,4CAA4C,kCAAO;AACnD;AACA;AACA,yCAAyC,mCAAQ,UAAU,iBAAiB;AAC5E;AACA;AACA,sBAAsB,gBAAgB;AACtC;AACA;AACA;AACA;AACA,cAAc,eAAU;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,eAAU;AAC5B;AACA,4CAA4C,kCAAO;AACnD;AACA,kBAAkB,eAAU;AAC5B;AACA,wCAAwC,mCAAQ,UAAU,cAAc;AACxE;AACA;AACA;AACA;AACA,kBAAkB,eAAU;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,eAAU;AAChC;AACA,qBAAqB,+BAAI;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA,8BAA8B,eAAU,CAAC,UAAK;AAC9C;AACA,gBAAgB,gBAAgB;AAChC;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;;;;;ACnMuE;AACJ;AACrB;AAC9C;AACA;AACA;AACA;AACA;AACA,mBAAmB,gBAAgB;AACnC;AACA,KAAK;AACL;AACA;AACA;AACA;AACO,mCAAmC,8BAAgB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,eAAU;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,wBAAwB,cAAK,CAAC,YAAO;AACrC;AACA,uBAAuB,aAAQ,UAAU,mBAAmB;AAC5D;AACA;AACA,KAAK;AACL;;;ACtH4F;AAC5F;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAM;AACrB;AACA;AACA;AACA,kDAAkD,eAAM;AACxD;AACA;AACA,sBAAsB,eAAU,CAAC,UAAK;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,eAAU,CAAC,UAAK;AACtC;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA,KAAK;AACL,aAAa,mCAAmC;AAChD,mBAAmB,YAAO;AAC1B,KAAK;AACL;;;AChE4B;AACG;AACF","sources":["webpack://fausteditorweb/./node_modules/@zenfs/dom/dist/utils.js","webpack://fausteditorweb/./node_modules/@zenfs/dom/dist/access.js","webpack://fausteditorweb/./node_modules/@zenfs/dom/dist/IndexedDB.js","webpack://fausteditorweb/./node_modules/@zenfs/dom/dist/Storage.js","webpack://fausteditorweb/./node_modules/@zenfs/dom/dist/index.js"],"sourcesContent":["import { ErrnoError, Errno } from '@zenfs/core';\n/**\n * Converts a DOMException into an Errno\n * @see https://developer.mozilla.org/Web/API/DOMException\n */\nfunction errnoForDOMException(ex) {\n    switch (ex.name) {\n        case 'IndexSizeError':\n        case 'HierarchyRequestError':\n        case 'InvalidCharacterError':\n        case 'InvalidStateError':\n        case 'SyntaxError':\n        case 'NamespaceError':\n        case 'TypeMismatchError':\n        case 'ConstraintError':\n        case 'VersionError':\n        case 'URLMismatchError':\n        case 'InvalidNodeTypeError':\n            return 'EINVAL';\n        case 'WrongDocumentError':\n            return 'EXDEV';\n        case 'NoModificationAllowedError':\n        case 'InvalidModificationError':\n        case 'InvalidAccessError':\n        case 'SecurityError':\n        case 'NotAllowedError':\n            return 'EACCES';\n        case 'NotFoundError':\n            return 'ENOENT';\n        case 'NotSupportedError':\n            return 'ENOTSUP';\n        case 'InUseAttributeError':\n            return 'EBUSY';\n        case 'NetworkError':\n            return 'ENETDOWN';\n        case 'AbortError':\n            return 'EINTR';\n        case 'QuotaExceededError':\n            return 'ENOSPC';\n        case 'TimeoutError':\n            return 'ETIMEDOUT';\n        case 'ReadOnlyError':\n            return 'EROFS';\n        case 'DataCloneError':\n        case 'EncodingError':\n        case 'NotReadableError':\n        case 'DataError':\n        case 'TransactionInactiveError':\n        case 'OperationError':\n        case 'UnknownError':\n        default:\n            return 'EIO';\n    }\n}\n/**\n * Handles converting errors, then rethrowing them\n * @internal\n */\nexport function convertException(ex, path, syscall) {\n    if (ex instanceof ErrnoError) {\n        return ex;\n    }\n    const code = ex instanceof DOMException ? Errno[errnoForDOMException(ex)] : Errno.EIO;\n    const error = new ErrnoError(code, ex.message, path, syscall);\n    error.stack = ex.stack;\n    error.cause = ex.cause;\n    return error;\n}\n","import { Async, Errno, ErrnoError, FileSystem, InMemory, PreloadFile, Stats } from '@zenfs/core';\nimport { S_IFDIR, S_IFREG } from '@zenfs/core/emulation/constants.js';\nimport { basename, dirname, join } from '@zenfs/core/emulation/path.js';\nimport { convertException } from './utils.js';\nexport class WebAccessFS extends Async(FileSystem) {\n    constructor(handle) {\n        super();\n        this._handles = new Map();\n        /**\n         * @hidden\n         */\n        this._sync = InMemory.create({ name: 'accessfs-cache' });\n        this._handles.set('/', handle);\n    }\n    metadata() {\n        return {\n            ...super.metadata(),\n            name: 'WebAccess',\n            noResizableBuffers: true,\n        };\n    }\n    async sync(path, data, stats) {\n        const currentStats = await this.stat(path);\n        if (stats.mtime !== currentStats.mtime) {\n            await this.writeFile(path, data);\n        }\n    }\n    async rename(oldPath, newPath) {\n        try {\n            const handle = await this.getHandle(oldPath);\n            if (handle instanceof FileSystemDirectoryHandle) {\n                const files = await this.readdir(oldPath);\n                await this.mkdir(newPath);\n                if (files.length == 0) {\n                    await this.unlink(oldPath);\n                }\n                else {\n                    for (const file of files) {\n                        await this.rename(join(oldPath, file), join(newPath, file));\n                        await this.unlink(oldPath);\n                    }\n                }\n            }\n            if (!(handle instanceof FileSystemFileHandle)) {\n                return;\n            }\n            const oldFile = await handle.getFile(), destFolder = await this.getHandle(dirname(newPath));\n            if (!(destFolder instanceof FileSystemDirectoryHandle)) {\n                return;\n            }\n            const newFile = await destFolder.getFileHandle(basename(newPath), { create: true });\n            const writable = await newFile.createWritable();\n            await writable.write(await oldFile.arrayBuffer());\n            writable.close();\n            await this.unlink(oldPath);\n        }\n        catch (ex) {\n            throw convertException(ex, oldPath, 'rename');\n        }\n    }\n    async writeFile(path, data) {\n        if (data.buffer.resizable) {\n            throw new ErrnoError(Errno.EINVAL, 'Resizable buffers can not be written', path, 'write');\n        }\n        const handle = await this.getHandle(dirname(path));\n        if (!(handle instanceof FileSystemDirectoryHandle)) {\n            return;\n        }\n        const file = await handle.getFileHandle(basename(path), { create: true });\n        const writable = await file.createWritable();\n        await writable.write(data);\n        await writable.close();\n    }\n    async createFile(path, flag) {\n        await this.writeFile(path, new Uint8Array());\n        return this.openFile(path, flag);\n    }\n    async stat(path) {\n        const handle = await this.getHandle(path);\n        if (!handle) {\n            throw ErrnoError.With('ENOENT', path, 'stat');\n        }\n        if (handle instanceof FileSystemDirectoryHandle) {\n            return new Stats({ mode: 0o777 | S_IFDIR, size: 4096 });\n        }\n        if (handle instanceof FileSystemFileHandle) {\n            const { lastModified, size } = await handle.getFile();\n            return new Stats({ mode: 0o777 | S_IFREG, size, mtimeMs: lastModified });\n        }\n        throw new ErrnoError(Errno.EBADE, 'Handle is not a directory or file', path, 'stat');\n    }\n    async openFile(path, flag) {\n        const handle = await this.getHandle(path);\n        if (!(handle instanceof FileSystemFileHandle)) {\n            throw ErrnoError.With('EISDIR', path, 'openFile');\n        }\n        try {\n            const file = await handle.getFile();\n            const data = new Uint8Array(await file.arrayBuffer());\n            const stats = new Stats({ mode: 0o777 | S_IFREG, size: file.size, mtimeMs: file.lastModified });\n            return new PreloadFile(this, path, flag, stats, data);\n        }\n        catch (ex) {\n            throw convertException(ex, path, 'openFile');\n        }\n    }\n    async unlink(path) {\n        const handle = await this.getHandle(dirname(path));\n        if (handle instanceof FileSystemDirectoryHandle) {\n            try {\n                await handle.removeEntry(basename(path), { recursive: true });\n            }\n            catch (ex) {\n                throw convertException(ex, path, 'unlink');\n            }\n        }\n    }\n    async link(srcpath) {\n        throw ErrnoError.With('ENOSYS', srcpath, 'WebAccessFS.link');\n    }\n    async rmdir(path) {\n        return this.unlink(path);\n    }\n    async mkdir(path) {\n        const existingHandle = await this.getHandle(path);\n        if (existingHandle) {\n            throw ErrnoError.With('EEXIST', path, 'mkdir');\n        }\n        const handle = await this.getHandle(dirname(path));\n        if (!(handle instanceof FileSystemDirectoryHandle)) {\n            throw ErrnoError.With('ENOTDIR', path, 'mkdir');\n        }\n        await handle.getDirectoryHandle(basename(path), { create: true });\n    }\n    async readdir(path) {\n        const handle = await this.getHandle(path);\n        if (!(handle instanceof FileSystemDirectoryHandle)) {\n            throw ErrnoError.With('ENOTDIR', path, 'readdir');\n        }\n        const keys = [];\n        for await (const key of handle.keys()) {\n            keys.push(key);\n        }\n        return keys;\n    }\n    async getHandle(path) {\n        if (this._handles.has(path)) {\n            return this._handles.get(path);\n        }\n        let walked = '/';\n        for (const part of path.split('/').slice(1)) {\n            const handle = this._handles.get(walked);\n            if (!(handle instanceof FileSystemDirectoryHandle)) {\n                throw ErrnoError.With('ENOTDIR', walked, 'getHandle');\n            }\n            walked = join(walked, part);\n            try {\n                const dirHandle = await handle.getDirectoryHandle(part);\n                this._handles.set(walked, dirHandle);\n            }\n            catch (_ex) {\n                const ex = _ex;\n                if (ex.name == 'TypeMismatchError') {\n                    try {\n                        const fileHandle = await handle.getFileHandle(part);\n                        this._handles.set(walked, fileHandle);\n                    }\n                    catch (ex) {\n                        convertException(ex, walked, 'getHandle');\n                    }\n                }\n                if (ex.name === 'TypeError') {\n                    throw new ErrnoError(Errno.ENOENT, ex.message, walked, 'getHandle');\n                }\n                convertException(ex, walked, 'getHandle');\n            }\n        }\n        return this._handles.get(path);\n    }\n}\nexport const WebAccess = {\n    name: 'WebAccess',\n    options: {\n        handle: {\n            type: 'object',\n            required: true,\n            description: 'The directory handle to use for the root',\n        },\n    },\n    isAvailable() {\n        return typeof FileSystemHandle == 'function';\n    },\n    create(options) {\n        return new WebAccessFS(options.handle);\n    },\n};\n","import { AsyncTransaction } from '@zenfs/core/backends/store/store.js';\nimport { Async, ErrnoError, InMemory, StoreFS } from '@zenfs/core';\nimport { convertException } from './utils.js';\nfunction wrap(request) {\n    return new Promise((resolve, reject) => {\n        request.onsuccess = () => resolve(request.result);\n        request.onerror = e => {\n            e.preventDefault();\n            reject(convertException(request.error));\n        };\n    });\n}\n/**\n * @hidden\n */\nexport class IndexedDBTransaction extends AsyncTransaction {\n    constructor(tx, store) {\n        super(store);\n        this.tx = tx;\n        this.store = store;\n        this._idb = tx.objectStore(store.name);\n    }\n    get(key) {\n        return wrap(this._idb.get(key.toString()));\n    }\n    async set(key, data) {\n        await wrap(this._idb.put(data, key.toString()));\n    }\n    remove(key) {\n        return wrap(this._idb.delete(key.toString()));\n    }\n    async commit() {\n        this.tx.commit();\n    }\n    async abort() {\n        try {\n            this.tx.abort();\n        }\n        catch (e) {\n            throw convertException(e);\n        }\n    }\n}\nasync function createDB(name, indexedDB = globalThis.indexedDB) {\n    const req = indexedDB.open(name);\n    req.onupgradeneeded = () => {\n        const db = req.result;\n        // This should never happen; we're at version 1. Why does another database exist?\n        if (db.objectStoreNames.contains(name)) {\n            db.deleteObjectStore(name);\n        }\n        db.createObjectStore(name);\n    };\n    const result = await wrap(req);\n    return result;\n}\nexport class IndexedDBStore {\n    constructor(db) {\n        this.db = db;\n    }\n    sync() {\n        throw new Error('Method not implemented.');\n    }\n    get name() {\n        return this.db.name;\n    }\n    clear() {\n        return wrap(this.db.transaction(this.name, 'readwrite').objectStore(this.name).clear());\n    }\n    clearSync() {\n        throw ErrnoError.With('ENOSYS', undefined, 'IndexedDBStore.clearSync');\n    }\n    transaction() {\n        const tx = this.db.transaction(this.name, 'readwrite');\n        return new IndexedDBTransaction(tx, this);\n    }\n}\n/**\n * A file system that uses the IndexedDB key value file system.\n */\nexport const IndexedDB = {\n    name: 'IndexedDB',\n    options: {\n        storeName: {\n            type: 'string',\n            required: false,\n            description: 'The name of this file system. You can have multiple IndexedDB file systems operating at once, but each must have a different name.',\n        },\n        idbFactory: {\n            type: 'object',\n            required: false,\n            description: 'The IDBFactory to use. Defaults to globalThis.indexedDB.',\n        },\n    },\n    async isAvailable(idbFactory = globalThis.indexedDB) {\n        try {\n            if (!(idbFactory instanceof IDBFactory)) {\n                return false;\n            }\n            const req = idbFactory.open('__zenfs_test');\n            await wrap(req);\n            idbFactory.deleteDatabase('__zenfs_test');\n            return true;\n        }\n        catch (e) {\n            idbFactory.deleteDatabase('__zenfs_test');\n            return false;\n        }\n    },\n    async create(options) {\n        const db = await createDB(options.storeName || 'zenfs', options.idbFactory);\n        const store = new IndexedDBStore(db);\n        const fs = new (Async(StoreFS))(store);\n        if (!options?.disableAsyncCache) {\n            fs._sync = InMemory.create({ name: 'idb-cache' });\n        }\n        return fs;\n    },\n};\n","import { ErrnoError, Errno, SimpleTransaction, StoreFS, decode, encode } from '@zenfs/core';\n/**\n * A synchronous key-value store backed by Storage.\n */\nexport class WebStorageStore {\n    get name() {\n        return WebStorage.name;\n    }\n    constructor(_storage) {\n        this._storage = _storage;\n    }\n    clear() {\n        this._storage.clear();\n    }\n    clearSync() {\n        this._storage.clear();\n    }\n    async sync() { }\n    transaction() {\n        // No need to differentiate.\n        return new SimpleTransaction(this);\n    }\n    get(key) {\n        const data = this._storage.getItem(key.toString());\n        if (typeof data != 'string') {\n            return;\n        }\n        return encode(data);\n    }\n    set(key, data) {\n        try {\n            this._storage.setItem(key.toString(), decode(data));\n        }\n        catch (e) {\n            throw new ErrnoError(Errno.ENOSPC, 'Storage is full.');\n        }\n    }\n    delete(key) {\n        try {\n            this._storage.removeItem(key.toString());\n        }\n        catch (e) {\n            throw new ErrnoError(Errno.EIO, 'Unable to delete key ' + key + ': ' + e);\n        }\n    }\n}\n/**\n * A synchronous file system backed by a `Storage` (e.g. localStorage).\n */\nexport const WebStorage = {\n    name: 'WebStorage',\n    options: {\n        storage: {\n            type: 'object',\n            required: false,\n            description: 'The Storage to use. Defaults to globalThis.localStorage.',\n        },\n    },\n    isAvailable(storage = globalThis.localStorage) {\n        return storage instanceof globalThis.Storage;\n    },\n    create({ storage = globalThis.localStorage }) {\n        return new StoreFS(new WebStorageStore(storage));\n    },\n};\n","export * from './access.js';\nexport * from './IndexedDB.js';\nexport * from './Storage.js';\n"],"names":[],"sourceRoot":""}