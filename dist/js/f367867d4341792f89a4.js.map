{"version":3,"file":"js/f367867d4341792f89a4.js","mappings":";;;;;;AAAa;;AAEb,8CAA6C;AAC7C;AACA,CAAC,EAAC;AACF,kBAAkB,GAAG,WAAW;;AAEhC,yCAAyC,mBAAO,CAAC,KAAe;;AAEhE,uCAAuC,uCAAuC;;AAE9E,wBAAwB,2BAA2B,sGAAsG,qBAAqB,mBAAmB,8HAA8H;;AAE/T;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA,2BAA2B;;AAE3B;AACA;;AAEA;AACA;AACA,gDAAgD;;AAEhD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,uCAAuC;AACvC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI;;;AAGJ;AACA,8EAA8E;AAC9E,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;;AAEA,oBAAoB,mBAAmB;AACvC;;AAEA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;;;AAGA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;;AAEH;AACA;;AAEA,wBAAwB,kBAAkB;AAC1C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uCAAuC,GAAG;AAC1C,IAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,oBAAoB;AAC1C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA,wDAAwD;AACxD;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;;AAGN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,sCAAsC;;AAEtC;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;;AAEA,kDAAkD;;AAElD;AACA;AACA;AACA;;AAEA;AACA;AACA,kDAAkD;;AAElD;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,0CAA0C;AAC1C;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,mDAAmD;AACnD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yCAAyC;AACzC,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uCAAuC;;AAEvC;AACA;;AAEA,8CAA8C,sCAAsC;AACpF,wCAAwC;;AAExC;AACA;AACA;;AAEA;AACA;AACA,YAAY;;;AAGZ;;AAEA;AACA;AACA,YAAY;;;AAGZ,wCAAwC;;;AAGxC;AACA;AACA;AACA,WAAW;AACX;AACA,QAAQ;;AAER,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,4CAA4C,QAAQ;AACpD;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,mGAAmG;;AAEnG;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,0BAA0B,uBAAuB;AACjD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,WAAW;AACX;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;;AAEzB,8BAA8B;AAC9B;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;;;AAGA,iGAAiG;AACjG;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU;;;AAGV;AACA;AACA,QAAQ;;;AAGR;;AAEA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;;;AAGA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA,sBAAsB,QAAQ;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wCAAwC,wCAAwC;AAChF;;AAEA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA;AACA;AACA,QAAQ;;;AAGR;AACA;AACA;AACA,QAAQ;;;AAGR;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;;AAEA,sBAAsB,yBAAyB;AAC/C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;;;AAGR;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,WAAW;AACrB;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,UAAU;AACV;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;;AAEzB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kDAAkD;;AAElD;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;;;AAGV;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,YAAY;AACZ;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;;AAEA;AACA;AACA,8BAA8B,mBAAmB;AACjD;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA,sCAAsC;;AAEtC,kDAAkD;;AAElD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO,wBAAwB;AAC7C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA,sCAAsC;;AAEtC;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,gDAAgD;;AAEhD,sFAAsF;;AAEtF;AACA;AACA,QAAQ;;;AAGR;AACA;AACA,QAAQ;AACR;;;AAGA,0BAA0B;AAC1B;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX,UAAU;AACV;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA;;AAEA,sBAAsB,uBAAuB;AAC7C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;;;AAGA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA,sCAAsC;;AAEtC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,uCAAuC;AACvC,gBAAgB,sBAAsB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kDAAkD,gBAAgB;AAClE;AACA;AACA,SAAS;AACT;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,KAAK;AACf,UAAU,KAAK;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD,2BAA2B;;AAE3B;AACA;AACA,QAAQ;AACR,sBAAsB;AACtB,QAAQ;AACR;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,oBAAoB,WAAW;AAC/B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,YAAY;;;AAGZ;AACA;;AAEA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,mGAAmG;AACnG;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,8BAA8B,cAAc;AAC5C,wBAAwB,YAAY;AACpC;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA,sBAAsB,uBAAuB;AAC7C;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV,0BAA0B,mBAAmB;AAC7C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,QAAQ;AACR;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;;;AAGR;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT,QAAQ;AACR;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA,QAAQ;AACR;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,QAAQ;AACR;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT,QAAQ;AACR;AACA;;AAEA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA,gBAAgB;AAChB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;;AAEA,kCAAkC,iBAAiB;AACnD;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,+CAA+C;;AAE/C;AACA;AACA;AACA;AACA;;AAEA;AACA,qEAAqE;;AAErE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA,YAAY;AACZ;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,wBAAwB,iBAAiB;AACzC;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E;;AAE9E;AACA;AACA,UAAU;;;AAGV;;AAEA;AACA;AACA,8CAA8C;;AAE9C;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;;;AAGV;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA,0BAA0B,iBAAiB;AAC3C;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV,sCAAsC;;AAEtC;AACA;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,oEAAoE;;AAEpE;AACA,QAAQ;AACR,4DAA4D;;AAE5D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,mBAAmB;AACvC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,sBAAsB,YAAY;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,yCAAyC;AACzC;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA,+BAA+B,kBAAkB;AACjD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA,IAAI;;;AAGJ;AACA,oBAAoB,mBAAmB;AACvC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;;AAEA,0CAA0C,uBAAuB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;;;AAGA;AACA;AACA,6BAA6B;;AAE7B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;;AAEA,sBAAsB,YAAY;AAClC;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;;;AAGA;AACA,mDAAmD;;AAEnD;AACA,yCAAyC;;AAEzC,mBAAmB;AACnB;AACA;;AAEA,gBAAgB;AAChB;;AAEA,mCAAmC,sDAAsD;AACzF;AACA;AACA,QAAQ;;;AAGR;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,IAAI;;;AAGJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB;AACtB;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,oEAAoE,MAAM;AAC1E,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,4CAA4C,MAAM;AAClD,6CAA6C,MAAM,MAAM;AACzD,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,KAAK;AACf,QAAQ;AACR;AACA,UAAU,KAAK;AACf,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,YAAY;AACzB,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA,aAAa,SAAS;AACtB;AACA,aAAa,SAAS;AACtB;AACA,cAAc,OAAO,uCAAuC;AAC5D;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,0BAA0B;;AAE1B;AACA;;AAEA,wBAAwB,oCAAoC;AAC5D;AACA,6BAA6B;;AAE7B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;;;AAGR;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,YAAY;AACzB,aAAa,KAAK;AAClB,aAAa,KAAK;AAClB,aAAa,SAAS;AACtB;AACA,aAAa,SAAS;AACtB;AACA,aAAa,SAAS;AACtB;AACA,cAAc,QAAQ;AACtB;;;AAGA;AACA;AACA;;AAEA;AACA;AACA,MAAM;;;AAGN;;AAEA,oBAAoB,YAAY;AAChC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,oBAAoB,YAAY;AAChC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB;;AAEzB;AACA;AACA,MAAM;AACN;AACA;;AAEA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;;AAE/C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA,oCAAoC,QAAQ;AAC5C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;;AAE/C;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA,sBAAsB,iBAAiB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;;AAEA;AACA,IAAI;AACJ;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,OAAO;AACf,QAAQ,OAAO;AACf;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,QAAQ,KAAK;AACb,QAAQ,KAAK;AACb;AACA;AACA,KAAK;AACL,uDAAuD;AACvD;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;;AAEA;AACA,2BAA2B;AAC3B;AACA,MAAM;AACN;AACA,oBAAoB;;AAEpB,gBAAgB;AAChB,MAAM;;;AAGN;AACA,0BAA0B;AAC1B,MAAM;AACN;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA,MAAM;;;AAGN;AACA,0CAA0C,iBAAiB;AAC3D;AACA;AACA;AACA;AACA,MAAM;;;AAGN;AACA;AACA;AACA;AACA;AACA,MAAM;;;AAGN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;;;AAGJ;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB;;AAErB;;AAEA,oBAAoB,oBAAoB;AACxC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,oBAAoB,gBAAgB;AACpC;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,IAAI;;;AAGJ;AACA;AACA,wBAAwB,GAAG;;AAE3B,qBAAqB;AACrB;AACA;;AAEA,qBAAqB,gBAAgB;AACrC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,QAAQ;AACR;AACA,iCAAiC;;AAEjC;AACA;AACA,YAAY;;;AAGZ;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,gBAAgB;AACrC;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI;;;AAGJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,uCAAuC;;AAEvC;AACA;AACA,MAAM;AACN;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,uBAAuB;AACvD;AACA,mBAAmB,SAAS,yBAAyB,aAAa;AAClE;AACA;AACA;AACA;;;AAGA;AACA;;AAEA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,uCAAuC;AACvC;AACA,2DAA2D;AAC3D;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,sBAAsB,kBAAkB;AACxC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,IAAI;;;AAGJ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,sBAAsB,YAAY;AAClC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA,mDAAmD;;AAEnD,sCAAsC;;AAEtC;AACA;AACA;;AAEA,sBAAsB,YAAY;AAClC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,8BAA8B,IAAI;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,wEAAwE;;AAExE;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,4BAA4B,2BAA2B;AACvD;AACA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,6CAA6C;AAC7C;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,KAAK;AACL;AACA,iCAAiC;;AAEjC;AACA;AACA;AACA,QAAQ;AACR;;AAEA;AACA;AACA;AACA,QAAQ;;;AAGR;;AAEA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iCAAiC;;AAEjC;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA,qDAAqD;;AAErD;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,+BAA+B,oBAAoB;AACnD,uCAAuC,OAAO;AAC9C;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA,sBAAsB,gCAAgC;AACtD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA,wBAAwB,0BAA0B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP,KAAK;AACL;AACA,iCAAiC;AACjC;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,QAAQ;;;AAGR;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA,QAAQ;AACR;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA,wBAAwB,oBAAoB;AAC5C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,iBAAiB;AACzC;;AAEA;AACA;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,wBAAwB,oBAAoB;AAC5C;AACA;AACA,QAAQ;AACR;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,oBAAoB;AAC5C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,oDAAoD;;AAEpD;AACA,oEAAoE;;AAEpE;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,QAAQ;AACR;;;AAGA;AACA;;AAEA,8BAA8B,cAAc;AAC5C;AACA;;AAEA;AACA;AACA;AACA,QAAQ;;;AAGR;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;;AAE3B,0BAA0B;;AAE1B;AACA;;AAEA;AACA,oDAAoD;AACpD;;AAEA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;;AAEA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,2BAA2B;AAC3B;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,iCAAiC;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0CAA0C;AAC1C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;;AAGA,4BAA4B,qBAAqB;AACjD;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,YAAY;AACzB,aAAa,SAAS;AACtB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB;AACA,aAAa,YAAY;AACzB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;;;AAGN;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;;AAEA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,oBAAoB,sBAAsB;AAC1C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,UAAU;;;AAGV;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA,qCAAqC;;AAErC;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,sBAAsB,YAAY;AAClC;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,YAAY;AAChC;AACA;AACA;;AAEA,sBAAsB,oBAAoB;AAC1C;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;;AAGH,WAAW;AACX;AACA;AACA,kBAAkB;;;;;;;AC3uPL;;AAEb,8CAA6C;AAC7C;AACA,CAAC,EAAC;AACF,kBAAkB;;AAElB,cAAc,mBAAO,CAAC,IAAwC;;AAE9D,oBAAoB,mBAAO,CAAC,KAA0D;;AAEtF,kCAAkC;;AAElC,8BAA8B;;AAE9B,kDAAkD,gBAAgB,gEAAgE,wDAAwD,6DAA6D,sDAAsD;;AAE7S,uCAAuC,uDAAuD,uCAAuC,SAAS,OAAO,oBAAoB;;AAEzK,yCAAyC,0GAA0G,wBAAwB,eAAe,eAAe,gBAAgB,YAAY,MAAM,wBAAwB,+BAA+B,aAAa,qBAAqB,uCAAuC,cAAc,WAAW,YAAY,UAAU,MAAM,mDAAmD,UAAU,sBAAsB;;AAEnf,gCAAgC;;AAEhC,wBAAwB,2BAA2B,sGAAsG,qBAAqB,mBAAmB,8HAA8H;;AAE/T,kDAAkD,0CAA0C;;AAE5F,4CAA4C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD;;AAE/P,8DAA8D,sEAAsE,8DAA8D,kDAAkD,iBAAiB,GAAG;;AAExQ;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,sBAAsB;AACtB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,uDAAuD;;AAEvD;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;;AAEA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;;;AAGJ;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,6FAA6F,aAAa;AAC1G;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAI;;AAEX;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA,OAAO;;AAEP,yBAAyB;AACzB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,eAAe;;AAEf;AACA;AACA,QAAQ;AACR;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,wBAAwB;;AAExB;AACA;AACA,QAAQ;AACR;AACA;;AAEA;;AAEA,2DAA2D;;;AAG3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,KAAK;AACT,IAAI,KAAK;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oBAAoB,4BAA4B;AAChD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kBAAkB;;;;;;;ACr4CL;;AAEb,8CAA6C;AAC7C;AACA,CAAC,EAAC;AACF,6CAA4C;AAC5C;AACA;AACA;AACA;AACA,CAAC,EAAC;AACF,2CAA0C;AAC1C;AACA;AACA;AACA;AACA,CAAC,EAAC;AACF,mBAAmB;;AAEnB,yCAAyC,mBAAO,CAAC,KAAiB;;AAElE,wCAAwC,mBAAO,CAAC,KAAa;;AAE7D,uCAAuC,uCAAuC;;AAE9E;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;;;;;;AC/Da;;AAEb,8CAA6C;AAC7C;AACA,CAAC,EAAC;AACF,kBAAkB;;AAElB,kDAAkD,0CAA0C;;AAE5F,4CAA4C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD;;AAE/P,8DAA8D,sEAAsE,8DAA8D,kDAAkD,iBAAiB,GAAG;;AAExQ;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,GAAG;;AAEH;AACA,CAAC;;AAED,kBAAkB","sources":["webpack://fausteditorweb/./node_modules/monaco-vim/lib/cm/keymap_vim.js","webpack://fausteditorweb/./node_modules/monaco-vim/lib/cm_adapter.js","webpack://fausteditorweb/./node_modules/monaco-vim/lib/index.js","webpack://fausteditorweb/./node_modules/monaco-vim/lib/statusbar.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = exports.Vim = void 0;\n\nvar _cm_adapter = _interopRequireDefault(require(\"../cm_adapter\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\nvar Pos = _cm_adapter[\"default\"].Pos;\n\nfunction transformCursor(cm, range) {\n  var vim = cm.state.vim;\n  if (!vim || vim.insertMode) return range.head;\n  var head = vim.sel.head;\n  if (!head) return range.head;\n\n  if (vim.visualBlock) {\n    if (range.head.line != head.line) {\n      return;\n    }\n  }\n\n  if (range.from() == range.anchor && !range.empty()) {\n    if (range.head.line == head.line && range.head.ch != head.ch) return new Pos(range.head.line, range.head.ch - 1);\n  }\n\n  return range.head;\n}\n\nvar defaultKeymap = [// Key to key mapping. This goes first to make it possible to override\n// existing mappings.\n{\n  keys: \"<Left>\",\n  type: \"keyToKey\",\n  toKeys: \"h\"\n}, {\n  keys: \"<Right>\",\n  type: \"keyToKey\",\n  toKeys: \"l\"\n}, {\n  keys: \"<Up>\",\n  type: \"keyToKey\",\n  toKeys: \"k\"\n}, {\n  keys: \"<Down>\",\n  type: \"keyToKey\",\n  toKeys: \"j\"\n}, {\n  keys: \"g<Up>\",\n  type: \"keyToKey\",\n  toKeys: \"gk\"\n}, {\n  keys: \"g<Down>\",\n  type: \"keyToKey\",\n  toKeys: \"gj\"\n}, {\n  keys: \"<Space>\",\n  type: \"keyToKey\",\n  toKeys: \"l\"\n}, {\n  keys: \"<BS>\",\n  type: \"keyToKey\",\n  toKeys: \"h\",\n  context: \"normal\"\n}, {\n  keys: \"<Del>\",\n  type: \"keyToKey\",\n  toKeys: \"x\",\n  context: \"normal\"\n}, {\n  keys: \"<C-Space>\",\n  type: \"keyToKey\",\n  toKeys: \"W\"\n}, {\n  keys: \"<C-BS>\",\n  type: \"keyToKey\",\n  toKeys: \"B\",\n  context: \"normal\"\n}, {\n  keys: \"<S-Space>\",\n  type: \"keyToKey\",\n  toKeys: \"w\"\n}, {\n  keys: \"<S-BS>\",\n  type: \"keyToKey\",\n  toKeys: \"b\",\n  context: \"normal\"\n}, {\n  keys: \"<C-n>\",\n  type: \"keyToKey\",\n  toKeys: \"j\"\n}, {\n  keys: \"<C-p>\",\n  type: \"keyToKey\",\n  toKeys: \"k\"\n}, {\n  keys: \"<C-[>\",\n  type: \"keyToKey\",\n  toKeys: \"<Esc>\"\n}, {\n  keys: \"<C-c>\",\n  type: \"keyToKey\",\n  toKeys: \"<Esc>\"\n}, {\n  keys: \"<C-[>\",\n  type: \"keyToKey\",\n  toKeys: \"<Esc>\",\n  context: \"insert\"\n}, {\n  keys: \"<C-c>\",\n  type: \"keyToKey\",\n  toKeys: \"<Esc>\",\n  context: \"insert\"\n}, {\n  keys: \"s\",\n  type: \"keyToKey\",\n  toKeys: \"cl\",\n  context: \"normal\"\n}, {\n  keys: \"s\",\n  type: \"keyToKey\",\n  toKeys: \"c\",\n  context: \"visual\"\n}, {\n  keys: \"S\",\n  type: \"keyToKey\",\n  toKeys: \"cc\",\n  context: \"normal\"\n}, {\n  keys: \"S\",\n  type: \"keyToKey\",\n  toKeys: \"VdO\",\n  context: \"visual\"\n}, {\n  keys: \"<Home>\",\n  type: \"keyToKey\",\n  toKeys: \"0\"\n}, {\n  keys: \"<End>\",\n  type: \"keyToKey\",\n  toKeys: \"$\"\n}, {\n  keys: \"<PageUp>\",\n  type: \"keyToKey\",\n  toKeys: \"<C-b>\"\n}, {\n  keys: \"<PageDown>\",\n  type: \"keyToKey\",\n  toKeys: \"<C-f>\"\n}, {\n  keys: \"<CR>\",\n  type: \"keyToKey\",\n  toKeys: \"j^\",\n  context: \"normal\"\n}, {\n  keys: \"<Ins>\",\n  type: \"keyToKey\",\n  toKeys: \"i\",\n  context: \"normal\"\n}, {\n  keys: \"<Ins>\",\n  type: \"action\",\n  action: \"toggleOverwrite\",\n  context: \"insert\"\n}, // Motions\n{\n  keys: \"H\",\n  type: \"motion\",\n  motion: \"moveToTopLine\",\n  motionArgs: {\n    linewise: true,\n    toJumplist: true\n  }\n}, {\n  keys: \"M\",\n  type: \"motion\",\n  motion: \"moveToMiddleLine\",\n  motionArgs: {\n    linewise: true,\n    toJumplist: true\n  }\n}, {\n  keys: \"L\",\n  type: \"motion\",\n  motion: \"moveToBottomLine\",\n  motionArgs: {\n    linewise: true,\n    toJumplist: true\n  }\n}, {\n  keys: \"h\",\n  type: \"motion\",\n  motion: \"moveByCharacters\",\n  motionArgs: {\n    forward: false\n  }\n}, {\n  keys: \"l\",\n  type: \"motion\",\n  motion: \"moveByCharacters\",\n  motionArgs: {\n    forward: true\n  }\n}, {\n  keys: \"j\",\n  type: \"motion\",\n  motion: \"moveByLines\",\n  motionArgs: {\n    forward: true,\n    linewise: true\n  }\n}, {\n  keys: \"k\",\n  type: \"motion\",\n  motion: \"moveByLines\",\n  motionArgs: {\n    forward: false,\n    linewise: true\n  }\n}, {\n  keys: \"gj\",\n  type: \"motion\",\n  motion: \"moveByDisplayLines\",\n  motionArgs: {\n    forward: true\n  }\n}, {\n  keys: \"gk\",\n  type: \"motion\",\n  motion: \"moveByDisplayLines\",\n  motionArgs: {\n    forward: false\n  }\n}, {\n  keys: \"w\",\n  type: \"motion\",\n  motion: \"moveByWords\",\n  motionArgs: {\n    forward: true,\n    wordEnd: false\n  }\n}, {\n  keys: \"W\",\n  type: \"motion\",\n  motion: \"moveByWords\",\n  motionArgs: {\n    forward: true,\n    wordEnd: false,\n    bigWord: true\n  }\n}, {\n  keys: \"e\",\n  type: \"motion\",\n  motion: \"moveByWords\",\n  motionArgs: {\n    forward: true,\n    wordEnd: true,\n    inclusive: true\n  }\n}, {\n  keys: \"E\",\n  type: \"motion\",\n  motion: \"moveByWords\",\n  motionArgs: {\n    forward: true,\n    wordEnd: true,\n    bigWord: true,\n    inclusive: true\n  }\n}, {\n  keys: \"b\",\n  type: \"motion\",\n  motion: \"moveByWords\",\n  motionArgs: {\n    forward: false,\n    wordEnd: false\n  }\n}, {\n  keys: \"B\",\n  type: \"motion\",\n  motion: \"moveByWords\",\n  motionArgs: {\n    forward: false,\n    wordEnd: false,\n    bigWord: true\n  }\n}, {\n  keys: \"ge\",\n  type: \"motion\",\n  motion: \"moveByWords\",\n  motionArgs: {\n    forward: false,\n    wordEnd: true,\n    inclusive: true\n  }\n}, {\n  keys: \"gE\",\n  type: \"motion\",\n  motion: \"moveByWords\",\n  motionArgs: {\n    forward: false,\n    wordEnd: true,\n    bigWord: true,\n    inclusive: true\n  }\n}, {\n  keys: \"{\",\n  type: \"motion\",\n  motion: \"moveByParagraph\",\n  motionArgs: {\n    forward: false,\n    toJumplist: true\n  }\n}, {\n  keys: \"}\",\n  type: \"motion\",\n  motion: \"moveByParagraph\",\n  motionArgs: {\n    forward: true,\n    toJumplist: true\n  }\n}, {\n  keys: \"(\",\n  type: \"motion\",\n  motion: \"moveBySentence\",\n  motionArgs: {\n    forward: false\n  }\n}, {\n  keys: \")\",\n  type: \"motion\",\n  motion: \"moveBySentence\",\n  motionArgs: {\n    forward: true\n  }\n}, {\n  keys: \"<C-f>\",\n  type: \"motion\",\n  motion: \"moveByPage\",\n  motionArgs: {\n    forward: true\n  }\n}, {\n  keys: \"<C-b>\",\n  type: \"motion\",\n  motion: \"moveByPage\",\n  motionArgs: {\n    forward: false\n  }\n}, {\n  keys: \"<C-d>\",\n  type: \"motion\",\n  motion: \"moveByScroll\",\n  motionArgs: {\n    forward: true,\n    explicitRepeat: true\n  }\n}, {\n  keys: \"<C-u>\",\n  type: \"motion\",\n  motion: \"moveByScroll\",\n  motionArgs: {\n    forward: false,\n    explicitRepeat: true\n  }\n}, {\n  keys: \"gg\",\n  type: \"motion\",\n  motion: \"moveToLineOrEdgeOfDocument\",\n  motionArgs: {\n    forward: false,\n    explicitRepeat: true,\n    linewise: true,\n    toJumplist: true\n  }\n}, {\n  keys: \"G\",\n  type: \"motion\",\n  motion: \"moveToLineOrEdgeOfDocument\",\n  motionArgs: {\n    forward: true,\n    explicitRepeat: true,\n    linewise: true,\n    toJumplist: true\n  }\n}, {\n  keys: \"g$\",\n  type: \"motion\",\n  motion: \"moveToEndOfDisplayLine\"\n}, {\n  keys: \"g^\",\n  type: \"motion\",\n  motion: \"moveToStartOfDisplayLine\"\n}, {\n  keys: \"g0\",\n  type: \"motion\",\n  motion: \"moveToStartOfDisplayLine\"\n}, {\n  keys: \"0\",\n  type: \"motion\",\n  motion: \"moveToStartOfLine\"\n}, {\n  keys: \"^\",\n  type: \"motion\",\n  motion: \"moveToFirstNonWhiteSpaceCharacter\"\n}, {\n  keys: \"+\",\n  type: \"motion\",\n  motion: \"moveByLines\",\n  motionArgs: {\n    forward: true,\n    toFirstChar: true\n  }\n}, {\n  keys: \"-\",\n  type: \"motion\",\n  motion: \"moveByLines\",\n  motionArgs: {\n    forward: false,\n    toFirstChar: true\n  }\n}, {\n  keys: \"_\",\n  type: \"motion\",\n  motion: \"moveByLines\",\n  motionArgs: {\n    forward: true,\n    toFirstChar: true,\n    repeatOffset: -1\n  }\n}, {\n  keys: \"$\",\n  type: \"motion\",\n  motion: \"moveToEol\",\n  motionArgs: {\n    inclusive: true\n  }\n}, {\n  keys: \"%\",\n  type: \"motion\",\n  motion: \"moveToMatchedSymbol\",\n  motionArgs: {\n    inclusive: true,\n    toJumplist: true\n  }\n}, {\n  keys: \"f<character>\",\n  type: \"motion\",\n  motion: \"moveToCharacter\",\n  motionArgs: {\n    forward: true,\n    inclusive: true\n  }\n}, {\n  keys: \"F<character>\",\n  type: \"motion\",\n  motion: \"moveToCharacter\",\n  motionArgs: {\n    forward: false\n  }\n}, {\n  keys: \"t<character>\",\n  type: \"motion\",\n  motion: \"moveTillCharacter\",\n  motionArgs: {\n    forward: true,\n    inclusive: true\n  }\n}, {\n  keys: \"T<character>\",\n  type: \"motion\",\n  motion: \"moveTillCharacter\",\n  motionArgs: {\n    forward: false\n  }\n}, {\n  keys: \";\",\n  type: \"motion\",\n  motion: \"repeatLastCharacterSearch\",\n  motionArgs: {\n    forward: true\n  }\n}, {\n  keys: \",\",\n  type: \"motion\",\n  motion: \"repeatLastCharacterSearch\",\n  motionArgs: {\n    forward: false\n  }\n}, {\n  keys: \"'<character>\",\n  type: \"motion\",\n  motion: \"goToMark\",\n  motionArgs: {\n    toJumplist: true,\n    linewise: true\n  }\n}, {\n  keys: \"`<character>\",\n  type: \"motion\",\n  motion: \"goToMark\",\n  motionArgs: {\n    toJumplist: true\n  }\n}, {\n  keys: \"]`\",\n  type: \"motion\",\n  motion: \"jumpToMark\",\n  motionArgs: {\n    forward: true\n  }\n}, {\n  keys: \"[`\",\n  type: \"motion\",\n  motion: \"jumpToMark\",\n  motionArgs: {\n    forward: false\n  }\n}, {\n  keys: \"]'\",\n  type: \"motion\",\n  motion: \"jumpToMark\",\n  motionArgs: {\n    forward: true,\n    linewise: true\n  }\n}, {\n  keys: \"['\",\n  type: \"motion\",\n  motion: \"jumpToMark\",\n  motionArgs: {\n    forward: false,\n    linewise: true\n  }\n}, // the next two aren't motions but must come before more general motion declarations\n{\n  keys: \"]p\",\n  type: \"action\",\n  action: \"paste\",\n  isEdit: true,\n  actionArgs: {\n    after: true,\n    isEdit: true,\n    matchIndent: true\n  }\n}, {\n  keys: \"[p\",\n  type: \"action\",\n  action: \"paste\",\n  isEdit: true,\n  actionArgs: {\n    after: false,\n    isEdit: true,\n    matchIndent: true\n  }\n}, {\n  keys: \"]<character>\",\n  type: \"motion\",\n  motion: \"moveToSymbol\",\n  motionArgs: {\n    forward: true,\n    toJumplist: true\n  }\n}, {\n  keys: \"[<character>\",\n  type: \"motion\",\n  motion: \"moveToSymbol\",\n  motionArgs: {\n    forward: false,\n    toJumplist: true\n  }\n}, {\n  keys: \"|\",\n  type: \"motion\",\n  motion: \"moveToColumn\"\n}, {\n  keys: \"o\",\n  type: \"motion\",\n  motion: \"moveToOtherHighlightedEnd\",\n  context: \"visual\"\n}, {\n  keys: \"O\",\n  type: \"motion\",\n  motion: \"moveToOtherHighlightedEnd\",\n  motionArgs: {\n    sameLine: true\n  },\n  context: \"visual\"\n}, // Operators\n{\n  keys: \"d\",\n  type: \"operator\",\n  operator: \"delete\"\n}, {\n  keys: \"y\",\n  type: \"operator\",\n  operator: \"yank\"\n}, {\n  keys: \"c\",\n  type: \"operator\",\n  operator: \"change\"\n}, {\n  keys: \"=\",\n  type: \"operator\",\n  operator: \"indentAuto\"\n}, {\n  keys: \">\",\n  type: \"operator\",\n  operator: \"indent\",\n  operatorArgs: {\n    indentRight: true\n  }\n}, {\n  keys: \"<\",\n  type: \"operator\",\n  operator: \"indent\",\n  operatorArgs: {\n    indentRight: false\n  }\n}, {\n  keys: \"g~\",\n  type: \"operator\",\n  operator: \"changeCase\"\n}, {\n  keys: \"gu\",\n  type: \"operator\",\n  operator: \"changeCase\",\n  operatorArgs: {\n    toLower: true\n  },\n  isEdit: true\n}, {\n  keys: \"gU\",\n  type: \"operator\",\n  operator: \"changeCase\",\n  operatorArgs: {\n    toLower: false\n  },\n  isEdit: true\n}, {\n  keys: \"n\",\n  type: \"motion\",\n  motion: \"findNext\",\n  motionArgs: {\n    forward: true,\n    toJumplist: true\n  }\n}, {\n  keys: \"N\",\n  type: \"motion\",\n  motion: \"findNext\",\n  motionArgs: {\n    forward: false,\n    toJumplist: true\n  }\n}, {\n  keys: \"gn\",\n  type: \"motion\",\n  motion: \"findAndSelectNextInclusive\",\n  motionArgs: {\n    forward: true\n  }\n}, {\n  keys: \"gN\",\n  type: \"motion\",\n  motion: \"findAndSelectNextInclusive\",\n  motionArgs: {\n    forward: false\n  }\n}, // Operator-Motion dual commands\n{\n  keys: \"x\",\n  type: \"operatorMotion\",\n  operator: \"delete\",\n  motion: \"moveByCharacters\",\n  motionArgs: {\n    forward: true\n  },\n  operatorMotionArgs: {\n    visualLine: false\n  }\n}, {\n  keys: \"X\",\n  type: \"operatorMotion\",\n  operator: \"delete\",\n  motion: \"moveByCharacters\",\n  motionArgs: {\n    forward: false\n  },\n  operatorMotionArgs: {\n    visualLine: true\n  }\n}, {\n  keys: \"D\",\n  type: \"operatorMotion\",\n  operator: \"delete\",\n  motion: \"moveToEol\",\n  motionArgs: {\n    inclusive: true\n  },\n  context: \"normal\"\n}, {\n  keys: \"D\",\n  type: \"operator\",\n  operator: \"delete\",\n  operatorArgs: {\n    linewise: true\n  },\n  context: \"visual\"\n}, {\n  keys: \"Y\",\n  type: \"operatorMotion\",\n  operator: \"yank\",\n  motion: \"expandToLine\",\n  motionArgs: {\n    linewise: true\n  },\n  context: \"normal\"\n}, {\n  keys: \"Y\",\n  type: \"operator\",\n  operator: \"yank\",\n  operatorArgs: {\n    linewise: true\n  },\n  context: \"visual\"\n}, {\n  keys: \"C\",\n  type: \"operatorMotion\",\n  operator: \"change\",\n  motion: \"moveToEol\",\n  motionArgs: {\n    inclusive: true\n  },\n  context: \"normal\"\n}, {\n  keys: \"C\",\n  type: \"operator\",\n  operator: \"change\",\n  operatorArgs: {\n    linewise: true\n  },\n  context: \"visual\"\n}, {\n  keys: \"~\",\n  type: \"operatorMotion\",\n  operator: \"changeCase\",\n  motion: \"moveByCharacters\",\n  motionArgs: {\n    forward: true\n  },\n  operatorArgs: {\n    shouldMoveCursor: true\n  },\n  context: \"normal\"\n}, {\n  keys: \"~\",\n  type: \"operator\",\n  operator: \"changeCase\",\n  context: \"visual\"\n}, {\n  keys: \"<C-u>\",\n  type: \"operatorMotion\",\n  operator: \"delete\",\n  motion: \"moveToStartOfLine\",\n  context: \"insert\"\n}, {\n  keys: \"<C-w>\",\n  type: \"operatorMotion\",\n  operator: \"delete\",\n  motion: \"moveByWords\",\n  motionArgs: {\n    forward: false,\n    wordEnd: false\n  },\n  context: \"insert\"\n}, //ignore C-w in normal mode\n{\n  keys: \"<C-w>\",\n  type: \"idle\",\n  context: \"normal\"\n}, // Actions\n{\n  keys: \"<C-i>\",\n  type: \"action\",\n  action: \"jumpListWalk\",\n  actionArgs: {\n    forward: true\n  }\n}, {\n  keys: \"<C-o>\",\n  type: \"action\",\n  action: \"jumpListWalk\",\n  actionArgs: {\n    forward: false\n  }\n}, {\n  keys: \"<C-e>\",\n  type: \"action\",\n  action: \"scroll\",\n  actionArgs: {\n    forward: true,\n    linewise: true\n  }\n}, {\n  keys: \"<C-y>\",\n  type: \"action\",\n  action: \"scroll\",\n  actionArgs: {\n    forward: false,\n    linewise: true\n  }\n}, {\n  keys: \"a\",\n  type: \"action\",\n  action: \"enterInsertMode\",\n  isEdit: true,\n  actionArgs: {\n    insertAt: \"charAfter\"\n  },\n  context: \"normal\"\n}, {\n  keys: \"A\",\n  type: \"action\",\n  action: \"enterInsertMode\",\n  isEdit: true,\n  actionArgs: {\n    insertAt: \"eol\"\n  },\n  context: \"normal\"\n}, {\n  keys: \"A\",\n  type: \"action\",\n  action: \"enterInsertMode\",\n  isEdit: true,\n  actionArgs: {\n    insertAt: \"endOfSelectedArea\"\n  },\n  context: \"visual\"\n}, {\n  keys: \"i\",\n  type: \"action\",\n  action: \"enterInsertMode\",\n  isEdit: true,\n  actionArgs: {\n    insertAt: \"inplace\"\n  },\n  context: \"normal\"\n}, {\n  keys: \"gi\",\n  type: \"action\",\n  action: \"enterInsertMode\",\n  isEdit: true,\n  actionArgs: {\n    insertAt: \"lastEdit\"\n  },\n  context: \"normal\"\n}, {\n  keys: \"I\",\n  type: \"action\",\n  action: \"enterInsertMode\",\n  isEdit: true,\n  actionArgs: {\n    insertAt: \"firstNonBlank\"\n  },\n  context: \"normal\"\n}, {\n  keys: \"gI\",\n  type: \"action\",\n  action: \"enterInsertMode\",\n  isEdit: true,\n  actionArgs: {\n    insertAt: \"bol\"\n  },\n  context: \"normal\"\n}, {\n  keys: \"I\",\n  type: \"action\",\n  action: \"enterInsertMode\",\n  isEdit: true,\n  actionArgs: {\n    insertAt: \"startOfSelectedArea\"\n  },\n  context: \"visual\"\n}, {\n  keys: \"o\",\n  type: \"action\",\n  action: \"newLineAndEnterInsertMode\",\n  isEdit: true,\n  interlaceInsertRepeat: true,\n  actionArgs: {\n    after: true\n  },\n  context: \"normal\"\n}, {\n  keys: \"O\",\n  type: \"action\",\n  action: \"newLineAndEnterInsertMode\",\n  isEdit: true,\n  interlaceInsertRepeat: true,\n  actionArgs: {\n    after: false\n  },\n  context: \"normal\"\n}, {\n  keys: \"v\",\n  type: \"action\",\n  action: \"toggleVisualMode\"\n}, {\n  keys: \"V\",\n  type: \"action\",\n  action: \"toggleVisualMode\",\n  actionArgs: {\n    linewise: true\n  }\n}, {\n  keys: \"<C-v>\",\n  type: \"action\",\n  action: \"toggleVisualMode\",\n  actionArgs: {\n    blockwise: true\n  }\n}, {\n  keys: \"<C-q>\",\n  type: \"action\",\n  action: \"toggleVisualMode\",\n  actionArgs: {\n    blockwise: true\n  }\n}, {\n  keys: \"gv\",\n  type: \"action\",\n  action: \"reselectLastSelection\"\n}, {\n  keys: \"J\",\n  type: \"action\",\n  action: \"joinLines\",\n  isEdit: true\n}, {\n  keys: \"gJ\",\n  type: \"action\",\n  action: \"joinLines\",\n  actionArgs: {\n    keepSpaces: true\n  },\n  isEdit: true\n}, {\n  keys: \"p\",\n  type: \"action\",\n  action: \"paste\",\n  isEdit: true,\n  actionArgs: {\n    after: true,\n    isEdit: true\n  }\n}, {\n  keys: \"P\",\n  type: \"action\",\n  action: \"paste\",\n  isEdit: true,\n  actionArgs: {\n    after: false,\n    isEdit: true\n  }\n}, {\n  keys: \"r<character>\",\n  type: \"action\",\n  action: \"replace\",\n  isEdit: true\n}, {\n  keys: \"@<character>\",\n  type: \"action\",\n  action: \"replayMacro\"\n}, {\n  keys: \"q<character>\",\n  type: \"action\",\n  action: \"enterMacroRecordMode\"\n}, // Handle Replace-mode as a special case of insert mode.\n{\n  keys: \"R\",\n  type: \"action\",\n  action: \"enterInsertMode\",\n  isEdit: true,\n  actionArgs: {\n    replace: true\n  },\n  context: \"normal\"\n}, {\n  keys: \"R\",\n  type: \"operator\",\n  operator: \"change\",\n  operatorArgs: {\n    linewise: true,\n    fullLine: true\n  },\n  context: \"visual\",\n  exitVisualBlock: true\n}, {\n  keys: \"u\",\n  type: \"action\",\n  action: \"undo\",\n  context: \"normal\"\n}, {\n  keys: \"u\",\n  type: \"operator\",\n  operator: \"changeCase\",\n  operatorArgs: {\n    toLower: true\n  },\n  context: \"visual\",\n  isEdit: true\n}, {\n  keys: \"U\",\n  type: \"operator\",\n  operator: \"changeCase\",\n  operatorArgs: {\n    toLower: false\n  },\n  context: \"visual\",\n  isEdit: true\n}, {\n  keys: \"<C-r>\",\n  type: \"action\",\n  action: \"redo\"\n}, {\n  keys: \"m<character>\",\n  type: \"action\",\n  action: \"setMark\"\n}, {\n  keys: '\"<character>',\n  type: \"action\",\n  action: \"setRegister\"\n}, {\n  keys: \"zz\",\n  type: \"action\",\n  action: \"scrollToCursor\",\n  actionArgs: {\n    position: \"center\"\n  }\n}, {\n  keys: \"z.\",\n  type: \"action\",\n  action: \"scrollToCursor\",\n  actionArgs: {\n    position: \"center\"\n  },\n  motion: \"moveToFirstNonWhiteSpaceCharacter\"\n}, {\n  keys: \"zt\",\n  type: \"action\",\n  action: \"scrollToCursor\",\n  actionArgs: {\n    position: \"top\"\n  }\n}, {\n  keys: \"z<CR>\",\n  type: \"action\",\n  action: \"scrollToCursor\",\n  actionArgs: {\n    position: \"top\"\n  },\n  motion: \"moveToFirstNonWhiteSpaceCharacter\"\n}, {\n  keys: \"z-\",\n  type: \"action\",\n  action: \"scrollToCursor\",\n  actionArgs: {\n    position: \"bottom\"\n  }\n}, {\n  keys: \"zb\",\n  type: \"action\",\n  action: \"scrollToCursor\",\n  actionArgs: {\n    position: \"bottom\"\n  },\n  motion: \"moveToFirstNonWhiteSpaceCharacter\"\n}, {\n  keys: \".\",\n  type: \"action\",\n  action: \"repeatLastEdit\"\n}, {\n  keys: \"<C-a>\",\n  type: \"action\",\n  action: \"incrementNumberToken\",\n  isEdit: true,\n  actionArgs: {\n    increase: true,\n    backtrack: false\n  }\n}, {\n  keys: \"<C-x>\",\n  type: \"action\",\n  action: \"incrementNumberToken\",\n  isEdit: true,\n  actionArgs: {\n    increase: false,\n    backtrack: false\n  }\n}, {\n  keys: \"<C-t>\",\n  type: \"action\",\n  action: \"indent\",\n  actionArgs: {\n    indentRight: true\n  },\n  context: \"insert\"\n}, {\n  keys: \"<C-d>\",\n  type: \"action\",\n  action: \"indent\",\n  actionArgs: {\n    indentRight: false\n  },\n  context: \"insert\"\n}, // Text object motions\n{\n  keys: \"a<character>\",\n  type: \"motion\",\n  motion: \"textObjectManipulation\"\n}, {\n  keys: \"i<character>\",\n  type: \"motion\",\n  motion: \"textObjectManipulation\",\n  motionArgs: {\n    textObjectInner: true\n  }\n}, // Search\n{\n  keys: \"/\",\n  type: \"search\",\n  searchArgs: {\n    forward: true,\n    querySrc: \"prompt\",\n    toJumplist: true\n  }\n}, {\n  keys: \"?\",\n  type: \"search\",\n  searchArgs: {\n    forward: false,\n    querySrc: \"prompt\",\n    toJumplist: true\n  }\n}, {\n  keys: \"*\",\n  type: \"search\",\n  searchArgs: {\n    forward: true,\n    querySrc: \"wordUnderCursor\",\n    wholeWordOnly: true,\n    toJumplist: true\n  }\n}, {\n  keys: \"#\",\n  type: \"search\",\n  searchArgs: {\n    forward: false,\n    querySrc: \"wordUnderCursor\",\n    wholeWordOnly: true,\n    toJumplist: true\n  }\n}, {\n  keys: \"g*\",\n  type: \"search\",\n  searchArgs: {\n    forward: true,\n    querySrc: \"wordUnderCursor\",\n    toJumplist: true\n  }\n}, {\n  keys: \"g#\",\n  type: \"search\",\n  searchArgs: {\n    forward: false,\n    querySrc: \"wordUnderCursor\",\n    toJumplist: true\n  }\n}, // Ex command\n{\n  keys: \":\",\n  type: \"ex\"\n}];\nvar defaultKeymapLength = defaultKeymap.length;\n/**\n * Ex commands\n * Care must be taken when adding to the default Ex command map. For any\n * pair of commands that have a shared prefix, at least one of their\n * shortNames must not match the prefix of the other command.\n */\n\nvar defaultExCommandMap = [{\n  name: \"colorscheme\",\n  shortName: \"colo\"\n}, {\n  name: \"map\"\n}, {\n  name: \"imap\",\n  shortName: \"im\"\n}, {\n  name: \"nmap\",\n  shortName: \"nm\"\n}, {\n  name: \"vmap\",\n  shortName: \"vm\"\n}, {\n  name: \"unmap\"\n}, {\n  name: \"write\",\n  shortName: \"w\"\n}, {\n  name: \"undo\",\n  shortName: \"u\"\n}, {\n  name: \"redo\",\n  shortName: \"red\"\n}, {\n  name: \"set\",\n  shortName: \"se\"\n}, {\n  name: \"setlocal\",\n  shortName: \"setl\"\n}, {\n  name: \"setglobal\",\n  shortName: \"setg\"\n}, {\n  name: \"sort\",\n  shortName: \"sor\"\n}, {\n  name: \"substitute\",\n  shortName: \"s\",\n  possiblyAsync: true\n}, {\n  name: \"nohlsearch\",\n  shortName: \"noh\"\n}, {\n  name: \"yank\",\n  shortName: \"y\"\n}, {\n  name: \"delmarks\",\n  shortName: \"delm\"\n}, {\n  name: \"registers\",\n  shortName: \"reg\",\n  excludeFromCommandHistory: true\n}, {\n  name: \"vglobal\",\n  shortName: \"v\"\n}, {\n  name: \"global\",\n  shortName: \"g\"\n}];\n\nvar Vim = function Vim() {\n  function enterVimMode(cm) {\n    cm.setOption(\"disableInput\", true);\n    cm.setOption(\"showCursorWhenSelecting\", false);\n\n    _cm_adapter[\"default\"].signal(cm, \"vim-mode-change\", {\n      mode: \"normal\"\n    });\n\n    cm.on(\"cursorActivity\", onCursorActivity);\n    maybeInitVimState(cm); // CodeMirror.on(cm.getInputField(), 'paste', getOnPasteFn(cm));\n\n    cm.enterVimMode();\n  }\n\n  function leaveVimMode(cm) {\n    cm.setOption(\"disableInput\", false);\n    cm.off(\"cursorActivity\", onCursorActivity); // CodeMirror.off(cm.getInputField(), 'paste', getOnPasteFn(cm));\n\n    cm.state.vim = null;\n    if (highlightTimeout) clearTimeout(highlightTimeout);\n    cm.leaveVimMode();\n  }\n\n  function detachVimMap(cm, next) {\n    cm.attached = false;\n\n    if (this == _cm_adapter[\"default\"].keyMap.vim) {\n      cm.options.$customCursor = null; // CodeMirror.rmClass(cm.getWrapperElement(), \"cm-fat-cursor\");\n    }\n\n    if (!next || next.attach != attachVimMap) leaveVimMode(cm);\n  }\n\n  function attachVimMap(cm, prev) {\n    if (this == _cm_adapter[\"default\"].keyMap.vim) {\n      cm.attached = true;\n      if (cm.curOp) cm.curOp.selectionChanged = true;\n      cm.options.$customCursor = transformCursor;\n    }\n\n    if (!prev || prev.attach != attachVimMap) enterVimMode(cm);\n  } // Deprecated, simply setting the keymap works again.\n\n\n  _cm_adapter[\"default\"].defineOption(\"vimMode\", false, function (cm, val, prev) {\n    if (val && cm.getOption(\"keyMap\") != \"vim\") cm.setOption(\"keyMap\", \"vim\");else if (!val && prev != _cm_adapter[\"default\"].Init && /^vim/.test(cm.getOption(\"keyMap\"))) cm.setOption(\"keyMap\", \"default\");\n  });\n\n  function cmKey(key, cm) {\n    if (!cm) {\n      return undefined;\n    }\n\n    if (this[key]) {\n      return this[key];\n    }\n\n    var vimKey = cmKeyToVimKey(key);\n\n    if (!vimKey) {\n      return false;\n    }\n\n    var cmd = vimApi.findKey(cm, vimKey);\n\n    if (typeof cmd == \"function\") {\n      _cm_adapter[\"default\"].signal(cm, \"vim-keypress\", vimKey);\n    }\n\n    return cmd;\n  }\n\n  var modifiers = {\n    Shift: \"S\",\n    Ctrl: \"C\",\n    Alt: \"A\",\n    Cmd: \"D\",\n    Mod: \"A\",\n    CapsLock: \"\"\n  };\n  var specialKeys = {\n    Enter: \"CR\",\n    Backspace: \"BS\",\n    Delete: \"Del\",\n    Insert: \"Ins\"\n  };\n\n  function cmKeyToVimKey(key) {\n    if (key.charAt(0) == \"'\") {\n      // Keypress character binding of format \"'a'\"\n      return key.charAt(1);\n    }\n\n    if (key === \"AltGraph\") {\n      return false;\n    }\n\n    var pieces = key.split(/-(?!$)/);\n    var lastPiece = pieces[pieces.length - 1];\n\n    if (pieces.length == 1 && pieces[0].length == 1) {\n      // No-modifier bindings use literal character bindings above. Skip.\n      return false;\n    } else if (pieces.length == 2 && pieces[0] == \"Shift\" && lastPiece.length == 1) {\n      // Ignore Shift+char bindings as they should be handled by literal character.\n      return false;\n    }\n\n    var hasCharacter = false;\n\n    for (var i = 0; i < pieces.length; i++) {\n      var piece = pieces[i];\n\n      if (piece in modifiers) {\n        pieces[i] = modifiers[piece];\n      } else {\n        hasCharacter = true;\n      }\n\n      if (piece in specialKeys) {\n        pieces[i] = specialKeys[piece];\n      }\n    }\n\n    if (!hasCharacter) {\n      // Vim does not support modifier only keys.\n      return false;\n    } // TODO: Current bindings expect the character to be lower case, but\n    // it looks like vim key notation uses upper case.\n\n\n    if (isUpperCase(lastPiece)) {\n      pieces[pieces.length - 1] = lastPiece.toLowerCase();\n    }\n\n    return \"<\" + pieces.join(\"-\") + \">\";\n  } // function getOnPasteFn(cm) {\n  //   var vim = cm.state.vim;\n  //   if (!vim.onPasteFn) {\n  //     vim.onPasteFn = function () {\n  //       if (!vim.insertMode) {\n  //         cm.setCursor(offsetCursor(cm.getCursor(), 0, 1));\n  //         actions.enterInsertMode(cm, {}, vim);\n  //       }\n  //     };\n  //   }\n  //   return vim.onPasteFn;\n  // }\n\n\n  var numberRegex = /[\\d]/;\n  var wordCharTest = [_cm_adapter[\"default\"].isWordChar, function (ch) {\n    return ch && !_cm_adapter[\"default\"].isWordChar(ch) && !/\\s/.test(ch);\n  }],\n      bigWordCharTest = [function (ch) {\n    return /\\S/.test(ch);\n  }];\n\n  function makeKeyRange(start, size) {\n    var keys = [];\n\n    for (var i = start; i < start + size; i++) {\n      keys.push(String.fromCharCode(i));\n    }\n\n    return keys;\n  }\n\n  var upperCaseAlphabet = makeKeyRange(65, 26);\n  var lowerCaseAlphabet = makeKeyRange(97, 26);\n  var numbers = makeKeyRange(48, 10);\n  var validMarks = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, [\"<\", \">\"]);\n  var validRegisters = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, [\"-\", '\"', \".\", \":\", \"_\", \"/\"]);\n  var upperCaseChars;\n\n  try {\n    upperCaseChars = new RegExp(\"^[\\\\p{Lu}]$\", \"u\");\n  } catch (_) {\n    upperCaseChars = /^[A-Z]$/;\n  }\n\n  function isLine(cm, line) {\n    return line >= cm.firstLine() && line <= cm.lastLine();\n  }\n\n  function isLowerCase(k) {\n    return /^[a-z]$/.test(k);\n  }\n\n  function isMatchableSymbol(k) {\n    return \"()[]{}\".indexOf(k) != -1;\n  }\n\n  function isNumber(k) {\n    return numberRegex.test(k);\n  }\n\n  function isUpperCase(k) {\n    return upperCaseChars.test(k);\n  }\n\n  function isWhiteSpaceString(k) {\n    return /^\\s*$/.test(k);\n  }\n\n  function isEndOfSentenceSymbol(k) {\n    return \".?!\".indexOf(k) != -1;\n  }\n\n  function inArray(val, arr) {\n    for (var i = 0; i < arr.length; i++) {\n      if (arr[i] == val) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  var options = {};\n\n  function defineOption(name, defaultValue, type, aliases, callback) {\n    if (defaultValue === undefined && !callback) {\n      throw Error(\"defaultValue is required unless callback is provided\");\n    }\n\n    if (!type) {\n      type = \"string\";\n    }\n\n    options[name] = {\n      type: type,\n      defaultValue: defaultValue,\n      callback: callback\n    };\n\n    if (aliases) {\n      for (var i = 0; i < aliases.length; i++) {\n        options[aliases[i]] = options[name];\n      }\n    }\n\n    if (defaultValue) {\n      setOption(name, defaultValue);\n    }\n  }\n\n  function setOption(name, value, cm, cfg) {\n    var option = options[name];\n    cfg = cfg || {};\n    var scope = cfg.scope;\n\n    if (!option) {\n      return new Error(\"Unknown option: \" + name);\n    }\n\n    if (option.type == \"boolean\") {\n      if (value && value !== true) {\n        return new Error(\"Invalid argument: \" + name + \"=\" + value);\n      } else if (value !== false) {\n        // Boolean options are set to true if value is not defined.\n        value = true;\n      }\n    }\n\n    if (option.callback) {\n      if (scope !== \"local\") {\n        option.callback(value, undefined);\n      }\n\n      if (scope !== \"global\" && cm) {\n        option.callback(value, cm);\n      }\n    } else {\n      if (scope !== \"local\") {\n        option.value = option.type == \"boolean\" ? !!value : value;\n      }\n\n      if (scope !== \"global\" && cm) {\n        cm.state.vim.options[name] = {\n          value: value\n        };\n      }\n    }\n  }\n\n  function getOption(name, cm, cfg) {\n    var option = options[name];\n    cfg = cfg || {};\n    var scope = cfg.scope;\n\n    if (!option) {\n      return new Error(\"Unknown option: \" + name);\n    }\n\n    if (option.callback) {\n      var local = cm && option.callback(undefined, cm);\n\n      if (scope !== \"global\" && local !== undefined) {\n        return local;\n      }\n\n      if (scope !== \"local\") {\n        return option.callback();\n      }\n\n      return;\n    } else {\n      var local = scope !== \"global\" && cm && cm.state.vim.options[name];\n      return (local || scope !== \"local\" && option || {}).value;\n    }\n  }\n\n  defineOption(\"filetype\", undefined, \"string\", [\"ft\"], function (name, cm) {\n    // Option is local. Do nothing for global.\n    if (cm === undefined) {\n      return;\n    } // The 'filetype' option proxies to the CodeMirror 'mode' option.\n\n\n    if (name === undefined) {\n      var mode = cm.getOption(\"mode\");\n      return mode == \"null\" ? \"\" : mode;\n    } else {\n      var mode = name == \"\" ? \"null\" : name;\n      cm.setOption(\"mode\", mode);\n    }\n  });\n\n  var createCircularJumpList = function createCircularJumpList() {\n    var size = 100;\n    var pointer = -1;\n    var head = 0;\n    var tail = 0;\n    var buffer = new Array(size);\n\n    function add(cm, oldCur, newCur) {\n      var current = pointer % size;\n      var curMark = buffer[current];\n\n      function useNextSlot(cursor) {\n        var next = ++pointer % size;\n        var trashMark = buffer[next];\n\n        if (trashMark) {\n          trashMark.clear();\n        }\n\n        buffer[next] = cm.setBookmark(cursor);\n      }\n\n      if (curMark) {\n        var markPos = curMark.find(); // avoid recording redundant cursor position\n\n        if (markPos && !cursorEqual(markPos, oldCur)) {\n          useNextSlot(oldCur);\n        }\n      } else {\n        useNextSlot(oldCur);\n      }\n\n      useNextSlot(newCur);\n      head = pointer;\n      tail = pointer - size + 1;\n\n      if (tail < 0) {\n        tail = 0;\n      }\n    }\n\n    function move(cm, offset) {\n      pointer += offset;\n\n      if (pointer > head) {\n        pointer = head;\n      } else if (pointer < tail) {\n        pointer = tail;\n      }\n\n      var mark = buffer[(size + pointer) % size]; // skip marks that are temporarily removed from text buffer\n\n      if (mark && !mark.find()) {\n        var inc = offset > 0 ? 1 : -1;\n        var newCur;\n        var oldCur = cm.getCursor();\n\n        do {\n          pointer += inc;\n          mark = buffer[(size + pointer) % size]; // skip marks that are the same as current position\n\n          if (mark && (newCur = mark.find()) && !cursorEqual(oldCur, newCur)) {\n            break;\n          }\n        } while (pointer < head && pointer > tail);\n      }\n\n      return mark;\n    }\n\n    function find(cm, offset) {\n      var oldPointer = pointer;\n      var mark = move(cm, offset);\n      pointer = oldPointer;\n      return mark && mark.find();\n    }\n\n    return {\n      cachedCursor: undefined,\n      //used for # and * jumps\n      add: add,\n      find: find,\n      move: move\n    };\n  }; // Returns an object to track the changes associated insert mode.  It\n  // clones the object that is passed in, or creates an empty object one if\n  // none is provided.\n\n\n  var createInsertModeChanges = function createInsertModeChanges(c) {\n    if (c) {\n      // Copy construction\n      return {\n        changes: c.changes,\n        expectCursorActivityForChange: c.expectCursorActivityForChange\n      };\n    }\n\n    return {\n      // Change list\n      changes: [],\n      // Set to true on change, false on cursorActivity.\n      expectCursorActivityForChange: false\n    };\n  };\n\n  function MacroModeState() {\n    this.latestRegister = undefined;\n    this.isPlaying = false;\n    this.isRecording = false;\n    this.replaySearchQueries = [];\n    this.onRecordingDone = undefined;\n    this.lastInsertModeChanges = createInsertModeChanges();\n  }\n\n  MacroModeState.prototype = {\n    exitMacroRecordMode: function exitMacroRecordMode() {\n      var macroModeState = vimGlobalState.macroModeState;\n\n      if (macroModeState.onRecordingDone) {\n        macroModeState.onRecordingDone(); // close dialog\n      }\n\n      macroModeState.onRecordingDone = undefined;\n      macroModeState.isRecording = false;\n    },\n    enterMacroRecordMode: function enterMacroRecordMode(cm, registerName) {\n      var register = vimGlobalState.registerController.getRegister(registerName);\n\n      if (register) {\n        register.clear();\n        this.latestRegister = registerName;\n\n        if (cm.openDialog) {\n          this.onRecordingDone = cm.openDialog(document.createTextNode(\"(recording)[\" + registerName + \"]\"), null, {\n            bottom: true\n          });\n        }\n\n        this.isRecording = true;\n      }\n    }\n  };\n\n  function maybeInitVimState(cm) {\n    if (!cm.state.vim) {\n      // Store instance state in the CodeMirror object.\n      cm.state.vim = {\n        inputState: new InputState(),\n        // Vim's input state that triggered the last edit, used to repeat\n        // motions and operators with '.'.\n        lastEditInputState: undefined,\n        // Vim's action command before the last edit, used to repeat actions\n        // with '.' and insert mode repeat.\n        lastEditActionCommand: undefined,\n        // When using jk for navigation, if you move from a longer line to a\n        // shorter line, the cursor may clip to the end of the shorter line.\n        // If j is pressed again and cursor goes to the next line, the\n        // cursor should go back to its horizontal position on the longer\n        // line if it can. This is to keep track of the horizontal position.\n        lastHPos: -1,\n        // Doing the same with screen-position for gj/gk\n        lastHSPos: -1,\n        // The last motion command run. Cleared if a non-motion command gets\n        // executed in between.\n        lastMotion: null,\n        marks: {},\n        insertMode: false,\n        // Repeat count for changes made in insert mode, triggered by key\n        // sequences like 3,i. Only exists when insertMode is true.\n        insertModeRepeat: undefined,\n        visualMode: false,\n        // If we are in visual line mode. No effect if visualMode is false.\n        visualLine: false,\n        visualBlock: false,\n        lastSelection: null,\n        lastPastedText: null,\n        sel: {},\n        // Buffer-local/window-local values of vim options.\n        options: {}\n      };\n    }\n\n    return cm.state.vim;\n  }\n\n  var vimGlobalState;\n\n  function resetVimGlobalState() {\n    vimGlobalState = {\n      // The current search query.\n      searchQuery: null,\n      // Whether we are searching backwards.\n      searchIsReversed: false,\n      // Replace part of the last substituted pattern\n      lastSubstituteReplacePart: undefined,\n      jumpList: createCircularJumpList(),\n      macroModeState: new MacroModeState(),\n      // Recording latest f, t, F or T motion command.\n      lastCharacterSearch: {\n        increment: 0,\n        forward: true,\n        selectedCharacter: \"\"\n      },\n      registerController: new RegisterController({}),\n      // search history buffer\n      searchHistoryController: new HistoryController(),\n      // ex Command history buffer\n      exCommandHistoryController: new HistoryController()\n    };\n\n    for (var optionName in options) {\n      var option = options[optionName];\n      option.value = option.defaultValue;\n    }\n  }\n\n  var lastInsertModeKeyTimer;\n  var vimApi = {\n    buildKeyMap: function buildKeyMap() {// TODO: Convert keymap into dictionary format for fast lookup.\n    },\n    // Testing hook, though it might be useful to expose the register\n    // controller anyway.\n    getRegisterController: function getRegisterController() {\n      return vimGlobalState.registerController;\n    },\n    // Testing hook.\n    resetVimGlobalState_: resetVimGlobalState,\n    // Testing hook.\n    getVimGlobalState_: function getVimGlobalState_() {\n      return vimGlobalState;\n    },\n    // Testing hook.\n    maybeInitVimState_: maybeInitVimState,\n    suppressErrorLogging: false,\n    InsertModeKey: InsertModeKey,\n    map: function map(lhs, rhs, ctx) {\n      // Add user defined key bindings.\n      exCommandDispatcher.map(lhs, rhs, ctx);\n    },\n    unmap: function unmap(lhs, ctx) {\n      return exCommandDispatcher.unmap(lhs, ctx);\n    },\n    // Non-recursive map function.\n    // NOTE: This will not create mappings to key maps that aren't present\n    // in the default key map. See TODO at bottom of function.\n    noremap: function noremap(lhs, rhs, ctx) {\n      function toCtxArray(ctx) {\n        return ctx ? [ctx] : [\"normal\", \"insert\", \"visual\"];\n      }\n\n      var ctxsToMap = toCtxArray(ctx); // Look through all actual defaults to find a map candidate.\n\n      var actualLength = defaultKeymap.length,\n          origLength = defaultKeymapLength;\n\n      for (var i = actualLength - origLength; i < actualLength && ctxsToMap.length; i++) {\n        var mapping = defaultKeymap[i]; // Omit mappings that operate in the wrong context(s) and those of invalid type.\n\n        if (mapping.keys == rhs && (!ctx || !mapping.context || mapping.context === ctx) && mapping.type.substr(0, 2) !== \"ex\" && mapping.type.substr(0, 3) !== \"key\") {\n          // Make a shallow copy of the original keymap entry.\n          var newMapping = {};\n\n          for (var key in mapping) {\n            newMapping[key] = mapping[key];\n          } // Modify it point to the new mapping with the proper context.\n\n\n          newMapping.keys = lhs;\n\n          if (ctx && !newMapping.context) {\n            newMapping.context = ctx;\n          } // Add it to the keymap with a higher priority than the original.\n\n\n          this._mapCommand(newMapping); // Record the mapped contexts as complete.\n\n\n          var mappedCtxs = toCtxArray(mapping.context);\n          ctxsToMap = ctxsToMap.filter(function (el) {\n            return mappedCtxs.indexOf(el) === -1;\n          });\n        }\n      } // TODO: Create non-recursive keyToKey mappings for the unmapped contexts once those exist.\n\n    },\n    // Remove all user-defined mappings for the provided context.\n    mapclear: function mapclear(ctx) {\n      // Partition the existing keymap into user-defined and true defaults.\n      var actualLength = defaultKeymap.length,\n          origLength = defaultKeymapLength;\n      var userKeymap = defaultKeymap.slice(0, actualLength - origLength);\n      defaultKeymap = defaultKeymap.slice(actualLength - origLength);\n\n      if (ctx) {\n        // If a specific context is being cleared, we need to keep mappings\n        // from all other contexts.\n        for (var i = userKeymap.length - 1; i >= 0; i--) {\n          var mapping = userKeymap[i];\n\n          if (ctx !== mapping.context) {\n            if (mapping.context) {\n              this._mapCommand(mapping);\n            } else {\n              // `mapping` applies to all contexts so create keymap copies\n              // for each context except the one being cleared.\n              var contexts = [\"normal\", \"insert\", \"visual\"];\n\n              for (var j in contexts) {\n                if (contexts[j] !== ctx) {\n                  var newMapping = {};\n\n                  for (var key in mapping) {\n                    newMapping[key] = mapping[key];\n                  }\n\n                  newMapping.context = contexts[j];\n\n                  this._mapCommand(newMapping);\n                }\n              }\n            }\n          }\n        }\n      }\n    },\n    // TODO: Expose setOption and getOption as instance methods. Need to decide how to namespace\n    // them, or somehow make them work with the existing CodeMirror setOption/getOption API.\n    setOption: setOption,\n    getOption: getOption,\n    defineOption: defineOption,\n    defineEx: function defineEx(name, prefix, func) {\n      if (!prefix) {\n        prefix = name;\n      } else if (name.indexOf(prefix) !== 0) {\n        throw new Error('(Vim.defineEx) \"' + prefix + '\" is not a prefix of \"' + name + '\", command not registered');\n      }\n\n      exCommands[name] = func;\n      exCommandDispatcher.commandMap_[prefix] = {\n        name: name,\n        shortName: prefix,\n        type: \"api\"\n      };\n    },\n    handleKey: function handleKey(cm, key, origin) {\n      var command = this.findKey(cm, key, origin);\n\n      if (typeof command === \"function\") {\n        return command();\n      }\n    },\n\n    /**\n     * This is the outermost function called by CodeMirror, after keys have\n     * been mapped to their Vim equivalents.\n     *\n     * Finds a command based on the key (and cached keys if there is a\n     * multi-key sequence). Returns `undefined` if no key is matched, a noop\n     * function if a partial match is found (multi-key), and a function to\n     * execute the bound command if a a key is matched. The function always\n     * returns true.\n     */\n    findKey: function findKey(cm, key, origin) {\n      var vim = maybeInitVimState(cm);\n\n      function handleMacroRecording() {\n        var macroModeState = vimGlobalState.macroModeState;\n\n        if (macroModeState.isRecording) {\n          if (key == \"q\") {\n            macroModeState.exitMacroRecordMode();\n            clearInputState(cm);\n            return true;\n          }\n\n          if (origin != \"mapping\") {\n            logKey(macroModeState, key);\n          }\n        }\n      }\n\n      function handleEsc() {\n        if (key == \"<Esc>\") {\n          if (vim.visualMode) {\n            // Get back to normal mode.\n            exitVisualMode(cm);\n          } else if (vim.insertMode) {\n            // Get back to normal mode.\n            exitInsertMode(cm);\n          } else {\n            // We're already in normal mode. Let '<Esc>' be handled normally.\n            return;\n          }\n\n          clearInputState(cm);\n          return true;\n        }\n      }\n\n      function doKeyToKey(keys) {\n        // TODO: prevent infinite recursion.\n        var match;\n\n        while (keys) {\n          // Pull off one command key, which is either a single character\n          // or a special sequence wrapped in '<' and '>', e.g. '<Space>'.\n          match = /<\\w+-.+?>|<\\w+>|./.exec(keys);\n          key = match[0];\n          keys = keys.substring(match.index + key.length);\n          vimApi.handleKey(cm, key, \"mapping\");\n        }\n      }\n\n      function handleKeyInsertMode() {\n        if (handleEsc()) {\n          return true;\n        }\n\n        var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key;\n        var keysAreChars = key.length == 1;\n        var match = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, \"insert\"); // Need to check all key substrings in insert mode.\n\n        while (keys.length > 1 && match.type != \"full\") {\n          var keys = vim.inputState.keyBuffer = keys.slice(1);\n          var thisMatch = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, \"insert\");\n\n          if (thisMatch.type != \"none\") {\n            match = thisMatch;\n          }\n        }\n\n        if (match.type == \"none\") {\n          clearInputState(cm);\n          return false;\n        } else if (match.type == \"partial\") {\n          if (lastInsertModeKeyTimer) {\n            window.clearTimeout(lastInsertModeKeyTimer);\n          }\n\n          lastInsertModeKeyTimer = window.setTimeout(function () {\n            if (vim.insertMode && vim.inputState.keyBuffer) {\n              clearInputState(cm);\n            }\n          }, getOption(\"insertModeEscKeysTimeout\"));\n          return !keysAreChars;\n        }\n\n        if (lastInsertModeKeyTimer) {\n          window.clearTimeout(lastInsertModeKeyTimer);\n        }\n\n        if (keysAreChars) {\n          var selections = cm.listSelections();\n\n          for (var i = 0; i < selections.length; i++) {\n            var here = selections[i].head;\n            cm.replaceRange(\"\", offsetCursor(here, 0, -(keys.length - 1)), here, \"+input\");\n          }\n\n          vimGlobalState.macroModeState.lastInsertModeChanges.changes.pop();\n        }\n\n        clearInputState(cm);\n        return match.command;\n      }\n\n      function handleKeyNonInsertMode() {\n        if (handleMacroRecording() || handleEsc()) {\n          return true;\n        }\n\n        var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key;\n\n        if (/^[1-9]\\d*$/.test(keys)) {\n          return true;\n        }\n\n        var keysMatcher = /^(\\d*)(.*)$/.exec(keys);\n\n        if (!keysMatcher) {\n          clearInputState(cm);\n          return false;\n        }\n\n        var context = vim.visualMode ? \"visual\" : \"normal\";\n        var mainKey = keysMatcher[2] || keysMatcher[1];\n\n        if (vim.inputState.operatorShortcut && vim.inputState.operatorShortcut.slice(-1) == mainKey) {\n          // multikey operators act linewise by repeating only the last character\n          mainKey = vim.inputState.operatorShortcut;\n        }\n\n        var match = commandDispatcher.matchCommand(mainKey, defaultKeymap, vim.inputState, context);\n\n        if (match.type == \"none\") {\n          clearInputState(cm);\n          return false;\n        } else if (match.type == \"partial\") {\n          return true;\n        }\n\n        vim.inputState.keyBuffer = \"\";\n        var keysMatcher = /^(\\d*)(.*)$/.exec(keys);\n\n        if (keysMatcher[1] && keysMatcher[1] != \"0\") {\n          vim.inputState.pushRepeatDigit(keysMatcher[1]);\n        }\n\n        return match.command;\n      }\n\n      var command;\n\n      if (vim.insertMode) {\n        command = handleKeyInsertMode();\n      } else {\n        command = handleKeyNonInsertMode();\n      }\n\n      if (command === false) {\n        return !vim.insertMode && key.length === 1 ? function () {\n          return true;\n        } : undefined;\n      } else if (command === true) {\n        // TODO: Look into using CodeMirror's multi-key handling.\n        // Return no-op since we are caching the key. Counts as handled, but\n        // don't want act on it just yet.\n        return function () {\n          return true;\n        };\n      } else {\n        return function () {\n          return cm.operation(function () {\n            cm.curOp.isVimOp = true;\n\n            try {\n              if (command.type == \"keyToKey\") {\n                doKeyToKey(command.toKeys);\n              } else {\n                commandDispatcher.processCommand(cm, vim, command);\n              }\n            } catch (e) {\n              // clear VIM state in case it's in a bad state.\n              cm.state.vim = undefined;\n              maybeInitVimState(cm);\n\n              if (!vimApi.suppressErrorLogging) {\n                console[\"log\"](e);\n              }\n\n              throw e;\n            }\n\n            return true;\n          });\n        };\n      }\n    },\n    handleEx: function handleEx(cm, input) {\n      exCommandDispatcher.processCommand(cm, input);\n    },\n    defineMotion: defineMotion,\n    defineAction: defineAction,\n    defineOperator: defineOperator,\n    mapCommand: mapCommand,\n    _mapCommand: _mapCommand,\n    defineRegister: defineRegister,\n    exitVisualMode: exitVisualMode,\n    exitInsertMode: exitInsertMode\n  }; // Represents the current input state.\n\n  function InputState() {\n    this.prefixRepeat = [];\n    this.motionRepeat = [];\n    this.operator = null;\n    this.operatorArgs = null;\n    this.motion = null;\n    this.motionArgs = null;\n    this.keyBuffer = []; // For matching multi-key commands.\n\n    this.registerName = null; // Defaults to the unnamed register.\n  }\n\n  InputState.prototype.pushRepeatDigit = function (n) {\n    if (!this.operator) {\n      this.prefixRepeat = this.prefixRepeat.concat(n);\n    } else {\n      this.motionRepeat = this.motionRepeat.concat(n);\n    }\n  };\n\n  InputState.prototype.getRepeat = function () {\n    var repeat = 0;\n\n    if (this.prefixRepeat.length > 0 || this.motionRepeat.length > 0) {\n      repeat = 1;\n\n      if (this.prefixRepeat.length > 0) {\n        repeat *= parseInt(this.prefixRepeat.join(\"\"), 10);\n      }\n\n      if (this.motionRepeat.length > 0) {\n        repeat *= parseInt(this.motionRepeat.join(\"\"), 10);\n      }\n    }\n\n    return repeat;\n  };\n\n  function clearInputState(cm, reason) {\n    cm.state.vim.inputState = new InputState();\n\n    _cm_adapter[\"default\"].signal(cm, \"vim-command-done\", reason);\n  }\n  /*\n   * Register stores information about copy and paste registers.  Besides\n   * text, a register must store whether it is linewise (i.e., when it is\n   * pasted, should it insert itself into a new line, or should the text be\n   * inserted at the cursor position.)\n   */\n\n\n  function Register(text, linewise, blockwise) {\n    this.clear();\n    this.keyBuffer = [text || \"\"];\n    this.insertModeChanges = [];\n    this.searchQueries = [];\n    this.linewise = !!linewise;\n    this.blockwise = !!blockwise;\n  }\n\n  Register.prototype = {\n    setText: function setText(text, linewise, blockwise) {\n      this.keyBuffer = [text || \"\"];\n      this.linewise = !!linewise;\n      this.blockwise = !!blockwise;\n    },\n    pushText: function pushText(text, linewise) {\n      // if this register has ever been set to linewise, use linewise.\n      if (linewise) {\n        if (!this.linewise) {\n          this.keyBuffer.push(\"\\n\");\n        }\n\n        this.linewise = true;\n      }\n\n      this.keyBuffer.push(text);\n    },\n    pushInsertModeChanges: function pushInsertModeChanges(changes) {\n      this.insertModeChanges.push(createInsertModeChanges(changes));\n    },\n    pushSearchQuery: function pushSearchQuery(query) {\n      this.searchQueries.push(query);\n    },\n    clear: function clear() {\n      this.keyBuffer = [];\n      this.insertModeChanges = [];\n      this.searchQueries = [];\n      this.linewise = false;\n    },\n    toString: function toString() {\n      return this.keyBuffer.join(\"\");\n    }\n  };\n  /**\n   * Defines an external register.\n   *\n   * The name should be a single character that will be used to reference the register.\n   * The register should support setText, pushText, clear, and toString(). See Register\n   * for a reference implementation.\n   */\n\n  function defineRegister(name, register) {\n    var registers = vimGlobalState.registerController.registers;\n\n    if (!name || name.length != 1) {\n      throw Error(\"Register name must be 1 character\");\n    }\n\n    if (registers[name]) {\n      throw Error(\"Register already defined \" + name);\n    }\n\n    registers[name] = register;\n    validRegisters.push(name);\n  }\n  /*\n   * vim registers allow you to keep many independent copy and paste buffers.\n   * See http://usevim.com/2012/04/13/registers/ for an introduction.\n   *\n   * RegisterController keeps the state of all the registers.  An initial\n   * state may be passed in.  The unnamed register '\"' will always be\n   * overridden.\n   */\n\n\n  function RegisterController(registers) {\n    this.registers = registers;\n    this.unnamedRegister = registers['\"'] = new Register();\n    registers[\".\"] = new Register();\n    registers[\":\"] = new Register();\n    registers[\"/\"] = new Register();\n  }\n\n  RegisterController.prototype = {\n    pushText: function pushText(registerName, operator, text, linewise, blockwise) {\n      // The black hole register, \"_, means delete/yank to nowhere.\n      if (registerName === \"_\") return;\n\n      if (linewise && text.charAt(text.length - 1) !== \"\\n\") {\n        text += \"\\n\";\n      } // Lowercase and uppercase registers refer to the same register.\n      // Uppercase just means append.\n\n\n      var register = this.isValidRegister(registerName) ? this.getRegister(registerName) : null; // if no register/an invalid register was specified, things go to the\n      // default registers\n\n      if (!register) {\n        switch (operator) {\n          case \"yank\":\n            // The 0 register contains the text from the most recent yank.\n            this.registers[\"0\"] = new Register(text, linewise, blockwise);\n            break;\n\n          case \"delete\":\n          case \"change\":\n            if (text.indexOf(\"\\n\") == -1) {\n              // Delete less than 1 line. Update the small delete register.\n              this.registers[\"-\"] = new Register(text, linewise);\n            } else {\n              // Shift down the contents of the numbered registers and put the\n              // deleted text into register 1.\n              this.shiftNumericRegisters_();\n              this.registers[\"1\"] = new Register(text, linewise);\n            }\n\n            break;\n        } // Make sure the unnamed register is set to what just happened\n\n\n        this.unnamedRegister.setText(text, linewise, blockwise);\n        return;\n      } // If we've gotten to this point, we've actually specified a register\n\n\n      var append = isUpperCase(registerName);\n\n      if (append) {\n        register.pushText(text, linewise);\n      } else {\n        register.setText(text, linewise, blockwise);\n      } // The unnamed register always has the same value as the last used\n      // register.\n\n\n      this.unnamedRegister.setText(register.toString(), linewise);\n    },\n    // Gets the register named @name.  If one of @name doesn't already exist,\n    // create it.  If @name is invalid, return the unnamedRegister.\n    getRegister: function getRegister(name) {\n      if (!this.isValidRegister(name)) {\n        return this.unnamedRegister;\n      }\n\n      name = name.toLowerCase();\n\n      if (!this.registers[name]) {\n        this.registers[name] = new Register();\n      }\n\n      return this.registers[name];\n    },\n    isValidRegister: function isValidRegister(name) {\n      return name && inArray(name, validRegisters);\n    },\n    shiftNumericRegisters_: function shiftNumericRegisters_() {\n      for (var i = 9; i >= 2; i--) {\n        this.registers[i] = this.getRegister(\"\" + (i - 1));\n      }\n    }\n  };\n\n  function HistoryController() {\n    this.historyBuffer = [];\n    this.iterator = 0;\n    this.initialPrefix = null;\n  }\n\n  HistoryController.prototype = {\n    // the input argument here acts a user entered prefix for a small time\n    // until we start autocompletion in which case it is the autocompleted.\n    nextMatch: function nextMatch(input, up) {\n      var historyBuffer = this.historyBuffer;\n      var dir = up ? -1 : 1;\n      if (this.initialPrefix === null) this.initialPrefix = input;\n\n      for (var i = this.iterator + dir; up ? i >= 0 : i < historyBuffer.length; i += dir) {\n        var element = historyBuffer[i];\n\n        for (var j = 0; j <= element.length; j++) {\n          if (this.initialPrefix == element.substring(0, j)) {\n            this.iterator = i;\n            return element;\n          }\n        }\n      } // should return the user input in case we reach the end of buffer.\n\n\n      if (i >= historyBuffer.length) {\n        this.iterator = historyBuffer.length;\n        return this.initialPrefix;\n      } // return the last autocompleted query or exCommand as it is.\n\n\n      if (i < 0) return input;\n    },\n    pushInput: function pushInput(input) {\n      var index = this.historyBuffer.indexOf(input);\n      if (index > -1) this.historyBuffer.splice(index, 1);\n      if (input.length) this.historyBuffer.push(input);\n    },\n    reset: function reset() {\n      this.initialPrefix = null;\n      this.iterator = this.historyBuffer.length;\n    }\n  };\n  var commandDispatcher = {\n    matchCommand: function matchCommand(keys, keyMap, inputState, context) {\n      var matches = commandMatches(keys, keyMap, context, inputState);\n\n      if (!matches.full && !matches.partial) {\n        return {\n          type: \"none\"\n        };\n      } else if (!matches.full && matches.partial) {\n        return {\n          type: \"partial\"\n        };\n      }\n\n      var bestMatch;\n\n      for (var i = 0; i < matches.full.length; i++) {\n        var match = matches.full[i];\n\n        if (!bestMatch) {\n          bestMatch = match;\n        }\n      }\n\n      if (bestMatch.keys.slice(-11) == \"<character>\") {\n        var character = lastChar(keys);\n        if (!character) return {\n          type: \"none\"\n        };\n        inputState.selectedCharacter = character;\n      }\n\n      return {\n        type: \"full\",\n        command: bestMatch\n      };\n    },\n    processCommand: function processCommand(cm, vim, command) {\n      vim.inputState.repeatOverride = command.repeatOverride;\n\n      switch (command.type) {\n        case \"motion\":\n          this.processMotion(cm, vim, command);\n          break;\n\n        case \"operator\":\n          this.processOperator(cm, vim, command);\n          break;\n\n        case \"operatorMotion\":\n          this.processOperatorMotion(cm, vim, command);\n          break;\n\n        case \"action\":\n          this.processAction(cm, vim, command);\n          break;\n\n        case \"search\":\n          this.processSearch(cm, vim, command);\n          break;\n\n        case \"ex\":\n        case \"keyToEx\":\n          this.processEx(cm, vim, command);\n          break;\n\n        default:\n          break;\n      }\n    },\n    processMotion: function processMotion(cm, vim, command) {\n      vim.inputState.motion = command.motion;\n      vim.inputState.motionArgs = copyArgs(command.motionArgs);\n      this.evalInput(cm, vim);\n    },\n    processOperator: function processOperator(cm, vim, command) {\n      var inputState = vim.inputState;\n\n      if (inputState.operator) {\n        if (inputState.operator == command.operator) {\n          // Typing an operator twice like 'dd' makes the operator operate\n          // linewise\n          inputState.motion = \"expandToLine\";\n          inputState.motionArgs = {\n            linewise: true\n          };\n          this.evalInput(cm, vim);\n          return;\n        } else {\n          // 2 different operators in a row doesn't make sense.\n          clearInputState(cm);\n        }\n      }\n\n      inputState.operator = command.operator;\n      inputState.operatorArgs = copyArgs(command.operatorArgs);\n\n      if (command.keys.length > 1) {\n        inputState.operatorShortcut = command.keys;\n      }\n\n      if (command.exitVisualBlock) {\n        vim.visualBlock = false;\n        updateCmSelection(cm);\n      }\n\n      if (vim.visualMode) {\n        // Operating on a selection in visual mode. We don't need a motion.\n        this.evalInput(cm, vim);\n      }\n    },\n    processOperatorMotion: function processOperatorMotion(cm, vim, command) {\n      var visualMode = vim.visualMode;\n      var operatorMotionArgs = copyArgs(command.operatorMotionArgs);\n\n      if (operatorMotionArgs) {\n        // Operator motions may have special behavior in visual mode.\n        if (visualMode && operatorMotionArgs.visualLine) {\n          vim.visualLine = true;\n        }\n      }\n\n      this.processOperator(cm, vim, command);\n\n      if (!visualMode) {\n        this.processMotion(cm, vim, command);\n      }\n    },\n    processAction: function processAction(cm, vim, command) {\n      var inputState = vim.inputState;\n      var repeat = inputState.getRepeat();\n      var repeatIsExplicit = !!repeat;\n      var actionArgs = copyArgs(command.actionArgs) || {};\n\n      if (inputState.selectedCharacter) {\n        actionArgs.selectedCharacter = inputState.selectedCharacter;\n      } // Actions may or may not have motions and operators. Do these first.\n\n\n      if (command.operator) {\n        this.processOperator(cm, vim, command);\n      }\n\n      if (command.motion) {\n        this.processMotion(cm, vim, command);\n      }\n\n      if (command.motion || command.operator) {\n        this.evalInput(cm, vim);\n      }\n\n      actionArgs.repeat = repeat || 1;\n      actionArgs.repeatIsExplicit = repeatIsExplicit;\n      actionArgs.registerName = inputState.registerName;\n      clearInputState(cm);\n      vim.lastMotion = null;\n\n      if (command.isEdit) {\n        this.recordLastEdit(vim, inputState, command);\n      }\n\n      actions[command.action](cm, actionArgs, vim);\n    },\n    processSearch: function processSearch(cm, vim, command) {\n      if (!cm.getSearchCursor) {\n        // Search depends on SearchCursor.\n        return;\n      }\n\n      var forward = command.searchArgs.forward;\n      var wholeWordOnly = command.searchArgs.wholeWordOnly;\n      getSearchState(cm).setReversed(!forward);\n      var promptPrefix = forward ? \"/\" : \"?\";\n      var originalQuery = getSearchState(cm).getQuery();\n      var originalScrollPos = cm.getScrollInfo();\n\n      function handleQuery(query, ignoreCase, smartCase) {\n        vimGlobalState.searchHistoryController.pushInput(query);\n        vimGlobalState.searchHistoryController.reset();\n\n        try {\n          updateSearchQuery(cm, query, ignoreCase, smartCase);\n        } catch (e) {\n          showConfirm(cm, \"Invalid regex: \" + query);\n          clearInputState(cm);\n          return;\n        }\n\n        commandDispatcher.processMotion(cm, vim, {\n          type: \"motion\",\n          motion: \"findNext\",\n          motionArgs: {\n            forward: true,\n            toJumplist: command.searchArgs.toJumplist\n          }\n        });\n      }\n\n      function onPromptClose(query) {\n        cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n        handleQuery(query, true\n        /** ignoreCase */\n        , true\n        /** smartCase */\n        );\n        var macroModeState = vimGlobalState.macroModeState;\n\n        if (macroModeState.isRecording) {\n          logSearchQuery(macroModeState, query);\n        }\n      }\n\n      function onPromptKeyUp(e, query, close) {\n        var keyName = _cm_adapter[\"default\"].keyName(e),\n            up,\n            offset;\n\n        if (keyName == \"Up\" || keyName == \"Down\") {\n          up = keyName == \"Up\" ? true : false;\n          offset = e.target ? e.target.selectionEnd : 0;\n          query = vimGlobalState.searchHistoryController.nextMatch(query, up) || \"\";\n          close(query);\n          if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);\n        } else {\n          if (keyName != \"Left\" && keyName != \"Right\" && keyName != \"Ctrl\" && keyName != \"Alt\" && keyName != \"Shift\") vimGlobalState.searchHistoryController.reset();\n        }\n\n        var parsedQuery;\n\n        try {\n          parsedQuery = updateSearchQuery(cm, query, true\n          /** ignoreCase */\n          , true\n          /** smartCase */\n          );\n        } catch (e) {// Swallow bad regexes for incremental search.\n        }\n\n        if (parsedQuery) {\n          cm.scrollIntoView(_findNext(cm, !forward, parsedQuery), 30);\n        } else {\n          clearSearchHighlight(cm);\n          cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n        }\n      }\n\n      function onPromptKeyDown(e, query, close) {\n        var keyName = _cm_adapter[\"default\"].keyName(e);\n\n        if (keyName == \"Esc\" || keyName == \"Ctrl-C\" || keyName == \"Ctrl-[\" || keyName == \"Backspace\" && query == \"\") {\n          vimGlobalState.searchHistoryController.pushInput(query);\n          vimGlobalState.searchHistoryController.reset();\n          updateSearchQuery(cm, originalQuery);\n          clearSearchHighlight(cm);\n          cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n\n          _cm_adapter[\"default\"].e_stop(e);\n\n          clearInputState(cm);\n          close();\n          cm.focus();\n        } else if (keyName == \"Up\" || keyName == \"Down\") {\n          _cm_adapter[\"default\"].e_stop(e);\n        } else if (keyName == \"Ctrl-U\") {\n          // Ctrl-U clears input.\n          _cm_adapter[\"default\"].e_stop(e);\n\n          close(\"\");\n        }\n      }\n\n      switch (command.searchArgs.querySrc) {\n        case \"prompt\":\n          var macroModeState = vimGlobalState.macroModeState;\n\n          if (macroModeState.isPlaying) {\n            var query = macroModeState.replaySearchQueries.shift();\n            handleQuery(query, true\n            /** ignoreCase */\n            , false\n            /** smartCase */\n            );\n          } else {\n            showPrompt(cm, {\n              onClose: onPromptClose,\n              prefix: promptPrefix,\n              desc: \"(JavaScript regexp)\",\n              onKeyUp: onPromptKeyUp,\n              onKeyDown: onPromptKeyDown\n            });\n          }\n\n          break;\n\n        case \"wordUnderCursor\":\n          var word = expandWordUnderCursor(cm, false\n          /** inclusive */\n          , true\n          /** forward */\n          , false\n          /** bigWord */\n          , true\n          /** noSymbol */\n          );\n          var isKeyword = true;\n\n          if (!word) {\n            word = expandWordUnderCursor(cm, false\n            /** inclusive */\n            , true\n            /** forward */\n            , false\n            /** bigWord */\n            , false\n            /** noSymbol */\n            );\n            isKeyword = false;\n          }\n\n          if (!word) {\n            return;\n          }\n\n          var query = cm.getLine(word.start.line).substring(word.start.ch, word.end.ch);\n\n          if (isKeyword && wholeWordOnly) {\n            query = \"\\\\b\" + query + \"\\\\b\";\n          } else {\n            query = escapeRegex(query);\n          } // cachedCursor is used to save the old position of the cursor\n          // when * or # causes vim to seek for the nearest word and shift\n          // the cursor before entering the motion.\n\n\n          vimGlobalState.jumpList.cachedCursor = cm.getCursor();\n          cm.setCursor(word.start);\n          handleQuery(query, true\n          /** ignoreCase */\n          , false\n          /** smartCase */\n          );\n          break;\n      }\n    },\n    processEx: function processEx(cm, vim, command) {\n      function onPromptClose(input) {\n        // Give the prompt some time to close so that if processCommand shows\n        // an error, the elements don't overlap.\n        vimGlobalState.exCommandHistoryController.pushInput(input);\n        vimGlobalState.exCommandHistoryController.reset();\n        exCommandDispatcher.processCommand(cm, input);\n      }\n\n      function onPromptKeyDown(e, input, close) {\n        var keyName = _cm_adapter[\"default\"].keyName(e),\n            up,\n            offset;\n\n        if (keyName == \"Esc\" || keyName == \"Ctrl-C\" || keyName == \"Ctrl-[\" || keyName == \"Backspace\" && input == \"\") {\n          vimGlobalState.exCommandHistoryController.pushInput(input);\n          vimGlobalState.exCommandHistoryController.reset();\n\n          _cm_adapter[\"default\"].e_stop(e);\n\n          clearInputState(cm);\n          close();\n          cm.focus();\n        }\n\n        if (keyName == \"Up\" || keyName == \"Down\") {\n          _cm_adapter[\"default\"].e_stop(e);\n\n          up = keyName == \"Up\" ? true : false;\n          offset = e.target ? e.target.selectionEnd : 0;\n          input = vimGlobalState.exCommandHistoryController.nextMatch(input, up) || \"\";\n          close(input);\n          if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);\n        } else if (keyName == \"Ctrl-U\") {\n          // Ctrl-U clears input.\n          _cm_adapter[\"default\"].e_stop(e);\n\n          close(\"\");\n        } else {\n          if (keyName != \"Left\" && keyName != \"Right\" && keyName != \"Ctrl\" && keyName != \"Alt\" && keyName != \"Shift\") vimGlobalState.exCommandHistoryController.reset();\n        }\n      }\n\n      if (command.type == \"keyToEx\") {\n        // Handle user defined Ex to Ex mappings\n        exCommandDispatcher.processCommand(cm, command.exArgs.input);\n      } else {\n        if (vim.visualMode) {\n          showPrompt(cm, {\n            onClose: onPromptClose,\n            prefix: \":\",\n            value: \"'<,'>\",\n            onKeyDown: onPromptKeyDown,\n            selectValueOnOpen: false\n          });\n        } else {\n          showPrompt(cm, {\n            onClose: onPromptClose,\n            prefix: \":\",\n            onKeyDown: onPromptKeyDown\n          });\n        }\n      }\n    },\n    evalInput: function evalInput(cm, vim) {\n      // If the motion command is set, execute both the operator and motion.\n      // Otherwise return.\n      var inputState = vim.inputState;\n      var motion = inputState.motion;\n      var motionArgs = inputState.motionArgs || {};\n      var operator = inputState.operator;\n      var operatorArgs = inputState.operatorArgs || {};\n      var registerName = inputState.registerName;\n      var sel = vim.sel; // TODO: Make sure cm and vim selections are identical outside visual mode.\n\n      var origHead = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.head) : cm.getCursor(\"head\"));\n      var origAnchor = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.anchor) : cm.getCursor(\"anchor\"));\n      var oldHead = copyCursor(origHead);\n      var oldAnchor = copyCursor(origAnchor);\n      var newHead, newAnchor;\n      var repeat;\n\n      if (operator) {\n        this.recordLastEdit(vim, inputState);\n      }\n\n      if (inputState.repeatOverride !== undefined) {\n        // If repeatOverride is specified, that takes precedence over the\n        // input state's repeat. Used by Ex mode and can be user defined.\n        repeat = inputState.repeatOverride;\n      } else {\n        repeat = inputState.getRepeat();\n      }\n\n      if (repeat > 0 && motionArgs.explicitRepeat) {\n        motionArgs.repeatIsExplicit = true;\n      } else if (motionArgs.noRepeat || !motionArgs.explicitRepeat && repeat === 0) {\n        repeat = 1;\n        motionArgs.repeatIsExplicit = false;\n      }\n\n      if (inputState.selectedCharacter) {\n        // If there is a character input, stick it in all of the arg arrays.\n        motionArgs.selectedCharacter = operatorArgs.selectedCharacter = inputState.selectedCharacter;\n      }\n\n      motionArgs.repeat = repeat;\n      clearInputState(cm);\n\n      if (motion) {\n        var motionResult = motions[motion](cm, origHead, motionArgs, vim, inputState);\n        vim.lastMotion = motions[motion];\n\n        if (!motionResult) {\n          return;\n        }\n\n        if (motionArgs.toJumplist) {\n          var jumpList = vimGlobalState.jumpList; // if the current motion is # or *, use cachedCursor\n\n          var cachedCursor = jumpList.cachedCursor;\n\n          if (cachedCursor) {\n            recordJumpPosition(cm, cachedCursor, motionResult);\n            delete jumpList.cachedCursor;\n          } else {\n            recordJumpPosition(cm, origHead, motionResult);\n          }\n        }\n\n        if (motionResult instanceof Array) {\n          newAnchor = motionResult[0];\n          newHead = motionResult[1];\n        } else {\n          newHead = motionResult;\n        } // TODO: Handle null returns from motion commands better.\n\n\n        if (!newHead) {\n          newHead = copyCursor(origHead);\n        }\n\n        if (vim.visualMode) {\n          if (!(vim.visualBlock && newHead.ch === Infinity)) {\n            newHead = clipCursorToContent(cm, newHead);\n          }\n\n          if (newAnchor) {\n            newAnchor = clipCursorToContent(cm, newAnchor);\n          }\n\n          newAnchor = newAnchor || oldAnchor;\n          sel.anchor = newAnchor;\n          sel.head = newHead;\n          updateCmSelection(cm);\n          updateMark(cm, vim, \"<\", cursorIsBefore(newAnchor, newHead) ? newAnchor : newHead);\n          updateMark(cm, vim, \">\", cursorIsBefore(newAnchor, newHead) ? newHead : newAnchor);\n        } else if (!operator) {\n          newHead = clipCursorToContent(cm, newHead);\n          cm.setCursor(newHead.line, newHead.ch);\n        }\n      }\n\n      if (operator) {\n        if (operatorArgs.lastSel) {\n          // Replaying a visual mode operation\n          newAnchor = oldAnchor;\n          var lastSel = operatorArgs.lastSel;\n          var lineOffset = Math.abs(lastSel.head.line - lastSel.anchor.line);\n          var chOffset = Math.abs(lastSel.head.ch - lastSel.anchor.ch);\n\n          if (lastSel.visualLine) {\n            // Linewise Visual mode: The same number of lines.\n            newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\n          } else if (lastSel.visualBlock) {\n            // Blockwise Visual mode: The same number of lines and columns.\n            newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch + chOffset);\n          } else if (lastSel.head.line == lastSel.anchor.line) {\n            // Normal Visual mode within one line: The same number of characters.\n            newHead = new Pos(oldAnchor.line, oldAnchor.ch + chOffset);\n          } else {\n            // Normal Visual mode with several lines: The same number of lines, in the\n            // last line the same number of characters as in the last line the last time.\n            newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\n          }\n\n          vim.visualMode = true;\n          vim.visualLine = lastSel.visualLine;\n          vim.visualBlock = lastSel.visualBlock;\n          sel = vim.sel = {\n            anchor: newAnchor,\n            head: newHead\n          };\n          updateCmSelection(cm);\n        } else if (vim.visualMode) {\n          operatorArgs.lastSel = {\n            anchor: copyCursor(sel.anchor),\n            head: copyCursor(sel.head),\n            visualBlock: vim.visualBlock,\n            visualLine: vim.visualLine\n          };\n        }\n\n        var curStart, curEnd, linewise, mode;\n        var cmSel;\n\n        if (vim.visualMode) {\n          // Init visual op\n          curStart = cursorMin(sel.head, sel.anchor);\n          curEnd = cursorMax(sel.head, sel.anchor);\n          linewise = vim.visualLine || operatorArgs.linewise;\n          mode = vim.visualBlock ? \"block\" : linewise ? \"line\" : \"char\";\n          cmSel = makeCmSelection(cm, {\n            anchor: curStart,\n            head: curEnd\n          }, mode);\n\n          if (linewise) {\n            var ranges = cmSel.ranges;\n\n            if (mode == \"block\") {\n              // Linewise operators in visual block mode extend to end of line\n              for (var i = 0; i < ranges.length; i++) {\n                ranges[i].head.ch = lineLength(cm, ranges[i].head.line);\n              }\n            } else if (mode == \"line\") {\n              ranges[0].head = new Pos(ranges[0].head.line + 1, 0);\n            }\n          }\n        } else {\n          // Init motion op\n          curStart = copyCursor(newAnchor || oldAnchor);\n          curEnd = copyCursor(newHead || oldHead);\n\n          if (cursorIsBefore(curEnd, curStart)) {\n            var tmp = curStart;\n            curStart = curEnd;\n            curEnd = tmp;\n          }\n\n          linewise = motionArgs.linewise || operatorArgs.linewise;\n\n          if (linewise) {\n            // Expand selection to entire line.\n            expandSelectionToLine(cm, curStart, curEnd);\n          } else if (motionArgs.forward) {\n            // Clip to trailing newlines only if the motion goes forward.\n            clipToLine(cm, curStart, curEnd);\n          }\n\n          mode = \"char\";\n          var exclusive = !motionArgs.inclusive || linewise;\n          cmSel = makeCmSelection(cm, {\n            anchor: curStart,\n            head: curEnd\n          }, mode, exclusive);\n        }\n\n        cm.setSelections(cmSel.ranges, cmSel.primary);\n        vim.lastMotion = null;\n        operatorArgs.repeat = repeat; // For indent in visual mode.\n\n        operatorArgs.registerName = registerName; // Keep track of linewise as it affects how paste and change behave.\n\n        operatorArgs.linewise = linewise;\n        var operatorMoveTo = operators[operator](cm, operatorArgs, cmSel.ranges, oldAnchor, newHead);\n\n        if (vim.visualMode) {\n          exitVisualMode(cm, operatorMoveTo != null);\n        }\n\n        if (operatorMoveTo) {\n          cm.setCursor(operatorMoveTo);\n        }\n      }\n    },\n    recordLastEdit: function recordLastEdit(vim, inputState, actionCommand) {\n      var macroModeState = vimGlobalState.macroModeState;\n\n      if (macroModeState.isPlaying) {\n        return;\n      }\n\n      vim.lastEditInputState = inputState;\n      vim.lastEditActionCommand = actionCommand;\n      macroModeState.lastInsertModeChanges.changes = [];\n      macroModeState.lastInsertModeChanges.expectCursorActivityForChange = false;\n      macroModeState.lastInsertModeChanges.visualBlock = vim.visualBlock ? vim.sel.head.line - vim.sel.anchor.line : 0;\n    }\n  };\n  /**\n   * typedef {Object{line:number,ch:number}} Cursor An object containing the\n   *     position of the cursor.\n   */\n  // All of the functions below return Cursor objects.\n\n  var motions = {\n    moveToTopLine: function moveToTopLine(cm, _head, motionArgs) {\n      var line = getUserVisibleLines(cm).top + motionArgs.repeat - 1;\n      return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n    },\n    moveToMiddleLine: function moveToMiddleLine(cm) {\n      var range = getUserVisibleLines(cm);\n      var line = Math.floor((range.top + range.bottom) * 0.5);\n      return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n    },\n    moveToBottomLine: function moveToBottomLine(cm, _head, motionArgs) {\n      var line = getUserVisibleLines(cm).bottom - motionArgs.repeat + 1;\n      return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n    },\n    expandToLine: function expandToLine(_cm, head, motionArgs) {\n      // Expands forward to end of line, and then to next line if repeat is\n      // >1. Does not handle backward motion!\n      var cur = head;\n      return new Pos(cur.line + motionArgs.repeat - 1, Infinity);\n    },\n    findNext: function findNext(cm, _head, motionArgs) {\n      var state = getSearchState(cm);\n      var query = state.getQuery();\n\n      if (!query) {\n        return;\n      }\n\n      var prev = !motionArgs.forward; // If search is initiated with ? instead of /, negate direction.\n\n      prev = state.isReversed() ? !prev : prev;\n      highlightSearchMatches(cm, query);\n      return _findNext(cm, prev\n      /** prev */\n      , query, motionArgs.repeat);\n    },\n\n    /**\n     * Find and select the next occurrence of the search query. If the cursor is currently\n     * within a match, then find and select the current match. Otherwise, find the next occurrence in the\n     * appropriate direction.\n     *\n     * This differs from `findNext` in the following ways:\n     *\n     * 1. Instead of only returning the \"from\", this returns a \"from\", \"to\" range.\n     * 2. If the cursor is currently inside a search match, this selects the current match\n     *    instead of the next match.\n     * 3. If there is no associated operator, this will turn on visual mode.\n     */\n    findAndSelectNextInclusive: function findAndSelectNextInclusive(cm, _head, motionArgs, vim, prevInputState) {\n      var state = getSearchState(cm);\n      var query = state.getQuery();\n\n      if (!query) {\n        return;\n      }\n\n      var prev = !motionArgs.forward;\n      prev = state.isReversed() ? !prev : prev; // next: [from, to] | null\n\n      var next = findNextFromAndToInclusive(cm, prev, query, motionArgs.repeat, vim); // No matches.\n\n      if (!next) {\n        return;\n      } // If there's an operator that will be executed, return the selection.\n\n\n      if (prevInputState.operator) {\n        return next;\n      } // At this point, we know that there is no accompanying operator -- let's\n      // deal with visual mode in order to select an appropriate match.\n\n\n      var from = next[0]; // For whatever reason, when we use the \"to\" as returned by searchcursor.js directly,\n      // the resulting selection is extended by 1 char. Let's shrink it so that only the\n      // match is selected.\n\n      var to = new Pos(next[1].line, next[1].ch - 1);\n\n      if (vim.visualMode) {\n        // If we were in visualLine or visualBlock mode, get out of it.\n        if (vim.visualLine || vim.visualBlock) {\n          vim.visualLine = false;\n          vim.visualBlock = false;\n\n          _cm_adapter[\"default\"].signal(cm, \"vim-mode-change\", {\n            mode: \"visual\",\n            subMode: \"\"\n          });\n        } // If we're currently in visual mode, we should extend the selection to include\n        // the search result.\n\n\n        var anchor = vim.sel.anchor;\n\n        if (anchor) {\n          if (state.isReversed()) {\n            if (motionArgs.forward) {\n              return [anchor, from];\n            }\n\n            return [anchor, to];\n          } else {\n            if (motionArgs.forward) {\n              return [anchor, to];\n            }\n\n            return [anchor, from];\n          }\n        }\n      } else {\n        // Let's turn visual mode on.\n        vim.visualMode = true;\n        vim.visualLine = false;\n        vim.visualBlock = false;\n\n        _cm_adapter[\"default\"].signal(cm, \"vim-mode-change\", {\n          mode: \"visual\",\n          subMode: \"\"\n        });\n      }\n\n      return prev ? [to, from] : [from, to];\n    },\n    goToMark: function goToMark(cm, _head, motionArgs, vim) {\n      var pos = getMarkPos(cm, vim, motionArgs.selectedCharacter);\n\n      if (pos) {\n        return motionArgs.linewise ? {\n          line: pos.line,\n          ch: findFirstNonWhiteSpaceCharacter(cm.getLine(pos.line))\n        } : pos;\n      }\n\n      return null;\n    },\n    moveToOtherHighlightedEnd: function moveToOtherHighlightedEnd(cm, _head, motionArgs, vim) {\n      if (vim.visualBlock && motionArgs.sameLine) {\n        var sel = vim.sel;\n        return [clipCursorToContent(cm, new Pos(sel.anchor.line, sel.head.ch)), clipCursorToContent(cm, new Pos(sel.head.line, sel.anchor.ch))];\n      } else {\n        return [vim.sel.head, vim.sel.anchor];\n      }\n    },\n    jumpToMark: function jumpToMark(cm, head, motionArgs, vim) {\n      var best = head;\n\n      for (var i = 0; i < motionArgs.repeat; i++) {\n        var cursor = best;\n\n        for (var key in vim.marks) {\n          if (!isLowerCase(key)) {\n            continue;\n          }\n\n          var mark = vim.marks[key].find();\n          var isWrongDirection = motionArgs.forward ? cursorIsBefore(mark, cursor) : cursorIsBefore(cursor, mark);\n\n          if (isWrongDirection) {\n            continue;\n          }\n\n          if (motionArgs.linewise && mark.line == cursor.line) {\n            continue;\n          }\n\n          var equal = cursorEqual(cursor, best);\n          var between = motionArgs.forward ? cursorIsBetween(cursor, mark, best) : cursorIsBetween(best, mark, cursor);\n\n          if (equal || between) {\n            best = mark;\n          }\n        }\n      }\n\n      if (motionArgs.linewise) {\n        // Vim places the cursor on the first non-whitespace character of\n        // the line if there is one, else it places the cursor at the end\n        // of the line, regardless of whether a mark was found.\n        best = new Pos(best.line, findFirstNonWhiteSpaceCharacter(cm.getLine(best.line)));\n      }\n\n      return best;\n    },\n    moveByCharacters: function moveByCharacters(_cm, head, motionArgs) {\n      var cur = head;\n      var repeat = motionArgs.repeat;\n      var ch = motionArgs.forward ? cur.ch + repeat : cur.ch - repeat;\n      return new Pos(cur.line, ch);\n    },\n    moveByLines: function moveByLines(cm, head, motionArgs, vim) {\n      var cur = head;\n      var endCh = cur.ch; // Depending what our last motion was, we may want to do different\n      // things. If our last motion was moving vertically, we want to\n      // preserve the HPos from our last horizontal move.  If our last motion\n      // was going to the end of a line, moving vertically we should go to\n      // the end of the line, etc.\n\n      switch (vim.lastMotion) {\n        case this.moveByLines:\n        case this.moveByDisplayLines:\n        case this.moveByScroll:\n        case this.moveToColumn:\n        case this.moveToEol:\n          endCh = vim.lastHPos;\n          break;\n\n        default:\n          vim.lastHPos = endCh;\n      }\n\n      var repeat = motionArgs.repeat + (motionArgs.repeatOffset || 0);\n      var line = motionArgs.forward ? cur.line + repeat : cur.line - repeat;\n      var first = cm.firstLine();\n      var last = cm.lastLine();\n      var posV = cm.findPosV(cur, motionArgs.forward ? repeat : -repeat, \"line\", vim.lastHSPos);\n      var hasMarkedText = motionArgs.forward ? posV.line > line : posV.line < line;\n\n      if (hasMarkedText) {\n        line = posV.line;\n        endCh = posV.ch;\n      } // Vim go to line begin or line end when cursor at first/last line and\n      // move to previous/next line is triggered.\n\n\n      if (line < first && cur.line == first) {\n        return this.moveToStartOfLine(cm, head, motionArgs, vim);\n      } else if (line > last && cur.line == last) {\n        return _moveToEol(cm, head, motionArgs, vim, true);\n      }\n\n      if (motionArgs.toFirstChar) {\n        endCh = findFirstNonWhiteSpaceCharacter(cm.getLine(line));\n        vim.lastHPos = endCh;\n      }\n\n      vim.lastHSPos = cm.charCoords(new Pos(line, endCh), \"div\").left;\n      return new Pos(line, endCh);\n    },\n    moveByDisplayLines: function moveByDisplayLines(cm, head, motionArgs, vim) {\n      var cur = head;\n\n      switch (vim.lastMotion) {\n        case this.moveByDisplayLines:\n        case this.moveByScroll:\n        case this.moveByLines:\n        case this.moveToColumn:\n        case this.moveToEol:\n          break;\n\n        default:\n          vim.lastHSPos = cm.charCoords(cur, \"div\").left;\n      }\n\n      var repeat = motionArgs.repeat;\n      var res = cm.findPosV(cur, motionArgs.forward ? repeat : -repeat, \"line\", vim.lastHSPos);\n\n      if (res.hitSide) {\n        if (motionArgs.forward) {\n          var lastCharCoords = cm.charCoords(res, \"div\");\n          var goalCoords = {\n            top: lastCharCoords.top + 8,\n            left: vim.lastHSPos\n          };\n          var res = cm.coordsChar(goalCoords, \"div\");\n        } else {\n          var resCoords = cm.charCoords(new Pos(cm.firstLine(), 0), \"div\");\n          resCoords.left = vim.lastHSPos;\n          res = cm.coordsChar(resCoords, \"div\");\n        }\n      }\n\n      vim.lastHPos = res.ch;\n      return res;\n    },\n    moveByPage: function moveByPage(cm, head, motionArgs) {\n      // CodeMirror only exposes functions that move the cursor page down, so\n      // doing this bad hack to move the cursor and move it back. evalInput\n      // will move the cursor to where it should be in the end.\n      var curStart = head;\n      var repeat = motionArgs.repeat;\n      return cm.findPosV(curStart, motionArgs.forward ? repeat : -repeat, \"page\");\n    },\n    moveByParagraph: function moveByParagraph(cm, head, motionArgs) {\n      var dir = motionArgs.forward ? 1 : -1;\n      return findParagraph(cm, head, motionArgs.repeat, dir);\n    },\n    moveBySentence: function moveBySentence(cm, head, motionArgs) {\n      var dir = motionArgs.forward ? 1 : -1;\n      return findSentence(cm, head, motionArgs.repeat, dir);\n    },\n    moveByScroll: function moveByScroll(cm, head, motionArgs, vim) {\n      var scrollbox = cm.getScrollInfo();\n      var curEnd = null;\n      var repeat = motionArgs.repeat;\n\n      if (!repeat) {\n        repeat = scrollbox.clientHeight / (2 * cm.defaultTextHeight());\n      }\n\n      var orig = cm.charCoords(head, \"local\");\n      motionArgs.repeat = repeat;\n      var curEnd = motions.moveByDisplayLines(cm, head, motionArgs, vim);\n\n      if (!curEnd) {\n        return null;\n      }\n\n      var dest = cm.charCoords(curEnd, \"local\");\n      cm.scrollTo(null, scrollbox.top + dest.top - orig.top);\n      return curEnd;\n    },\n    moveByWords: function moveByWords(cm, head, motionArgs) {\n      return moveToWord(cm, head, motionArgs.repeat, !!motionArgs.forward, !!motionArgs.wordEnd, !!motionArgs.bigWord);\n    },\n    moveTillCharacter: function moveTillCharacter(cm, _head, motionArgs) {\n      var repeat = motionArgs.repeat;\n\n      var curEnd = _moveToCharacter(cm, repeat, motionArgs.forward, motionArgs.selectedCharacter);\n\n      var increment = motionArgs.forward ? -1 : 1;\n      recordLastCharacterSearch(increment, motionArgs);\n      if (!curEnd) return null;\n      curEnd.ch += increment;\n      return curEnd;\n    },\n    moveToCharacter: function moveToCharacter(cm, head, motionArgs) {\n      var repeat = motionArgs.repeat;\n      recordLastCharacterSearch(0, motionArgs);\n      return _moveToCharacter(cm, repeat, motionArgs.forward, motionArgs.selectedCharacter) || head;\n    },\n    moveToSymbol: function moveToSymbol(cm, head, motionArgs) {\n      var repeat = motionArgs.repeat;\n      return findSymbol(cm, repeat, motionArgs.forward, motionArgs.selectedCharacter) || head;\n    },\n    moveToColumn: function moveToColumn(cm, head, motionArgs, vim) {\n      var repeat = motionArgs.repeat; // repeat is equivalent to which column we want to move to!\n\n      vim.lastHPos = repeat - 1;\n      vim.lastHSPos = cm.charCoords(head, \"div\").left;\n      return _moveToColumn(cm, repeat);\n    },\n    moveToEol: function moveToEol(cm, head, motionArgs, vim) {\n      return _moveToEol(cm, head, motionArgs, vim, false);\n    },\n    moveToFirstNonWhiteSpaceCharacter: function moveToFirstNonWhiteSpaceCharacter(cm, head) {\n      // Go to the start of the line where the text begins, or the end for\n      // whitespace-only lines\n      var cursor = head;\n      return new Pos(cursor.line, findFirstNonWhiteSpaceCharacter(cm.getLine(cursor.line)));\n    },\n    moveToMatchedSymbol: function moveToMatchedSymbol(cm, head) {\n      var cursor = head;\n      var line = cursor.line;\n      var ch = cursor.ch;\n      var lineText = cm.getLine(line); // var symbol;\n      // for (; ch < lineText.length; ch++) {\n      //   symbol = lineText.charAt(ch);\n      //   if (symbol && isMatchableSymbol(symbol)) {\n      //     var style = cm.getTokenTypeAt(new Pos(line, ch + 1));\n      //     if (style !== \"string\" && style !== \"comment\") {\n      //       break;\n      //     }\n      //   }\n      // }\n\n      if (ch < lineText.length) {\n        // Only include angle brackets in analysis if they are being matched.\n        var re = ch === \"<\" || ch === \">\" ? /[(){}[\\]<>]/ : /[(){}[\\]]/;\n        var matched = cm.findMatchingBracket(new Pos(line, ch), {\n          bracketRegex: re\n        });\n        return matched.to;\n      } else {\n        return cursor;\n      }\n    },\n    moveToStartOfLine: function moveToStartOfLine(_cm, head) {\n      return new Pos(head.line, 0);\n    },\n    moveToLineOrEdgeOfDocument: function moveToLineOrEdgeOfDocument(cm, _head, motionArgs) {\n      var lineNum = motionArgs.forward ? cm.lastLine() : cm.firstLine();\n\n      if (motionArgs.repeatIsExplicit) {\n        lineNum = motionArgs.repeat - cm.getOption(\"firstLineNumber\");\n      }\n\n      return new Pos(lineNum, findFirstNonWhiteSpaceCharacter(cm.getLine(lineNum)));\n    },\n    moveToStartOfDisplayLine: function moveToStartOfDisplayLine(cm) {\n      cm.execCommand(\"goLineLeft\");\n      return cm.getCursor();\n    },\n    moveToEndOfDisplayLine: function moveToEndOfDisplayLine(cm) {\n      cm.execCommand(\"goLineRight\");\n      var head = cm.getCursor();\n      if (head.sticky == \"before\") head.ch--;\n      return head;\n    },\n    textObjectManipulation: function textObjectManipulation(cm, head, motionArgs, vim) {\n      // TODO: lots of possible exceptions that can be thrown here. Try da(\n      //     outside of a () block.\n      var mirroredPairs = {\n        \"(\": \")\",\n        \")\": \"(\",\n        \"{\": \"}\",\n        \"}\": \"{\",\n        \"[\": \"]\",\n        \"]\": \"[\",\n        \"<\": \">\",\n        \">\": \"<\"\n      };\n      var selfPaired = {\n        \"'\": true,\n        '\"': true,\n        \"`\": true\n      };\n      var character = motionArgs.selectedCharacter; // 'b' refers to  '()' block.\n      // 'B' refers to  '{}' block.\n\n      if (character == \"b\") {\n        character = \"(\";\n      } else if (character == \"B\") {\n        character = \"{\";\n      } // Inclusive is the difference between a and i\n      // TODO: Instead of using the additional text object map to perform text\n      //     object operations, merge the map into the defaultKeyMap and use\n      //     motionArgs to define behavior. Define separate entries for 'aw',\n      //     'iw', 'a[', 'i[', etc.\n\n\n      var inclusive = !motionArgs.textObjectInner;\n      var tmp;\n\n      if (mirroredPairs[character]) {\n        tmp = selectCompanionObject(cm, head, character, inclusive);\n      } else if (selfPaired[character]) {\n        tmp = findBeginningAndEnd(cm, head, character, inclusive);\n      } else if (character === \"W\") {\n        tmp = expandWordUnderCursor(cm, inclusive, true\n        /** forward */\n        , true\n        /** bigWord */\n        );\n      } else if (character === \"w\") {\n        tmp = expandWordUnderCursor(cm, inclusive, true\n        /** forward */\n        , false\n        /** bigWord */\n        );\n      } else if (character === \"p\") {\n        tmp = findParagraph(cm, head, motionArgs.repeat, 0, inclusive);\n        motionArgs.linewise = true;\n\n        if (vim.visualMode) {\n          if (!vim.visualLine) {\n            vim.visualLine = true;\n          }\n        } else {\n          var operatorArgs = vim.inputState.operatorArgs;\n\n          if (operatorArgs) {\n            operatorArgs.linewise = true;\n          }\n\n          tmp.end.line--;\n        }\n      } else if (character === \"t\") {\n        tmp = expandTagUnderCursor(cm, head, inclusive);\n      } else {\n        // No text object defined for this, don't move.\n        return null;\n      }\n\n      if (!cm.state.vim.visualMode) {\n        return [tmp.start, tmp.end];\n      } else {\n        return expandSelection(cm, tmp.start, tmp.end);\n      }\n    },\n    repeatLastCharacterSearch: function repeatLastCharacterSearch(cm, head, motionArgs) {\n      var lastSearch = vimGlobalState.lastCharacterSearch;\n      var repeat = motionArgs.repeat;\n      var forward = motionArgs.forward === lastSearch.forward;\n      var increment = (lastSearch.increment ? 1 : 0) * (forward ? -1 : 1);\n      cm.moveH(-increment, \"char\");\n      motionArgs.inclusive = forward ? true : false;\n\n      var curEnd = _moveToCharacter(cm, repeat, forward, lastSearch.selectedCharacter);\n\n      if (!curEnd) {\n        cm.moveH(increment, \"char\");\n        return head;\n      }\n\n      curEnd.ch += increment;\n      return curEnd;\n    }\n  };\n\n  function defineMotion(name, fn) {\n    motions[name] = fn;\n  }\n\n  function fillArray(val, times) {\n    var arr = [];\n\n    for (var i = 0; i < times; i++) {\n      arr.push(val);\n    }\n\n    return arr;\n  }\n  /**\n   * An operator acts on a text selection. It receives the list of selections\n   * as input. The corresponding CodeMirror selection is guaranteed to\n   * match the input selection.\n   */\n\n\n  var operators = {\n    change: function change(cm, args, ranges) {\n      var finalHead, text;\n      var vim = cm.state.vim;\n      var anchor = ranges[0].anchor,\n          head = ranges[0].head;\n\n      if (!vim.visualMode) {\n        text = cm.getRange(anchor, head);\n        var lastState = vim.lastEditInputState || {};\n\n        if (lastState.motion == \"moveByWords\" && !isWhiteSpaceString(text)) {\n          // Exclude trailing whitespace if the range is not all whitespace.\n          var match = /\\s+$/.exec(text);\n\n          if (match && lastState.motionArgs && lastState.motionArgs.forward) {\n            head = offsetCursor(head, 0, -match[0].length);\n            text = text.slice(0, -match[0].length);\n          }\n        }\n\n        var prevLineEnd = new Pos(anchor.line - 1, Number.MAX_VALUE);\n        var wasLastLine = cm.firstLine() == cm.lastLine();\n\n        if (head.line > cm.lastLine() && args.linewise && !wasLastLine) {\n          cm.replaceRange(\"\", prevLineEnd, head);\n        } else {\n          cm.replaceRange(\"\", anchor, head);\n        }\n\n        if (args.linewise) {\n          // Push the next line back down, if there is a next line.\n          if (!wasLastLine) {\n            cm.setCursor(prevLineEnd);\n\n            _cm_adapter[\"default\"].commands.newlineAndIndent(cm);\n          } // make sure cursor ends up at the end of the line.\n\n\n          anchor.ch = Number.MAX_VALUE;\n        }\n\n        finalHead = anchor;\n      } else if (args.fullLine) {\n        head.ch = Number.MAX_VALUE;\n        head.line--;\n        cm.setSelection(anchor, head);\n        text = cm.getSelection();\n        cm.replaceSelections(\"\");\n        finalHead = anchor;\n      } else {\n        text = cm.getSelection();\n        var replacement = fillArray(\"\", ranges.length);\n        cm.replaceSelections(replacement);\n        finalHead = cursorMin(ranges[0].head, ranges[0].anchor);\n      }\n\n      vimGlobalState.registerController.pushText(args.registerName, \"change\", text, args.linewise, ranges.length > 1);\n      actions.enterInsertMode(cm, {\n        head: finalHead\n      }, cm.state.vim);\n    },\n    // delete is a javascript keyword.\n    \"delete\": function _delete(cm, args, ranges) {\n      // Add to the undo stack explicitly so that this delete is recorded as a\n      // specific action instead of being bundled with generic other edits.\n      cm.pushUndoStop();\n      var finalHead, text;\n      var vim = cm.state.vim;\n\n      if (!vim.visualBlock) {\n        var anchor = ranges[0].anchor,\n            head = ranges[0].head;\n\n        if (args.linewise && head.line != cm.firstLine() && anchor.line == cm.lastLine() && anchor.line == head.line - 1) {\n          // Special case for dd on last line (and first line).\n          if (anchor.line == cm.firstLine()) {\n            anchor.ch = 0;\n          } else {\n            anchor = new Pos(anchor.line - 1, lineLength(cm, anchor.line - 1));\n          }\n        }\n\n        text = cm.getRange(anchor, head);\n        cm.replaceRange(\"\", anchor, head);\n        finalHead = anchor;\n\n        if (args.linewise) {\n          finalHead = motions.moveToFirstNonWhiteSpaceCharacter(cm, anchor);\n        }\n      } else {\n        text = cm.getSelection();\n        var replacement = fillArray(\"\", ranges.length);\n        cm.replaceSelections(replacement);\n        finalHead = cursorMin(ranges[0].head, ranges[0].anchor);\n      }\n\n      vimGlobalState.registerController.pushText(args.registerName, \"delete\", text, args.linewise, vim.visualBlock);\n      return clipCursorToContent(cm, finalHead);\n    },\n    indent: function indent(cm, args, ranges) {\n      var vim = cm.state.vim;\n      var startLine = ranges[0].anchor.line;\n      var endLine = vim.visualBlock ? ranges[ranges.length - 1].anchor.line : ranges[0].head.line; // In visual mode, n> shifts the selection right n times, instead of\n      // shifting n lines right once.\n\n      var repeat = vim.visualMode ? args.repeat : 1;\n\n      if (args.linewise) {\n        // The only way to delete a newline is to delete until the start of\n        // the next line, so in linewise mode evalInput will include the next\n        // line. We don't want this in indent, so we go back a line.\n        endLine--;\n      }\n\n      cm.pushUndoStop();\n\n      for (var i = startLine; i <= endLine; i++) {\n        for (var j = 0; j < repeat; j++) {\n          cm.indentLine(i, args.indentRight);\n        }\n      }\n\n      cm.pushUndoStop();\n      return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);\n    },\n    indentAuto: function indentAuto(cm, _args, ranges) {\n      cm.execCommand(\"indentAuto\");\n      return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);\n    },\n    changeCase: function changeCase(cm, args, ranges, oldAnchor, newHead) {\n      var selections = cm.getSelections();\n      var swapped = [];\n      var toLower = args.toLower;\n\n      for (var j = 0; j < selections.length; j++) {\n        var toSwap = selections[j];\n        var text = \"\";\n\n        if (toLower === true) {\n          text = toSwap.toLowerCase();\n        } else if (toLower === false) {\n          text = toSwap.toUpperCase();\n        } else {\n          for (var i = 0; i < toSwap.length; i++) {\n            var character = toSwap.charAt(i);\n            text += isUpperCase(character) ? character.toLowerCase() : character.toUpperCase();\n          }\n        }\n\n        swapped.push(text);\n      }\n\n      cm.replaceSelections(swapped);\n\n      if (args.shouldMoveCursor) {\n        return newHead;\n      } else if (!cm.state.vim.visualMode && args.linewise && ranges[0].anchor.line + 1 == ranges[0].head.line) {\n        return motions.moveToFirstNonWhiteSpaceCharacter(cm, oldAnchor);\n      } else if (args.linewise) {\n        return oldAnchor;\n      } else {\n        return cursorMin(ranges[0].anchor, ranges[0].head);\n      }\n    },\n    yank: function yank(cm, args, ranges, oldAnchor) {\n      var vim = cm.state.vim;\n      var text = cm.getSelection();\n      var endPos = vim.visualMode ? cursorMin(vim.sel.anchor, vim.sel.head, ranges[0].head, ranges[0].anchor) : oldAnchor;\n      vimGlobalState.registerController.pushText(args.registerName, \"yank\", text, args.linewise, vim.visualBlock);\n      return endPos;\n    }\n  };\n\n  function defineOperator(name, fn) {\n    operators[name] = fn;\n  }\n\n  var actions = {\n    jumpListWalk: function jumpListWalk(cm, actionArgs, vim) {\n      if (vim.visualMode) {\n        return;\n      }\n\n      var repeat = actionArgs.repeat;\n      var forward = actionArgs.forward;\n      var jumpList = vimGlobalState.jumpList;\n      var mark = jumpList.move(cm, forward ? repeat : -repeat);\n      var markPos = mark ? mark.find() : undefined;\n      markPos = markPos ? markPos : cm.getCursor();\n      cm.setCursor(markPos);\n    },\n    scroll: function scroll(cm, actionArgs, vim) {\n      if (vim.visualMode) {\n        return;\n      }\n\n      var repeat = actionArgs.repeat || 1;\n      var lineHeight = cm.defaultTextHeight();\n      var top = cm.getScrollInfo().top;\n      var delta = lineHeight * repeat;\n      var newPos = actionArgs.forward ? top + delta : top - delta;\n      var cursor = copyCursor(cm.getCursor());\n      var cursorCoords = cm.charCoords(cursor, \"local\");\n\n      if (actionArgs.forward) {\n        if (newPos > cursorCoords.top) {\n          cursor.line += (newPos - cursorCoords.top) / lineHeight;\n          cursor.line = Math.ceil(cursor.line);\n          cm.setCursor(cursor);\n          cursorCoords = cm.charCoords(cursor, \"local\");\n          cm.scrollTo(null, cursorCoords.top);\n        } else {\n          // Cursor stays within bounds.  Just reposition the scroll window.\n          cm.scrollTo(null, newPos);\n        }\n      } else {\n        var newBottom = newPos + cm.getScrollInfo().clientHeight;\n\n        if (newBottom < cursorCoords.bottom) {\n          cursor.line -= (cursorCoords.bottom - newBottom) / lineHeight;\n          cursor.line = Math.floor(cursor.line);\n          cm.setCursor(cursor);\n          cursorCoords = cm.charCoords(cursor, \"local\");\n          cm.scrollTo(null, cursorCoords.bottom - cm.getScrollInfo().clientHeight);\n        } else {\n          // Cursor stays within bounds.  Just reposition the scroll window.\n          cm.scrollTo(null, newPos);\n        }\n      }\n    },\n    scrollToCursor: function scrollToCursor(cm, actionArgs) {\n      var lineNum = cm.getCursor().line;\n      var charCoords = cm.charCoords(new Pos(lineNum, 0), \"local\");\n      var height = cm.getScrollInfo().clientHeight;\n      var y = charCoords.top;\n      var lineHeight = charCoords.bottom - y;\n\n      switch (actionArgs.position) {\n        case \"center\":\n          y = y - height / 2 + lineHeight;\n          break;\n\n        case \"bottom\":\n          y = y - height + lineHeight;\n          break;\n      } // cm.scrollTo(null, y);\n\n\n      cm.moveCurrentLineTo(y);\n    },\n    replayMacro: function replayMacro(cm, actionArgs, vim) {\n      var registerName = actionArgs.selectedCharacter;\n      var repeat = actionArgs.repeat;\n      var macroModeState = vimGlobalState.macroModeState;\n\n      if (registerName == \"@\") {\n        registerName = macroModeState.latestRegister;\n      } else {\n        macroModeState.latestRegister = registerName;\n      }\n\n      while (repeat--) {\n        executeMacroRegister(cm, vim, macroModeState, registerName);\n      }\n    },\n    enterMacroRecordMode: function enterMacroRecordMode(cm, actionArgs) {\n      var macroModeState = vimGlobalState.macroModeState;\n      var registerName = actionArgs.selectedCharacter;\n\n      if (vimGlobalState.registerController.isValidRegister(registerName)) {\n        macroModeState.enterMacroRecordMode(cm, registerName);\n      }\n    },\n    toggleOverwrite: function toggleOverwrite(cm) {\n      if (!cm.state.overwrite) {\n        cm.toggleOverwrite(true);\n        cm.setOption(\"keyMap\", \"vim-replace\");\n\n        _cm_adapter[\"default\"].signal(cm, \"vim-mode-change\", {\n          mode: \"replace\"\n        });\n      } else {\n        cm.toggleOverwrite(false);\n        cm.setOption(\"keyMap\", \"vim-insert\");\n\n        _cm_adapter[\"default\"].signal(cm, \"vim-mode-change\", {\n          mode: \"insert\"\n        });\n      }\n    },\n    enterInsertMode: function enterInsertMode(cm, actionArgs, vim) {\n      if (cm.getOption(\"readOnly\")) {\n        return;\n      }\n\n      vim.insertMode = true;\n      vim.insertModeRepeat = actionArgs && actionArgs.repeat || 1;\n      var insertAt = actionArgs ? actionArgs.insertAt : null;\n      var sel = vim.sel;\n      var head = actionArgs.head || cm.getCursor(\"head\");\n      var height = cm.listSelections().length;\n\n      if (insertAt == \"eol\") {\n        head = new Pos(head.line, lineLength(cm, head.line));\n      } else if (insertAt == \"bol\") {\n        head = new Pos(head.line, 0);\n      } else if (insertAt == \"charAfter\") {\n        head = offsetCursor(head, 0, 1);\n      } else if (insertAt == \"firstNonBlank\") {\n        head = motions.moveToFirstNonWhiteSpaceCharacter(cm, head);\n      } else if (insertAt == \"startOfSelectedArea\") {\n        if (!vim.visualMode) return;\n\n        if (!vim.visualBlock) {\n          if (sel.head.line < sel.anchor.line) {\n            head = sel.head;\n          } else {\n            head = new Pos(sel.anchor.line, 0);\n          }\n        } else {\n          head = new Pos(Math.min(sel.head.line, sel.anchor.line), Math.min(sel.head.ch, sel.anchor.ch));\n          height = Math.abs(sel.head.line - sel.anchor.line) + 1;\n        }\n      } else if (insertAt == \"endOfSelectedArea\") {\n        if (!vim.visualMode) return;\n\n        if (!vim.visualBlock) {\n          if (sel.head.line >= sel.anchor.line) {\n            head = offsetCursor(sel.head, 0, 1);\n          } else {\n            head = new Pos(sel.anchor.line, 0);\n          }\n        } else {\n          head = new Pos(Math.min(sel.head.line, sel.anchor.line), Math.max(sel.head.ch, sel.anchor.ch) + 1);\n          height = Math.abs(sel.head.line - sel.anchor.line) + 1;\n        }\n      } else if (insertAt == \"inplace\") {\n        if (vim.visualMode) {\n          return;\n        }\n      } else if (insertAt == \"lastEdit\") {\n        head = getLastEditPos(cm) || head;\n      }\n\n      cm.setOption(\"disableInput\", false);\n\n      if (actionArgs && actionArgs.replace) {\n        // Handle Replace-mode as a special case of insert mode.\n        cm.toggleOverwrite(true);\n        cm.setOption(\"keyMap\", \"vim-replace\");\n\n        _cm_adapter[\"default\"].signal(cm, \"vim-mode-change\", {\n          mode: \"replace\"\n        });\n      } else {\n        cm.toggleOverwrite(false);\n        cm.setOption(\"keyMap\", \"vim-insert\");\n\n        _cm_adapter[\"default\"].signal(cm, \"vim-mode-change\", {\n          mode: \"insert\"\n        });\n      }\n\n      if (!vimGlobalState.macroModeState.isPlaying) {\n        // Only record if not replaying.\n        cm.on(\"change\", onChange);\n\n        _cm_adapter[\"default\"].on(cm.getInputField(), \"keydown\", onKeyEventTargetKeyDown);\n      }\n\n      if (vim.visualMode) {\n        exitVisualMode(cm);\n      }\n\n      selectForInsert(cm, head, height);\n    },\n    toggleVisualMode: function toggleVisualMode(cm, actionArgs, vim) {\n      var repeat = actionArgs.repeat;\n      var anchor = cm.getCursor();\n      var head; // TODO: The repeat should actually select number of characters/lines\n      //     equal to the repeat times the size of the previous visual\n      //     operation.\n\n      if (!vim.visualMode) {\n        // Entering visual mode\n        vim.visualMode = true;\n        vim.visualLine = !!actionArgs.linewise;\n        vim.visualBlock = !!actionArgs.blockwise;\n        head = clipCursorToContent(cm, new Pos(anchor.line, anchor.ch + repeat - 1));\n        vim.sel = {\n          anchor: anchor,\n          head: head\n        };\n\n        _cm_adapter[\"default\"].signal(cm, \"vim-mode-change\", {\n          mode: \"visual\",\n          subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\"\n        });\n\n        updateCmSelection(cm);\n        updateMark(cm, vim, \"<\", cursorMin(anchor, head));\n        updateMark(cm, vim, \">\", cursorMax(anchor, head));\n      } else if (vim.visualLine ^ actionArgs.linewise || vim.visualBlock ^ actionArgs.blockwise) {\n        // Toggling between modes\n        vim.visualLine = !!actionArgs.linewise;\n        vim.visualBlock = !!actionArgs.blockwise;\n\n        _cm_adapter[\"default\"].signal(cm, \"vim-mode-change\", {\n          mode: \"visual\",\n          subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\"\n        });\n\n        updateCmSelection(cm);\n      } else {\n        exitVisualMode(cm);\n      }\n    },\n    reselectLastSelection: function reselectLastSelection(cm, _actionArgs, vim) {\n      var lastSelection = vim.lastSelection;\n\n      if (vim.visualMode) {\n        updateLastSelection(cm, vim);\n      }\n\n      if (lastSelection) {\n        var anchor = lastSelection.anchorMark.find();\n        var head = lastSelection.headMark.find();\n\n        if (!anchor || !head) {\n          // If the marks have been destroyed due to edits, do nothing.\n          return;\n        }\n\n        vim.sel = {\n          anchor: anchor,\n          head: head\n        };\n        vim.visualMode = true;\n        vim.visualLine = lastSelection.visualLine;\n        vim.visualBlock = lastSelection.visualBlock;\n        updateCmSelection(cm);\n        updateMark(cm, vim, \"<\", cursorMin(anchor, head));\n        updateMark(cm, vim, \">\", cursorMax(anchor, head));\n\n        _cm_adapter[\"default\"].signal(cm, \"vim-mode-change\", {\n          mode: \"visual\",\n          subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\"\n        });\n      }\n    },\n    joinLines: function joinLines(cm, actionArgs, vim) {\n      var curStart, curEnd;\n\n      if (vim.visualMode) {\n        curStart = cm.getCursor(\"anchor\");\n        curEnd = cm.getCursor(\"head\");\n\n        if (cursorIsBefore(curEnd, curStart)) {\n          var tmp = curEnd;\n          curEnd = curStart;\n          curStart = tmp;\n        }\n\n        curEnd.ch = lineLength(cm, curEnd.line) - 1;\n      } else {\n        // Repeat is the number of lines to join. Minimum 2 lines.\n        var repeat = Math.max(actionArgs.repeat, 2);\n        curStart = cm.getCursor();\n        curEnd = clipCursorToContent(cm, new Pos(curStart.line + repeat - 1, Infinity));\n      }\n\n      var finalCh = 0;\n\n      for (var i = curStart.line; i < curEnd.line; i++) {\n        finalCh = lineLength(cm, curStart.line);\n        var tmp = new Pos(curStart.line + 1, lineLength(cm, curStart.line + 1));\n        var text = cm.getRange(curStart, tmp);\n        text = actionArgs.keepSpaces ? text.replace(/\\n\\r?/g, \"\") : text.replace(/\\n\\s*/g, \" \");\n        cm.replaceRange(text, curStart, tmp);\n      }\n\n      var curFinalPos = new Pos(curStart.line, finalCh);\n\n      if (vim.visualMode) {\n        exitVisualMode(cm, false);\n      }\n\n      cm.setCursor(curFinalPos);\n    },\n    newLineAndEnterInsertMode: function newLineAndEnterInsertMode(cm, actionArgs, vim) {\n      if (cm.getOption(\"readOnly\")) {\n        return;\n      }\n\n      vim.insertMode = true;\n      var insertAt = copyCursor(cm.getCursor());\n\n      if (insertAt.line === cm.firstLine() && !actionArgs.after) {\n        // Special case for inserting newline before start of document.\n        cm.replaceRange(\"\\n\", new Pos(cm.firstLine(), 0));\n        cm.setCursor(cm.firstLine(), 0);\n      } else {\n        insertAt.line = actionArgs.after ? insertAt.line : insertAt.line - 1;\n        insertAt.ch = lineLength(cm, insertAt.line);\n        cm.setCursor(insertAt);\n        var newlineFn = _cm_adapter[\"default\"].commands.newlineAndIndentContinueComment || _cm_adapter[\"default\"].commands.newlineAndIndent;\n        newlineFn(cm);\n      }\n\n      this.enterInsertMode(cm, {\n        repeat: actionArgs.repeat\n      }, vim);\n    },\n    paste: function paste(cm, actionArgs, vim) {\n      var cur = copyCursor(cm.getCursor());\n      var register = vimGlobalState.registerController.getRegister(actionArgs.registerName);\n      var text = register.toString();\n\n      if (!text) {\n        return;\n      }\n\n      if (actionArgs.matchIndent) {\n        var tabSize = cm.getOption(\"tabSize\"); // length that considers tabs and tabSize\n\n        var whitespaceLength = function whitespaceLength(str) {\n          var tabs = str.split(\"\\t\").length - 1;\n          var spaces = str.split(\" \").length - 1;\n          return tabs * tabSize + spaces * 1;\n        };\n\n        var currentLine = cm.getLine(cm.getCursor().line);\n        var indent = whitespaceLength(currentLine.match(/^\\s*/)[0]); // chomp last newline b/c don't want it to match /^\\s*/gm\n\n        var chompedText = text.replace(/\\n$/, \"\");\n        var wasChomped = text !== chompedText;\n        var firstIndent = whitespaceLength(text.match(/^\\s*/)[0]);\n        var text = chompedText.replace(/^\\s*/gm, function (wspace) {\n          var newIndent = indent + (whitespaceLength(wspace) - firstIndent);\n\n          if (newIndent < 0) {\n            return \"\";\n          } else if (cm.getOption(\"indentWithTabs\")) {\n            var quotient = Math.floor(newIndent / tabSize);\n            return Array(quotient + 1).join(\"\\t\");\n          } else {\n            return Array(newIndent + 1).join(\" \");\n          }\n        });\n        text += wasChomped ? \"\\n\" : \"\";\n      }\n\n      if (actionArgs.repeat > 1) {\n        var text = Array(actionArgs.repeat + 1).join(text);\n      }\n\n      var linewise = register.linewise;\n      var blockwise = register.blockwise;\n\n      if (blockwise) {\n        text = text.split(\"\\n\");\n\n        if (linewise) {\n          text.pop();\n        }\n\n        for (var i = 0; i < text.length; i++) {\n          text[i] = text[i] == \"\" ? \" \" : text[i];\n        }\n\n        cur.ch += actionArgs.after ? 1 : 0;\n        cur.ch = Math.min(lineLength(cm, cur.line), cur.ch);\n      } else if (linewise) {\n        if (vim.visualMode) {\n          text = vim.visualLine ? text.slice(0, -1) : \"\\n\" + text.slice(0, text.length - 1) + \"\\n\";\n        } else if (actionArgs.after) {\n          // Move the newline at the end to the start instead, and paste just\n          // before the newline character of the line we are on right now.\n          text = \"\\n\" + text.slice(0, text.length - 1);\n          cur.ch = lineLength(cm, cur.line);\n        } else {\n          cur.ch = 0;\n        }\n      } else {\n        cur.ch += actionArgs.after ? 1 : 0;\n      }\n\n      var curPosFinal;\n      var idx;\n\n      if (vim.visualMode) {\n        //  save the pasted text for reselection if the need arises\n        vim.lastPastedText = text;\n        var lastSelectionCurEnd;\n        var selectedArea = getSelectedAreaRange(cm, vim);\n        var selectionStart = selectedArea[0];\n        var selectionEnd = selectedArea[1];\n        var selectedText = cm.getSelection();\n        var selections = cm.listSelections();\n        var emptyStrings = new Array(selections.length).join(\"1\").split(\"1\"); // save the curEnd marker before it get cleared due to cm.replaceRange.\n\n        if (vim.lastSelection) {\n          lastSelectionCurEnd = vim.lastSelection.headMark.find();\n        } // push the previously selected text to unnamed register\n\n\n        vimGlobalState.registerController.unnamedRegister.setText(selectedText);\n\n        if (blockwise) {\n          // first delete the selected text\n          cm.replaceSelections(emptyStrings); // Set new selections as per the block length of the yanked text\n\n          selectionEnd = new Pos(selectionStart.line + text.length - 1, selectionStart.ch);\n          cm.setCursor(selectionStart);\n          selectBlock(cm, selectionEnd);\n          cm.replaceSelections(text);\n          curPosFinal = selectionStart;\n        } else if (vim.visualBlock) {\n          cm.replaceSelections(emptyStrings);\n          cm.setCursor(selectionStart);\n          cm.replaceRange(text, selectionStart, selectionStart);\n          curPosFinal = selectionStart;\n        } else {\n          cm.replaceRange(text, selectionStart, selectionEnd);\n          curPosFinal = cm.posFromIndex(cm.indexFromPos(selectionStart) + text.length - 1);\n        } // restore the the curEnd marker\n\n\n        if (lastSelectionCurEnd) {\n          vim.lastSelection.headMark = cm.setBookmark(lastSelectionCurEnd);\n        }\n\n        if (linewise) {\n          curPosFinal.ch = 0;\n        }\n      } else {\n        if (blockwise) {\n          cm.setCursor(cur);\n\n          for (var i = 0; i < text.length; i++) {\n            var line = cur.line + i;\n\n            if (line > cm.lastLine()) {\n              cm.replaceRange(\"\\n\", new Pos(line, 0));\n            }\n\n            var lastCh = lineLength(cm, line);\n\n            if (lastCh < cur.ch) {\n              extendLineToColumn(cm, line, cur.ch);\n            }\n          }\n\n          cm.setCursor(cur);\n          selectBlock(cm, new Pos(cur.line + text.length - 1, cur.ch));\n          cm.replaceSelections(text);\n          curPosFinal = cur;\n        } else {\n          cm.replaceRange(text, cur); // Now fine tune the cursor to where we want it.\n\n          if (linewise && actionArgs.after) {\n            curPosFinal = new Pos(cur.line + 1, findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line + 1)));\n          } else if (linewise && !actionArgs.after) {\n            curPosFinal = new Pos(cur.line, findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line)));\n          } else if (!linewise && actionArgs.after) {\n            idx = cm.indexFromPos(cur);\n            curPosFinal = cm.posFromIndex(idx + text.length - 1);\n          } else {\n            idx = cm.indexFromPos(cur);\n            curPosFinal = cm.posFromIndex(idx + text.length);\n          }\n        }\n      }\n\n      if (vim.visualMode) {\n        exitVisualMode(cm, false);\n      }\n\n      cm.setCursor(curPosFinal);\n    },\n    undo: function undo(cm, actionArgs) {\n      cm.operation(function () {\n        repeatFn(cm, _cm_adapter[\"default\"].commands.undo, actionArgs.repeat)();\n        cm.setCursor(cm.getCursor(\"anchor\"));\n      });\n    },\n    redo: function redo(cm, actionArgs) {\n      repeatFn(cm, _cm_adapter[\"default\"].commands.redo, actionArgs.repeat)();\n    },\n    setRegister: function setRegister(_cm, actionArgs, vim) {\n      vim.inputState.registerName = actionArgs.selectedCharacter;\n    },\n    setMark: function setMark(cm, actionArgs, vim) {\n      var markName = actionArgs.selectedCharacter;\n      updateMark(cm, vim, markName, cm.getCursor());\n    },\n    replace: function replace(cm, actionArgs, vim) {\n      var replaceWith = actionArgs.selectedCharacter;\n      var curStart = cm.getCursor();\n      var replaceTo;\n      var curEnd;\n      var selections = cm.listSelections();\n\n      if (vim.visualMode) {\n        curStart = cm.getCursor(\"start\");\n        curEnd = cm.getCursor(\"end\");\n      } else {\n        var line = cm.getLine(curStart.line);\n        replaceTo = curStart.ch + actionArgs.repeat;\n\n        if (replaceTo > line.length) {\n          replaceTo = line.length;\n        }\n\n        curEnd = new Pos(curStart.line, replaceTo);\n      }\n\n      if (replaceWith == \"\\n\") {\n        if (!vim.visualMode) cm.replaceRange(\"\", curStart, curEnd); // special case, where vim help says to replace by just one line-break\n\n        (_cm_adapter[\"default\"].commands.newlineAndIndentContinueComment || _cm_adapter[\"default\"].commands.newlineAndIndent)(cm);\n      } else {\n        var replaceWithStr = cm.getRange(curStart, curEnd); //replace all characters in range by selected, but keep linebreaks\n\n        replaceWithStr = replaceWithStr.replace(/[^\\n]/g, replaceWith);\n\n        if (vim.visualBlock) {\n          // Tabs are split in visua block before replacing\n          var spaces = new Array(cm.getOption(\"tabSize\") + 1).join(\" \");\n          replaceWithStr = cm.getSelection();\n          replaceWithStr = replaceWithStr.replace(/\\t/g, spaces).replace(/[^\\n]/g, replaceWith).split(\"\\n\");\n          cm.replaceSelections(replaceWithStr);\n        } else {\n          cm.replaceRange(replaceWithStr, curStart, curEnd);\n        }\n\n        if (vim.visualMode) {\n          curStart = cursorIsBefore(selections[0].anchor, selections[0].head) ? selections[0].anchor : selections[0].head;\n          cm.setCursor(curStart);\n          exitVisualMode(cm, false);\n        } else {\n          cm.setCursor(offsetCursor(curEnd, 0, -1));\n        }\n      }\n    },\n    incrementNumberToken: function incrementNumberToken(cm, actionArgs) {\n      var cur = cm.getCursor();\n      var lineStr = cm.getLine(cur.line);\n      var re = /(-?)(?:(0x)([\\da-f]+)|(0b|0|)(\\d+))/gi;\n      var match;\n      var start;\n      var end;\n      var numberStr;\n\n      while ((match = re.exec(lineStr)) !== null) {\n        start = match.index;\n        end = start + match[0].length;\n        if (cur.ch < end) break;\n      }\n\n      if (!actionArgs.backtrack && end <= cur.ch) return;\n\n      if (match) {\n        var baseStr = match[2] || match[4];\n        var digits = match[3] || match[5];\n        var increment = actionArgs.increase ? 1 : -1;\n        var base = {\n          \"0b\": 2,\n          0: 8,\n          \"\": 10,\n          \"0x\": 16\n        }[baseStr.toLowerCase()];\n        var number = parseInt(match[1] + digits, base) + increment * actionArgs.repeat;\n        numberStr = number.toString(base);\n        var zeroPadding = baseStr ? new Array(digits.length - numberStr.length + 1 + match[1].length).join(\"0\") : \"\";\n\n        if (numberStr.charAt(0) === \"-\") {\n          numberStr = \"-\" + baseStr + zeroPadding + numberStr.substr(1);\n        } else {\n          numberStr = baseStr + zeroPadding + numberStr;\n        }\n\n        var from = new Pos(cur.line, start);\n        var to = new Pos(cur.line, end);\n        cm.replaceRange(numberStr, from, to);\n      } else {\n        return;\n      }\n\n      cm.setCursor(new Pos(cur.line, start + numberStr.length - 1));\n    },\n    repeatLastEdit: function repeatLastEdit(cm, actionArgs, vim) {\n      var lastEditInputState = vim.lastEditInputState;\n\n      if (!lastEditInputState) {\n        return;\n      }\n\n      var repeat = actionArgs.repeat;\n\n      if (repeat && actionArgs.repeatIsExplicit) {\n        vim.lastEditInputState.repeatOverride = repeat;\n      } else {\n        repeat = vim.lastEditInputState.repeatOverride || repeat;\n      }\n\n      _repeatLastEdit(cm, vim, repeat, false\n      /** repeatForInsert */\n      );\n    },\n    indent: function indent(cm, actionArgs) {\n      cm.indentLine(cm.getCursor().line, actionArgs.indentRight);\n    },\n    exitInsertMode: exitInsertMode\n  };\n\n  function defineAction(name, fn) {\n    actions[name] = fn;\n  }\n  /*\n   * Below are miscellaneous utility functions used by vim.js\n   */\n\n  /**\n   * Clips cursor to ensure that line is within the buffer's range\n   * If includeLineBreak is true, then allow cur.ch == lineLength.\n   */\n\n\n  function clipCursorToContent(cm, cur) {\n    var vim = cm.state.vim;\n    var includeLineBreak = vim.insertMode || vim.visualMode;\n    var line = Math.min(Math.max(cm.firstLine(), cur.line), cm.lastLine());\n    var maxCh = lineLength(cm, line) - 1 + !!includeLineBreak;\n    var ch = Math.min(Math.max(0, cur.ch), maxCh);\n    return new Pos(line, ch);\n  }\n\n  function copyArgs(args) {\n    var ret = {};\n\n    for (var prop in args) {\n      if (args.hasOwnProperty(prop)) {\n        ret[prop] = args[prop];\n      }\n    }\n\n    return ret;\n  }\n\n  function offsetCursor(cur, offsetLine, offsetCh) {\n    if (_typeof(offsetLine) === \"object\") {\n      offsetCh = offsetLine.ch;\n      offsetLine = offsetLine.line;\n    }\n\n    return new Pos(cur.line + offsetLine, cur.ch + offsetCh);\n  }\n\n  function commandMatches(keys, keyMap, context, inputState) {\n    // Partial matches are not applied. They inform the key handler\n    // that the current key sequence is a subsequence of a valid key\n    // sequence, so that the key buffer is not cleared.\n    var match,\n        partial = [],\n        full = [];\n\n    for (var i = 0; i < keyMap.length; i++) {\n      var command = keyMap[i];\n\n      if (context == \"insert\" && command.context != \"insert\" || command.context && command.context != context || inputState.operator && command.type == \"action\" || !(match = commandMatch(keys, command.keys))) {\n        continue;\n      }\n\n      if (match == \"partial\") {\n        partial.push(command);\n      }\n\n      if (match == \"full\") {\n        full.push(command);\n      }\n    }\n\n    return {\n      partial: partial.length && partial,\n      full: full.length && full\n    };\n  }\n\n  function commandMatch(pressed, mapped) {\n    if (mapped.slice(-11) == \"<character>\") {\n      // Last character matches anything.\n      var prefixLen = mapped.length - 11;\n      var pressedPrefix = pressed.slice(0, prefixLen);\n      var mappedPrefix = mapped.slice(0, prefixLen);\n      return pressedPrefix == mappedPrefix && pressed.length > prefixLen ? \"full\" : mappedPrefix.indexOf(pressedPrefix) == 0 ? \"partial\" : false;\n    } else {\n      return pressed == mapped ? \"full\" : mapped.indexOf(pressed) == 0 ? \"partial\" : false;\n    }\n  }\n\n  function lastChar(keys) {\n    var match = /^.*(<[^>]+>)$/.exec(keys);\n    var selectedCharacter = match ? match[1] : keys.slice(-1);\n\n    if (selectedCharacter.length > 1) {\n      switch (selectedCharacter) {\n        case \"<CR>\":\n          selectedCharacter = \"\\n\";\n          break;\n\n        case \"<Space>\":\n          selectedCharacter = \" \";\n          break;\n\n        default:\n          selectedCharacter = \"\";\n          break;\n      }\n    }\n\n    return selectedCharacter;\n  }\n\n  function repeatFn(cm, fn, repeat) {\n    return function () {\n      for (var i = 0; i < repeat; i++) {\n        fn(cm);\n      }\n    };\n  }\n\n  function copyCursor(cur) {\n    return new Pos(cur.line, cur.ch);\n  }\n\n  function cursorEqual(cur1, cur2) {\n    return cur1.ch == cur2.ch && cur1.line == cur2.line;\n  }\n\n  function cursorIsBefore(cur1, cur2) {\n    if (cur1.line < cur2.line) {\n      return true;\n    }\n\n    if (cur1.line == cur2.line && cur1.ch < cur2.ch) {\n      return true;\n    }\n\n    return false;\n  }\n\n  function cursorMin(cur1, cur2) {\n    if (arguments.length > 2) {\n      cur2 = cursorMin.apply(undefined, Array.prototype.slice.call(arguments, 1));\n    }\n\n    return cursorIsBefore(cur1, cur2) ? cur1 : cur2;\n  }\n\n  function cursorMax(cur1, cur2) {\n    if (arguments.length > 2) {\n      cur2 = cursorMax.apply(undefined, Array.prototype.slice.call(arguments, 1));\n    }\n\n    return cursorIsBefore(cur1, cur2) ? cur2 : cur1;\n  }\n\n  function cursorIsBetween(cur1, cur2, cur3) {\n    // returns true if cur2 is between cur1 and cur3.\n    var cur1before2 = cursorIsBefore(cur1, cur2);\n    var cur2before3 = cursorIsBefore(cur2, cur3);\n    return cur1before2 && cur2before3;\n  }\n\n  function lineLength(cm, lineNum) {\n    return cm.getLine(lineNum).length;\n  }\n\n  function trim(s) {\n    if (s.trim) {\n      return s.trim();\n    }\n\n    return s.replace(/^\\s+|\\s+$/g, \"\");\n  }\n\n  function escapeRegex(s) {\n    return s.replace(/([.?*+$\\[\\]\\/\\\\(){}|\\-])/g, \"\\\\$1\");\n  }\n\n  function extendLineToColumn(cm, lineNum, column) {\n    var endCh = lineLength(cm, lineNum);\n    var spaces = new Array(column - endCh + 1).join(\" \");\n    cm.setCursor(new Pos(lineNum, endCh));\n    cm.replaceRange(spaces, cm.getCursor());\n  } // This functions selects a rectangular block\n  // of text with selectionEnd as any of its corner\n  // Height of block:\n  // Difference in selectionEnd.line and first/last selection.line\n  // Width of the block:\n  // Distance between selectionEnd.ch and any(first considered here) selection.ch\n\n\n  function selectBlock(cm, selectionEnd) {\n    var selections = [],\n        ranges = cm.listSelections();\n    var head = copyCursor(cm.clipPos(selectionEnd));\n    var isClipped = !cursorEqual(selectionEnd, head);\n    var curHead = cm.getCursor(\"head\");\n    var primIndex = getIndex(ranges, curHead);\n    var wasClipped = cursorEqual(ranges[primIndex].head, ranges[primIndex].anchor);\n    var max = ranges.length - 1;\n    var index = max - primIndex > primIndex ? max : 0;\n    var base = ranges[index].anchor;\n    var firstLine = Math.min(base.line, head.line);\n    var lastLine = Math.max(base.line, head.line);\n    var baseCh = base.ch,\n        headCh = head.ch;\n    var dir = ranges[index].head.ch - baseCh;\n    var newDir = headCh - baseCh;\n\n    if (dir > 0 && newDir <= 0) {\n      baseCh++;\n\n      if (!isClipped) {\n        headCh--;\n      }\n    } else if (dir < 0 && newDir >= 0) {\n      baseCh--;\n\n      if (!wasClipped) {\n        headCh++;\n      }\n    } else if (dir < 0 && newDir == -1) {\n      baseCh--;\n      headCh++;\n    }\n\n    for (var line = firstLine; line <= lastLine; line++) {\n      var range = {\n        anchor: new Pos(line, baseCh),\n        head: new Pos(line, headCh)\n      };\n      selections.push(range);\n    }\n\n    cm.setSelections(selections);\n    selectionEnd.ch = headCh;\n    base.ch = baseCh;\n    return base;\n  }\n\n  function selectForInsert(cm, head, height) {\n    var sel = [];\n\n    for (var i = 0; i < height; i++) {\n      var lineHead = offsetCursor(head, i, 0);\n      sel.push({\n        anchor: lineHead,\n        head: lineHead\n      });\n    }\n\n    cm.setSelections(sel, 0);\n  } // getIndex returns the index of the cursor in the selections.\n\n\n  function getIndex(ranges, cursor, end) {\n    for (var i = 0; i < ranges.length; i++) {\n      var atAnchor = end != \"head\" && cursorEqual(ranges[i].anchor, cursor);\n      var atHead = end != \"anchor\" && cursorEqual(ranges[i].head, cursor);\n\n      if (atAnchor || atHead) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n\n  function getSelectedAreaRange(cm, vim) {\n    var lastSelection = vim.lastSelection;\n\n    var getCurrentSelectedAreaRange = function getCurrentSelectedAreaRange() {\n      var selections = cm.listSelections();\n      var start = selections[0];\n      var end = selections[selections.length - 1];\n      var selectionStart = cursorIsBefore(start.anchor, start.head) ? start.anchor : start.head;\n      var selectionEnd = cursorIsBefore(end.anchor, end.head) ? end.head : end.anchor;\n      return [selectionStart, selectionEnd];\n    };\n\n    var getLastSelectedAreaRange = function getLastSelectedAreaRange() {\n      var selectionStart = cm.getCursor();\n      var selectionEnd = cm.getCursor();\n      var block = lastSelection.visualBlock;\n\n      if (block) {\n        var width = block.width;\n        var height = block.height;\n        selectionEnd = new Pos(selectionStart.line + height, selectionStart.ch + width);\n        var selections = []; // selectBlock creates a 'proper' rectangular block.\n        // We do not want that in all cases, so we manually set selections.\n\n        for (var i = selectionStart.line; i < selectionEnd.line; i++) {\n          var anchor = new Pos(i, selectionStart.ch);\n          var head = new Pos(i, selectionEnd.ch);\n          var range = {\n            anchor: anchor,\n            head: head\n          };\n          selections.push(range);\n        }\n\n        cm.setSelections(selections);\n      } else {\n        var start = lastSelection.anchorMark.find();\n        var end = lastSelection.headMark.find();\n        var line = end.line - start.line;\n        var ch = end.ch - start.ch;\n        selectionEnd = {\n          line: selectionEnd.line + line,\n          ch: line ? selectionEnd.ch : ch + selectionEnd.ch\n        };\n\n        if (lastSelection.visualLine) {\n          selectionStart = new Pos(selectionStart.line, 0);\n          selectionEnd = new Pos(selectionEnd.line, lineLength(cm, selectionEnd.line));\n        }\n\n        cm.setSelection(selectionStart, selectionEnd);\n      }\n\n      return [selectionStart, selectionEnd];\n    };\n\n    if (!vim.visualMode) {\n      // In case of replaying the action.\n      return getLastSelectedAreaRange();\n    } else {\n      return getCurrentSelectedAreaRange();\n    }\n  } // Updates the previous selection with the current selection's values. This\n  // should only be called in visual mode.\n\n\n  function updateLastSelection(cm, vim) {\n    var anchor = vim.sel.anchor;\n    var head = vim.sel.head; // To accommodate the effect of lastPastedText in the last selection\n\n    if (vim.lastPastedText) {\n      head = cm.posFromIndex(cm.indexFromPos(anchor) + vim.lastPastedText.length);\n      vim.lastPastedText = null;\n    }\n\n    vim.lastSelection = {\n      anchorMark: cm.setBookmark(anchor),\n      headMark: cm.setBookmark(head),\n      anchor: copyCursor(anchor),\n      head: copyCursor(head),\n      visualMode: vim.visualMode,\n      visualLine: vim.visualLine,\n      visualBlock: vim.visualBlock\n    };\n  }\n\n  function expandSelection(cm, start, end) {\n    var sel = cm.state.vim.sel;\n    var head = sel.head;\n    var anchor = sel.anchor;\n    var tmp;\n\n    if (cursorIsBefore(end, start)) {\n      tmp = end;\n      end = start;\n      start = tmp;\n    }\n\n    if (cursorIsBefore(head, anchor)) {\n      head = cursorMin(start, head);\n      anchor = cursorMax(anchor, end);\n    } else {\n      anchor = cursorMin(start, anchor);\n      head = cursorMax(head, end);\n      head = offsetCursor(head, 0, -1);\n\n      if (head.ch == -1 && head.line != cm.firstLine()) {\n        head = new Pos(head.line - 1, lineLength(cm, head.line - 1));\n      }\n    }\n\n    return [anchor, head];\n  }\n  /**\n   * Updates the CodeMirror selection to match the provided vim selection.\n   * If no arguments are given, it uses the current vim selection state.\n   */\n\n\n  function updateCmSelection(cm, sel, mode) {\n    var vim = cm.state.vim;\n    sel = sel || vim.sel;\n    var mode = mode || vim.visualLine ? \"line\" : vim.visualBlock ? \"block\" : \"char\";\n    var cmSel = makeCmSelection(cm, sel, mode);\n    cm.setSelections(cmSel.ranges, cmSel.primary);\n  }\n\n  function makeCmSelection(cm, sel, mode, exclusive) {\n    var head = copyCursor(sel.head);\n    var anchor = copyCursor(sel.anchor);\n\n    if (mode == \"char\") {\n      var headOffset = !exclusive && !cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\n      var anchorOffset = cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\n      head = offsetCursor(sel.head, 0, headOffset);\n      anchor = offsetCursor(sel.anchor, 0, anchorOffset);\n      return {\n        ranges: [{\n          anchor: anchor,\n          head: head\n        }],\n        primary: 0\n      };\n    } else if (mode == \"line\") {\n      if (!cursorIsBefore(sel.head, sel.anchor)) {\n        anchor.ch = 0;\n        var lastLine = cm.lastLine();\n\n        if (head.line > lastLine) {\n          head.line = lastLine;\n        }\n\n        head.ch = lineLength(cm, head.line);\n      } else {\n        head.ch = 0;\n        anchor.ch = lineLength(cm, anchor.line);\n      }\n\n      return {\n        ranges: [{\n          anchor: anchor,\n          head: head\n        }],\n        primary: 0\n      };\n    } else if (mode == \"block\") {\n      var top = Math.min(anchor.line, head.line),\n          fromCh = anchor.ch,\n          bottom = Math.max(anchor.line, head.line),\n          toCh = head.ch;\n\n      if (fromCh < toCh) {\n        toCh += 1;\n      } else {\n        fromCh += 1;\n      }\n\n      var height = bottom - top + 1;\n      var primary = head.line == top ? 0 : height - 1;\n      var ranges = [];\n\n      for (var i = 0; i < height; i++) {\n        ranges.push({\n          anchor: new Pos(top + i, fromCh),\n          head: new Pos(top + i, toCh)\n        });\n      }\n\n      return {\n        ranges: ranges,\n        primary: primary\n      };\n    }\n  }\n\n  function getHead(cm) {\n    var cur = cm.getCursor(\"head\");\n\n    if (cm.getSelection().length == 1) {\n      // Small corner case when only 1 character is selected. The \"real\"\n      // head is the left of head and anchor.\n      cur = cursorMin(cur, cm.getCursor(\"anchor\"));\n    }\n\n    return cur;\n  }\n  /**\n   * If moveHead is set to false, the CodeMirror selection will not be\n   * touched. The caller assumes the responsibility of putting the cursor\n   * in the right place.\n   */\n\n\n  function exitVisualMode(cm, moveHead) {\n    var vim = cm.state.vim;\n\n    if (moveHead !== false) {\n      cm.setCursor(clipCursorToContent(cm, vim.sel.head));\n    }\n\n    updateLastSelection(cm, vim);\n    vim.visualMode = false;\n    vim.visualLine = false;\n    vim.visualBlock = false;\n    if (!vim.insertMode) _cm_adapter[\"default\"].signal(cm, \"vim-mode-change\", {\n      mode: \"normal\"\n    });\n  } // Remove any trailing newlines from the selection. For\n  // example, with the caret at the start of the last word on the line,\n  // 'dw' should word, but not the newline, while 'w' should advance the\n  // caret to the first character of the next line.\n\n\n  function clipToLine(cm, curStart, curEnd) {\n    var selection = cm.getRange(curStart, curEnd); // Only clip if the selection ends with trailing newline + whitespace\n\n    if (/\\n\\s*$/.test(selection)) {\n      var lines = selection.split(\"\\n\"); // We know this is all whitespace.\n\n      lines.pop(); // Cases:\n      // 1. Last word is an empty line - do not clip the trailing '\\n'\n      // 2. Last word is not an empty line - clip the trailing '\\n'\n\n      var line; // Find the line containing the last word, and clip all whitespace up\n      // to it.\n\n      for (var line = lines.pop(); lines.length > 0 && line && isWhiteSpaceString(line); line = lines.pop()) {\n        curEnd.line--;\n        curEnd.ch = 0;\n      } // If the last word is not an empty line, clip an additional newline\n\n\n      if (line) {\n        curEnd.line--;\n        curEnd.ch = lineLength(cm, curEnd.line);\n      } else {\n        curEnd.ch = 0;\n      }\n    }\n  } // Expand the selection to line ends.\n\n\n  function expandSelectionToLine(_cm, curStart, curEnd) {\n    curStart.ch = 0;\n    curEnd.ch = 0;\n    curEnd.line++;\n  }\n\n  function findFirstNonWhiteSpaceCharacter(text) {\n    if (!text) {\n      return 0;\n    }\n\n    var firstNonWS = text.search(/\\S/);\n    return firstNonWS == -1 ? text.length : firstNonWS;\n  }\n\n  function expandWordUnderCursor(cm, inclusive, _forward, bigWord, noSymbol) {\n    var cur = getHead(cm);\n    var line = cm.getLine(cur.line);\n    var idx = cur.ch; // Seek to first word or non-whitespace character, depending on if\n    // noSymbol is true.\n\n    var test = noSymbol ? wordCharTest[0] : bigWordCharTest[0];\n\n    while (!test(line.charAt(idx))) {\n      idx++;\n\n      if (idx >= line.length) {\n        return null;\n      }\n    }\n\n    if (bigWord) {\n      test = bigWordCharTest[0];\n    } else {\n      test = wordCharTest[0];\n\n      if (!test(line.charAt(idx))) {\n        test = wordCharTest[1];\n      }\n    }\n\n    var end = idx,\n        start = idx;\n\n    while (test(line.charAt(end)) && end < line.length) {\n      end++;\n    }\n\n    while (test(line.charAt(start)) && start >= 0) {\n      start--;\n    }\n\n    start++;\n\n    if (inclusive) {\n      // If present, include all whitespace after word.\n      // Otherwise, include all whitespace before word, except indentation.\n      var wordEnd = end;\n\n      while (/\\s/.test(line.charAt(end)) && end < line.length) {\n        end++;\n      }\n\n      if (wordEnd == end) {\n        var wordStart = start;\n\n        while (/\\s/.test(line.charAt(start - 1)) && start > 0) {\n          start--;\n        }\n\n        if (!start) {\n          start = wordStart;\n        }\n      }\n    }\n\n    return {\n      start: new Pos(cur.line, start),\n      end: new Pos(cur.line, end)\n    };\n  }\n  /**\n   * Depends on the following:\n   *\n   * - editor mode should be htmlmixedmode / xml\n   * - mode/xml/xml.js should be loaded\n   * - addon/fold/xml-fold.js should be loaded\n   *\n   * If any of the above requirements are not true, this function noops.\n   *\n   * This is _NOT_ a 100% accurate implementation of vim tag text objects.\n   * The following caveats apply (based off cursory testing, I'm sure there\n   * are other discrepancies):\n   *\n   * - Does not work inside comments:\n   *   ```\n   *   <!-- <div>broken</div> -->\n   *   ```\n   * - Does not work when tags have different cases:\n   *   ```\n   *   <div>broken</DIV>\n   *   ```\n   * - Does not work when cursor is inside a broken tag:\n   *   ```\n   *   <div><brok><en></div>\n   *   ```\n   */\n\n\n  function expandTagUnderCursor(cm, head, inclusive) {\n    var cur = head;\n\n    if (!_cm_adapter[\"default\"].findMatchingTag || !_cm_adapter[\"default\"].findEnclosingTag) {\n      return {\n        start: cur,\n        end: cur\n      };\n    }\n\n    var tags = _cm_adapter[\"default\"].findMatchingTag(cm, head) || _cm_adapter[\"default\"].findEnclosingTag(cm, head);\n\n    if (!tags || !tags.open || !tags.close) {\n      return {\n        start: cur,\n        end: cur\n      };\n    }\n\n    if (inclusive) {\n      return {\n        start: tags.open.from,\n        end: tags.close.to\n      };\n    }\n\n    return {\n      start: tags.open.to,\n      end: tags.close.from\n    };\n  }\n\n  function recordJumpPosition(cm, oldCur, newCur) {\n    if (!cursorEqual(oldCur, newCur)) {\n      vimGlobalState.jumpList.add(cm, oldCur, newCur);\n    }\n  }\n\n  function recordLastCharacterSearch(increment, args) {\n    vimGlobalState.lastCharacterSearch.increment = increment;\n    vimGlobalState.lastCharacterSearch.forward = args.forward;\n    vimGlobalState.lastCharacterSearch.selectedCharacter = args.selectedCharacter;\n  }\n\n  var symbolToMode = {\n    \"(\": \"bracket\",\n    \")\": \"bracket\",\n    \"{\": \"bracket\",\n    \"}\": \"bracket\",\n    \"[\": \"section\",\n    \"]\": \"section\",\n    \"*\": \"comment\",\n    \"/\": \"comment\",\n    m: \"method\",\n    M: \"method\",\n    \"#\": \"preprocess\"\n  };\n  var findSymbolModes = {\n    bracket: {\n      isComplete: function isComplete(state) {\n        if (state.nextCh === state.symb) {\n          state.depth++;\n          if (state.depth >= 1) return true;\n        } else if (state.nextCh === state.reverseSymb) {\n          state.depth--;\n        }\n\n        return false;\n      }\n    },\n    section: {\n      init: function init(state) {\n        state.curMoveThrough = true;\n        state.symb = (state.forward ? \"]\" : \"[\") === state.symb ? \"{\" : \"}\";\n      },\n      isComplete: function isComplete(state) {\n        return state.index === 0 && state.nextCh === state.symb;\n      }\n    },\n    comment: {\n      isComplete: function isComplete(state) {\n        var found = state.lastCh === \"*\" && state.nextCh === \"/\";\n        state.lastCh = state.nextCh;\n        return found;\n      }\n    },\n    // TODO: The original Vim implementation only operates on level 1 and 2.\n    // The current implementation doesn't check for code block level and\n    // therefore it operates on any levels.\n    method: {\n      init: function init(state) {\n        state.symb = state.symb === \"m\" ? \"{\" : \"}\";\n        state.reverseSymb = state.symb === \"{\" ? \"}\" : \"{\";\n      },\n      isComplete: function isComplete(state) {\n        if (state.nextCh === state.symb) return true;\n        return false;\n      }\n    },\n    preprocess: {\n      init: function init(state) {\n        state.index = 0;\n      },\n      isComplete: function isComplete(state) {\n        if (state.nextCh === \"#\") {\n          var token = state.lineText.match(/^#(\\w+)/)[1];\n\n          if (token === \"endif\") {\n            if (state.forward && state.depth === 0) {\n              return true;\n            }\n\n            state.depth++;\n          } else if (token === \"if\") {\n            if (!state.forward && state.depth === 0) {\n              return true;\n            }\n\n            state.depth--;\n          }\n\n          if (token === \"else\" && state.depth === 0) return true;\n        }\n\n        return false;\n      }\n    }\n  };\n\n  function findSymbol(cm, repeat, forward, symb) {\n    var cur = copyCursor(cm.getCursor());\n    var increment = forward ? 1 : -1;\n    var endLine = forward ? cm.lineCount() : -1;\n    var curCh = cur.ch;\n    var line = cur.line;\n    var lineText = cm.getLine(line);\n    var state = {\n      lineText: lineText,\n      nextCh: lineText.charAt(curCh),\n      lastCh: null,\n      index: curCh,\n      symb: symb,\n      reverseSymb: (forward ? {\n        \")\": \"(\",\n        \"}\": \"{\"\n      } : {\n        \"(\": \")\",\n        \"{\": \"}\"\n      })[symb],\n      forward: forward,\n      depth: 0,\n      curMoveThrough: false\n    };\n    var mode = symbolToMode[symb];\n    if (!mode) return cur;\n    var init = findSymbolModes[mode].init;\n    var isComplete = findSymbolModes[mode].isComplete;\n\n    if (init) {\n      init(state);\n    }\n\n    while (line !== endLine && repeat) {\n      state.index += increment;\n      state.nextCh = state.lineText.charAt(state.index);\n\n      if (!state.nextCh) {\n        line += increment;\n        state.lineText = cm.getLine(line) || \"\";\n\n        if (increment > 0) {\n          state.index = 0;\n        } else {\n          var lineLen = state.lineText.length;\n          state.index = lineLen > 0 ? lineLen - 1 : 0;\n        }\n\n        state.nextCh = state.lineText.charAt(state.index);\n      }\n\n      if (isComplete(state)) {\n        cur.line = line;\n        cur.ch = state.index;\n        repeat--;\n      }\n    }\n\n    if (state.nextCh || state.curMoveThrough) {\n      return new Pos(line, state.index);\n    }\n\n    return cur;\n  }\n  /*\n   * Returns the boundaries of the next word. If the cursor in the middle of\n   * the word, then returns the boundaries of the current word, starting at\n   * the cursor. If the cursor is at the start/end of a word, and we are going\n   * forward/backward, respectively, find the boundaries of the next word.\n   *\n   * @param {CodeMirror} cm CodeMirror object.\n   * @param {Cursor} cur The cursor position.\n   * @param {boolean} forward True to search forward. False to search\n   *     backward.\n   * @param {boolean} bigWord True if punctuation count as part of the word.\n   *     False if only [a-zA-Z0-9] characters count as part of the word.\n   * @param {boolean} emptyLineIsWord True if empty lines should be treated\n   *     as words.\n   * @return {Object{from:number, to:number, line: number}} The boundaries of\n   *     the word, or null if there are no more words.\n   */\n\n\n  function findWord(cm, cur, forward, bigWord, emptyLineIsWord) {\n    var lineNum = cur.line;\n    var pos = cur.ch;\n    var line = cm.getLine(lineNum);\n    var dir = forward ? 1 : -1;\n    var charTests = bigWord ? bigWordCharTest : wordCharTest;\n\n    if (emptyLineIsWord && line == \"\") {\n      lineNum += dir;\n      line = cm.getLine(lineNum);\n\n      if (!isLine(cm, lineNum)) {\n        return null;\n      }\n\n      pos = forward ? 0 : line.length;\n    }\n\n    while (true) {\n      if (emptyLineIsWord && line == \"\") {\n        return {\n          from: 0,\n          to: 0,\n          line: lineNum\n        };\n      }\n\n      var stop = dir > 0 ? line.length : -1;\n      var wordStart = stop,\n          wordEnd = stop; // Find bounds of next word.\n\n      while (pos != stop) {\n        var foundWord = false;\n\n        for (var i = 0; i < charTests.length && !foundWord; ++i) {\n          if (charTests[i](line.charAt(pos))) {\n            wordStart = pos; // Advance to end of word.\n\n            while (pos != stop && charTests[i](line.charAt(pos))) {\n              pos += dir;\n            }\n\n            wordEnd = pos;\n            foundWord = wordStart != wordEnd;\n\n            if (wordStart == cur.ch && lineNum == cur.line && wordEnd == wordStart + dir) {\n              // We started at the end of a word. Find the next one.\n              continue;\n            } else {\n              return {\n                from: Math.min(wordStart, wordEnd + 1),\n                to: Math.max(wordStart, wordEnd),\n                line: lineNum\n              };\n            }\n          }\n        }\n\n        if (!foundWord) {\n          pos += dir;\n        }\n      } // Advance to next/prev line.\n\n\n      lineNum += dir;\n\n      if (!isLine(cm, lineNum)) {\n        return null;\n      }\n\n      line = cm.getLine(lineNum);\n      pos = dir > 0 ? 0 : line.length;\n    }\n  }\n  /**\n   * @param {CodeMirror} cm CodeMirror object.\n   * @param {Pos} cur The position to start from.\n   * @param {int} repeat Number of words to move past.\n   * @param {boolean} forward True to search forward. False to search\n   *     backward.\n   * @param {boolean} wordEnd True to move to end of word. False to move to\n   *     beginning of word.\n   * @param {boolean} bigWord True if punctuation count as part of the word.\n   *     False if only alphabet characters count as part of the word.\n   * @return {Cursor} The position the cursor should move to.\n   */\n\n\n  function moveToWord(cm, cur, repeat, forward, wordEnd, bigWord) {\n    var curStart = copyCursor(cur);\n    var words = [];\n\n    if (forward && !wordEnd || !forward && wordEnd) {\n      repeat++;\n    } // For 'e', empty lines are not considered words, go figure.\n\n\n    var emptyLineIsWord = !(forward && wordEnd);\n\n    for (var i = 0; i < repeat; i++) {\n      var word = findWord(cm, cur, forward, bigWord, emptyLineIsWord);\n\n      if (!word) {\n        var eodCh = lineLength(cm, cm.lastLine());\n        words.push(forward ? {\n          line: cm.lastLine(),\n          from: eodCh,\n          to: eodCh\n        } : {\n          line: 0,\n          from: 0,\n          to: 0\n        });\n        break;\n      }\n\n      words.push(word);\n      cur = new Pos(word.line, forward ? word.to - 1 : word.from);\n    }\n\n    var shortCircuit = words.length != repeat;\n    var firstWord = words[0];\n    var lastWord = words.pop();\n\n    if (forward && !wordEnd) {\n      // w\n      if (!shortCircuit && (firstWord.from != curStart.ch || firstWord.line != curStart.line)) {\n        // We did not start in the middle of a word. Discard the extra word at the end.\n        lastWord = words.pop();\n      }\n\n      return new Pos(lastWord.line, lastWord.from);\n    } else if (forward && wordEnd) {\n      return new Pos(lastWord.line, lastWord.to - 1);\n    } else if (!forward && wordEnd) {\n      // ge\n      if (!shortCircuit && (firstWord.to != curStart.ch || firstWord.line != curStart.line)) {\n        // We did not start in the middle of a word. Discard the extra word at the end.\n        lastWord = words.pop();\n      }\n\n      return new Pos(lastWord.line, lastWord.to);\n    } else {\n      // b\n      return new Pos(lastWord.line, lastWord.from);\n    }\n  }\n\n  function _moveToEol(cm, head, motionArgs, vim, keepHPos) {\n    var cur = head;\n    var retval = new Pos(cur.line + motionArgs.repeat - 1, Infinity);\n    var end = cm.clipPos(retval);\n    end.ch--;\n\n    if (!keepHPos) {\n      vim.lastHPos = Infinity;\n      vim.lastHSPos = cm.charCoords(end, \"div\").left;\n    }\n\n    return retval;\n  }\n\n  function _moveToCharacter(cm, repeat, forward, character) {\n    var cur = cm.getCursor();\n    var start = cur.ch;\n    var idx;\n\n    for (var i = 0; i < repeat; i++) {\n      var line = cm.getLine(cur.line);\n      idx = charIdxInLine(start, line, character, forward, true);\n\n      if (idx == -1) {\n        return null;\n      }\n\n      start = idx;\n    }\n\n    return new Pos(cm.getCursor().line, idx);\n  }\n\n  function _moveToColumn(cm, repeat) {\n    // repeat is always >= 1, so repeat - 1 always corresponds\n    // to the column we want to go to.\n    var line = cm.getCursor().line;\n    return clipCursorToContent(cm, new Pos(line, repeat - 1));\n  }\n\n  function updateMark(cm, vim, markName, pos) {\n    if (!inArray(markName, validMarks)) {\n      return;\n    }\n\n    if (vim.marks[markName]) {\n      vim.marks[markName].clear();\n    }\n\n    vim.marks[markName] = cm.setBookmark(pos);\n  }\n\n  function charIdxInLine(start, line, character, forward, includeChar) {\n    // Search for char in line.\n    // motion_options: {forward, includeChar}\n    // If includeChar = true, include it too.\n    // If forward = true, search forward, else search backwards.\n    // If char is not found on this line, do nothing\n    var idx;\n\n    if (forward) {\n      idx = line.indexOf(character, start + 1);\n\n      if (idx != -1 && !includeChar) {\n        idx -= 1;\n      }\n    } else {\n      idx = line.lastIndexOf(character, start - 1);\n\n      if (idx != -1 && !includeChar) {\n        idx += 1;\n      }\n    }\n\n    return idx;\n  }\n\n  function findParagraph(cm, head, repeat, dir, inclusive) {\n    var line = head.line;\n    var min = cm.firstLine();\n    var max = cm.lastLine();\n    var start,\n        end,\n        i = line;\n\n    function isEmpty(i) {\n      return !cm.getLine(i);\n    }\n\n    function isBoundary(i, dir, any) {\n      if (any) {\n        return isEmpty(i) != isEmpty(i + dir);\n      }\n\n      return !isEmpty(i) && isEmpty(i + dir);\n    }\n\n    if (dir) {\n      while (min <= i && i <= max && repeat > 0) {\n        if (isBoundary(i, dir)) {\n          repeat--;\n        }\n\n        i += dir;\n      }\n\n      return new Pos(i, 0);\n    }\n\n    var vim = cm.state.vim;\n\n    if (vim.visualLine && isBoundary(line, 1, true)) {\n      var anchor = vim.sel.anchor;\n\n      if (isBoundary(anchor.line, -1, true)) {\n        if (!inclusive || anchor.line != line) {\n          line += 1;\n        }\n      }\n    }\n\n    var startState = isEmpty(line);\n\n    for (i = line; i <= max && repeat; i++) {\n      if (isBoundary(i, 1, true)) {\n        if (!inclusive || isEmpty(i) != startState) {\n          repeat--;\n        }\n      }\n    }\n\n    end = new Pos(i, 0); // select boundary before paragraph for the last one\n\n    if (i > max && !startState) {\n      startState = true;\n    } else {\n      inclusive = false;\n    }\n\n    for (i = line; i > min; i--) {\n      if (!inclusive || isEmpty(i) == startState || i == line) {\n        if (isBoundary(i, -1, true)) {\n          break;\n        }\n      }\n    }\n\n    start = new Pos(i, 0);\n    return {\n      start: start,\n      end: end\n    };\n  }\n\n  function findSentence(cm, cur, repeat, dir) {\n    /*\n        Takes an index object\n        {\n          line: the line string,\n          ln: line number,\n          pos: index in line,\n          dir: direction of traversal (-1 or 1)\n        }\n        and modifies the line, ln, and pos members to represent the\n        next valid position or sets them to null if there are\n        no more valid positions.\n       */\n    function nextChar(cm, idx) {\n      if (idx.pos + idx.dir < 0 || idx.pos + idx.dir >= idx.line.length) {\n        idx.ln += idx.dir;\n\n        if (!isLine(cm, idx.ln)) {\n          idx.line = null;\n          idx.ln = null;\n          idx.pos = null;\n          return;\n        }\n\n        idx.line = cm.getLine(idx.ln);\n        idx.pos = idx.dir > 0 ? 0 : idx.line.length - 1;\n      } else {\n        idx.pos += idx.dir;\n      }\n    }\n    /*\n        Performs one iteration of traversal in forward direction\n        Returns an index object of the new location\n       */\n\n\n    function forward(cm, ln, pos, dir) {\n      var line = cm.getLine(ln);\n      var stop = line === \"\";\n      var curr = {\n        line: line,\n        ln: ln,\n        pos: pos,\n        dir: dir\n      };\n      var last_valid = {\n        ln: curr.ln,\n        pos: curr.pos\n      };\n      var skip_empty_lines = curr.line === \"\"; // Move one step to skip character we start on\n\n      nextChar(cm, curr);\n\n      while (curr.line !== null) {\n        last_valid.ln = curr.ln;\n        last_valid.pos = curr.pos;\n\n        if (curr.line === \"\" && !skip_empty_lines) {\n          return {\n            ln: curr.ln,\n            pos: curr.pos\n          };\n        } else if (stop && curr.line !== \"\" && !isWhiteSpaceString(curr.line[curr.pos])) {\n          return {\n            ln: curr.ln,\n            pos: curr.pos\n          };\n        } else if (isEndOfSentenceSymbol(curr.line[curr.pos]) && !stop && (curr.pos === curr.line.length - 1 || isWhiteSpaceString(curr.line[curr.pos + 1]))) {\n          stop = true;\n        }\n\n        nextChar(cm, curr);\n      }\n      /*\n          Set the position to the last non whitespace character on the last\n          valid line in the case that we reach the end of the document.\n        */\n\n\n      var line = cm.getLine(last_valid.ln);\n      last_valid.pos = 0;\n\n      for (var i = line.length - 1; i >= 0; --i) {\n        if (!isWhiteSpaceString(line[i])) {\n          last_valid.pos = i;\n          break;\n        }\n      }\n\n      return last_valid;\n    }\n    /*\n        Performs one iteration of traversal in reverse direction\n        Returns an index object of the new location\n       */\n\n\n    function reverse(cm, ln, pos, dir) {\n      var line = cm.getLine(ln);\n      var curr = {\n        line: line,\n        ln: ln,\n        pos: pos,\n        dir: dir\n      };\n      var last_valid = {\n        ln: curr.ln,\n        pos: null\n      };\n      var skip_empty_lines = curr.line === \"\"; // Move one step to skip character we start on\n\n      nextChar(cm, curr);\n\n      while (curr.line !== null) {\n        if (curr.line === \"\" && !skip_empty_lines) {\n          if (last_valid.pos !== null) {\n            return last_valid;\n          } else {\n            return {\n              ln: curr.ln,\n              pos: curr.pos\n            };\n          }\n        } else if (isEndOfSentenceSymbol(curr.line[curr.pos]) && last_valid.pos !== null && !(curr.ln === last_valid.ln && curr.pos + 1 === last_valid.pos)) {\n          return last_valid;\n        } else if (curr.line !== \"\" && !isWhiteSpaceString(curr.line[curr.pos])) {\n          skip_empty_lines = false;\n          last_valid = {\n            ln: curr.ln,\n            pos: curr.pos\n          };\n        }\n\n        nextChar(cm, curr);\n      }\n      /*\n          Set the position to the first non whitespace character on the last\n          valid line in the case that we reach the beginning of the document.\n        */\n\n\n      var line = cm.getLine(last_valid.ln);\n      last_valid.pos = 0;\n\n      for (var i = 0; i < line.length; ++i) {\n        if (!isWhiteSpaceString(line[i])) {\n          last_valid.pos = i;\n          break;\n        }\n      }\n\n      return last_valid;\n    }\n\n    var curr_index = {\n      ln: cur.line,\n      pos: cur.ch\n    };\n\n    while (repeat > 0) {\n      if (dir < 0) {\n        curr_index = reverse(cm, curr_index.ln, curr_index.pos, dir);\n      } else {\n        curr_index = forward(cm, curr_index.ln, curr_index.pos, dir);\n      }\n\n      repeat--;\n    }\n\n    return new Pos(curr_index.ln, curr_index.pos);\n  } // TODO: perhaps this finagling of start and end positions belongs\n  // in codemirror/replaceRange?\n\n\n  function selectCompanionObject(cm, head, symb, inclusive) {\n    var cur = head,\n        start,\n        end;\n    var bracketRegexp = {\n      \"(\": /[()]/,\n      \")\": /[()]/,\n      \"[\": /[[\\]]/,\n      \"]\": /[[\\]]/,\n      \"{\": /[{}]/,\n      \"}\": /[{}]/,\n      \"<\": /[<>]/,\n      \">\": /[<>]/\n    }[symb];\n    var openSym = {\n      \"(\": \"(\",\n      \")\": \"(\",\n      \"[\": \"[\",\n      \"]\": \"[\",\n      \"{\": \"{\",\n      \"}\": \"{\",\n      \"<\": \"<\",\n      \">\": \"<\"\n    }[symb];\n    var curChar = cm.getLine(cur.line).charAt(cur.ch); // Due to the behavior of scanForBracket, we need to add an offset if the\n    // cursor is on a matching open bracket.\n\n    var offset = curChar === openSym ? 1 : 0;\n    start = cm.scanForBracket(new Pos(cur.line, cur.ch + offset), -1, undefined, {\n      bracketRegex: bracketRegexp\n    });\n    end = cm.scanForBracket(new Pos(cur.line, cur.ch + offset), 1, undefined, {\n      bracketRegex: bracketRegexp\n    });\n\n    if (!start || !end) {\n      return {\n        start: cur,\n        end: cur\n      };\n    }\n\n    start = start.pos;\n    end = end.pos;\n\n    if (start.line == end.line && start.ch > end.ch || start.line > end.line) {\n      var tmp = start;\n      start = end;\n      end = tmp;\n    }\n\n    if (inclusive) {\n      end.ch += 1;\n    } else {\n      start.ch += 1;\n    }\n\n    return {\n      start: start,\n      end: end\n    };\n  } // Takes in a symbol and a cursor and tries to simulate text objects that\n  // have identical opening and closing symbols\n  // TODO support across multiple lines\n\n\n  function findBeginningAndEnd(cm, head, symb, inclusive) {\n    var cur = copyCursor(head);\n    var line = cm.getLine(cur.line);\n    var chars = line.split(\"\");\n    var start, end, i, len;\n    var firstIndex = chars.indexOf(symb); // the decision tree is to always look backwards for the beginning first,\n    // but if the cursor is in front of the first instance of the symb,\n    // then move the cursor forward\n\n    if (cur.ch < firstIndex) {\n      cur.ch = firstIndex; // Why is this line even here???\n      // cm.setCursor(cur.line, firstIndex+1);\n    } // otherwise if the cursor is currently on the closing symbol\n    else if (firstIndex < cur.ch && chars[cur.ch] == symb) {\n      end = cur.ch; // assign end to the current cursor\n\n      --cur.ch; // make sure to look backwards\n    } // if we're currently on the symbol, we've got a start\n\n\n    if (chars[cur.ch] == symb && !end) {\n      start = cur.ch + 1; // assign start to ahead of the cursor\n    } else {\n      // go backwards to find the start\n      for (i = cur.ch; i > -1 && !start; i--) {\n        if (chars[i] == symb) {\n          start = i + 1;\n        }\n      }\n    } // look forwards for the end symbol\n\n\n    if (start && !end) {\n      for (i = start, len = chars.length; i < len && !end; i++) {\n        if (chars[i] == symb) {\n          end = i;\n        }\n      }\n    } // nothing found\n\n\n    if (!start || !end) {\n      return {\n        start: cur,\n        end: cur\n      };\n    } // include the symbols\n\n\n    if (inclusive) {\n      --start;\n      ++end;\n    }\n\n    return {\n      start: new Pos(cur.line, start),\n      end: new Pos(cur.line, end)\n    };\n  } // Search functions\n\n\n  defineOption(\"pcre\", true, \"boolean\");\n\n  function SearchState() {}\n\n  SearchState.prototype = {\n    getQuery: function getQuery() {\n      return vimGlobalState.query;\n    },\n    setQuery: function setQuery(query) {\n      vimGlobalState.query = query;\n    },\n    getOverlay: function getOverlay() {\n      return this.searchOverlay;\n    },\n    setOverlay: function setOverlay(overlay) {\n      this.searchOverlay = overlay;\n    },\n    isReversed: function isReversed() {\n      return vimGlobalState.isReversed;\n    },\n    setReversed: function setReversed(reversed) {\n      vimGlobalState.isReversed = reversed;\n    },\n    getScrollbarAnnotate: function getScrollbarAnnotate() {\n      return this.annotate;\n    },\n    setScrollbarAnnotate: function setScrollbarAnnotate(annotate) {\n      this.annotate = annotate;\n    }\n  };\n\n  function getSearchState(cm) {\n    var vim = cm.state.vim;\n    return vim.searchState_ || (vim.searchState_ = new SearchState());\n  }\n\n  function splitBySlash(argString) {\n    return splitBySeparator(argString, \"/\");\n  }\n\n  function findUnescapedSlashes(argString) {\n    return findUnescapedSeparators(argString, \"/\");\n  }\n\n  function splitBySeparator(argString, separator) {\n    var slashes = findUnescapedSeparators(argString, separator) || [];\n    if (!slashes.length) return [];\n    var tokens = []; // in case of strings like foo/bar\n\n    if (slashes[0] !== 0) return;\n\n    for (var i = 0; i < slashes.length; i++) {\n      if (typeof slashes[i] == \"number\") tokens.push(argString.substring(slashes[i] + 1, slashes[i + 1]));\n    }\n\n    return tokens;\n  }\n\n  function findUnescapedSeparators(str, separator) {\n    if (!separator) separator = \"/\";\n    var escapeNextChar = false;\n    var slashes = [];\n\n    for (var i = 0; i < str.length; i++) {\n      var c = str.charAt(i);\n\n      if (!escapeNextChar && c == separator) {\n        slashes.push(i);\n      }\n\n      escapeNextChar = !escapeNextChar && c == \"\\\\\";\n    }\n\n    return slashes;\n  } // Translates a search string from ex (vim) syntax into javascript form.\n\n\n  function translateRegex(str) {\n    // When these match, add a '\\' if unescaped or remove one if escaped.\n    var specials = \"|(){\"; // Remove, but never add, a '\\' for these.\n\n    var unescape = \"}\";\n    var escapeNextChar = false;\n    var out = [];\n\n    for (var i = -1; i < str.length; i++) {\n      var c = str.charAt(i) || \"\";\n      var n = str.charAt(i + 1) || \"\";\n      var specialComesNext = n && specials.indexOf(n) != -1;\n\n      if (escapeNextChar) {\n        if (c !== \"\\\\\" || !specialComesNext) {\n          out.push(c);\n        }\n\n        escapeNextChar = false;\n      } else {\n        if (c === \"\\\\\") {\n          escapeNextChar = true; // Treat the unescape list as special for removing, but not adding '\\'.\n\n          if (n && unescape.indexOf(n) != -1) {\n            specialComesNext = true;\n          } // Not passing this test means removing a '\\'.\n\n\n          if (!specialComesNext || n === \"\\\\\") {\n            out.push(c);\n          }\n        } else {\n          out.push(c);\n\n          if (specialComesNext && n !== \"\\\\\") {\n            out.push(\"\\\\\");\n          }\n        }\n      }\n    }\n\n    return out.join(\"\");\n  } // Translates the replace part of a search and replace from ex (vim) syntax into\n  // javascript form.  Similar to translateRegex, but additionally fixes back references\n  // (translates '\\[0..9]' to '$[0..9]') and follows different rules for escaping '$'.\n\n\n  var charUnescapes = {\n    \"\\\\n\": \"\\n\",\n    \"\\\\r\": \"\\r\",\n    \"\\\\t\": \"\\t\"\n  };\n\n  function translateRegexReplace(str) {\n    var escapeNextChar = false;\n    var out = [];\n\n    for (var i = -1; i < str.length; i++) {\n      var c = str.charAt(i) || \"\";\n      var n = str.charAt(i + 1) || \"\";\n\n      if (charUnescapes[c + n]) {\n        out.push(charUnescapes[c + n]);\n        i++;\n      } else if (escapeNextChar) {\n        // At any point in the loop, escapeNextChar is true if the previous\n        // character was a '\\' and was not escaped.\n        out.push(c);\n        escapeNextChar = false;\n      } else {\n        if (c === \"\\\\\") {\n          escapeNextChar = true;\n\n          if (isNumber(n) || n === \"$\") {\n            out.push(\"$\");\n          } else if (n !== \"/\" && n !== \"\\\\\") {\n            out.push(\"\\\\\");\n          }\n        } else {\n          if (c === \"$\") {\n            out.push(\"$\");\n          }\n\n          out.push(c);\n\n          if (n === \"/\") {\n            out.push(\"\\\\\");\n          }\n        }\n      }\n    }\n\n    return out.join(\"\");\n  } // Unescape \\ and / in the replace part, for PCRE mode.\n\n\n  var unescapes = {\n    \"\\\\/\": \"/\",\n    \"\\\\\\\\\": \"\\\\\",\n    \"\\\\n\": \"\\n\",\n    \"\\\\r\": \"\\r\",\n    \"\\\\t\": \"\\t\",\n    \"\\\\&\": \"&\"\n  };\n\n  function unescapeRegexReplace(str) {\n    var stream = new _cm_adapter[\"default\"].StringStream(str);\n    var output = [];\n\n    while (!stream.eol()) {\n      // Search for \\.\n      while (stream.peek() && stream.peek() != \"\\\\\") {\n        output.push(stream.next());\n      }\n\n      var matched = false;\n\n      for (var matcher in unescapes) {\n        if (stream.match(matcher, true)) {\n          matched = true;\n          output.push(unescapes[matcher]);\n          break;\n        }\n      }\n\n      if (!matched) {\n        // Don't change anything\n        output.push(stream.next());\n      }\n    }\n\n    return output.join(\"\");\n  }\n  /**\n   * Extract the regular expression from the query and return a Regexp object.\n   * Returns null if the query is blank.\n   * If ignoreCase is passed in, the Regexp object will have the 'i' flag set.\n   * If smartCase is passed in, and the query contains upper case letters,\n   *   then ignoreCase is overridden, and the 'i' flag will not be set.\n   * If the query contains the /i in the flag part of the regular expression,\n   *   then both ignoreCase and smartCase are ignored, and 'i' will be passed\n   *   through to the Regex object.\n   */\n\n\n  function parseQuery(query, ignoreCase, smartCase) {\n    // First update the last search register\n    var lastSearchRegister = vimGlobalState.registerController.getRegister(\"/\");\n    lastSearchRegister.setText(query); // Check if the query is already a regex.\n\n    if (query instanceof RegExp) {\n      return query;\n    } // First try to extract regex + flags from the input. If no flags found,\n    // extract just the regex. IE does not accept flags directly defined in\n    // the regex string in the form /regex/flags\n\n\n    var slashes = findUnescapedSlashes(query);\n    var regexPart;\n    var forceIgnoreCase;\n\n    if (!slashes.length) {\n      // Query looks like 'regexp'\n      regexPart = query;\n    } else {\n      // Query looks like 'regexp/...'\n      regexPart = query.substring(0, slashes[0]);\n      var flagsPart = query.substring(slashes[0]);\n      forceIgnoreCase = flagsPart.indexOf(\"i\") != -1;\n    }\n\n    if (!regexPart) {\n      return null;\n    }\n\n    if (!getOption(\"pcre\")) {\n      regexPart = translateRegex(regexPart);\n    }\n\n    if (smartCase) {\n      ignoreCase = /^[^A-Z]*$/.test(regexPart);\n    }\n\n    var regexp = new RegExp(regexPart, ignoreCase || forceIgnoreCase ? \"im\" : \"m\");\n    return regexp;\n  }\n  /**\n   * dom - Document Object Manipulator\n   * Usage:\n   *   dom('<tag>'|<node>[, ...{<attributes>|<$styles>}|<child-node>|'<text>'])\n   * Examples:\n   *   dom('div', {id:'xyz'}, dom('p', 'CM rocks!', {$color:'red'}))\n   *   dom(document.head, dom('script', 'alert(\"hello!\")'))\n   * Not supported:\n   *   dom('p', ['arrays are objects'], Error('objects specify attributes'))\n   */\n\n\n  function dom(n) {\n    if (typeof n === \"string\") n = document.createElement(n);\n\n    for (var a, i = 1; i < arguments.length; i++) {\n      if (!(a = arguments[i])) continue;\n      if (_typeof(a) !== \"object\") a = document.createTextNode(a);\n      if (a.nodeType) n.appendChild(a);else for (var key in a) {\n        if (!Object.prototype.hasOwnProperty.call(a, key)) continue;\n        if (key[0] === \"$\") n.style[key.slice(1)] = a[key];else n.setAttribute(key, a[key]);\n      }\n    }\n\n    return n;\n  }\n\n  function showConfirm(cm, template) {\n    var pre = dom(\"pre\", {\n      $color: \"red\",\n      \"class\": \"cm-vim-message\"\n    }, template);\n\n    if (cm.openNotification) {\n      cm.openNotification(pre, {\n        bottom: true,\n        duration: 5000\n      });\n    } else {\n      alert(pre.innerText);\n    }\n  }\n\n  function makePrompt(prefix, desc) {\n    return dom(document.createDocumentFragment(), dom(\"span\", {\n      $fontFamily: \"monospace\",\n      $whiteSpace: \"pre\"\n    }, prefix, dom(\"input\", {\n      type: \"text\",\n      autocorrect: \"off\",\n      autocapitalize: \"off\",\n      spellcheck: \"false\"\n    })), desc && dom(\"span\", {\n      $color: \"#888\"\n    }, desc));\n  }\n\n  function showPrompt(cm, options) {\n    var template = makePrompt(options.prefix, options.desc);\n\n    if (cm.openDialog) {\n      cm.openDialog(template, options.onClose, {\n        onKeyDown: options.onKeyDown,\n        onKeyUp: options.onKeyUp,\n        bottom: true,\n        selectValueOnOpen: false,\n        value: options.value\n      });\n    } else {\n      var shortText = \"\";\n      if (typeof options.prefix != \"string\" && options.prefix) shortText += options.prefix.textContent;\n      if (options.desc) shortText += \" \" + options.desc;\n      options.onClose(prompt(shortText, \"\"));\n    }\n  }\n\n  function regexEqual(r1, r2) {\n    if (r1 instanceof RegExp && r2 instanceof RegExp) {\n      var props = [\"global\", \"multiline\", \"ignoreCase\", \"source\"];\n\n      for (var i = 0; i < props.length; i++) {\n        var prop = props[i];\n\n        if (r1[prop] !== r2[prop]) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    return false;\n  } // Returns true if the query is valid.\n\n\n  function updateSearchQuery(cm, rawQuery, ignoreCase, smartCase) {\n    if (!rawQuery) {\n      return;\n    }\n\n    var state = getSearchState(cm);\n    var query = parseQuery(rawQuery, !!ignoreCase, !!smartCase);\n\n    if (!query) {\n      return;\n    }\n\n    highlightSearchMatches(cm, query);\n\n    if (regexEqual(query, state.getQuery())) {\n      return query;\n    }\n\n    state.setQuery(query);\n    return query;\n  }\n\n  function searchOverlay(query) {\n    if (query.source.charAt(0) == \"^\") {\n      var matchSol = true;\n    }\n\n    return {\n      token: function token(stream) {\n        if (matchSol && !stream.sol()) {\n          stream.skipToEnd();\n          return;\n        }\n\n        var match = stream.match(query, false);\n\n        if (match) {\n          if (match[0].length == 0) {\n            // Matched empty string, skip to next.\n            stream.next();\n            return \"searching\";\n          }\n\n          if (!stream.sol()) {\n            // Backtrack 1 to match \\b\n            stream.backUp(1);\n\n            if (!query.exec(stream.next() + match[0])) {\n              stream.next();\n              return null;\n            }\n          }\n\n          stream.match(query);\n          return \"searching\";\n        }\n\n        while (!stream.eol()) {\n          stream.next();\n          if (stream.match(query, false)) break;\n        }\n      },\n      query: query\n    };\n  }\n\n  var highlightTimeout = 0;\n\n  function highlightSearchMatches(cm, query) {\n    clearTimeout(highlightTimeout);\n    highlightTimeout = setTimeout(function () {\n      if (!cm.state.vim) return;\n      var searchState = getSearchState(cm);\n      var overlay = searchState.getOverlay();\n\n      if (!overlay || query != overlay.query) {\n        if (overlay) {\n          cm.removeOverlay(overlay);\n        }\n\n        overlay = searchOverlay(query);\n        cm.addOverlay(overlay);\n\n        if (cm.showMatchesOnScrollbar) {\n          if (searchState.getScrollbarAnnotate()) {\n            searchState.getScrollbarAnnotate().clear();\n          }\n\n          searchState.setScrollbarAnnotate(cm.showMatchesOnScrollbar(query));\n        }\n\n        searchState.setOverlay(overlay);\n      }\n    }, 50);\n  }\n\n  function _findNext(cm, prev, query, repeat) {\n    if (repeat === undefined) {\n      repeat = 1;\n    }\n\n    return cm.operation(function () {\n      var pos = cm.getCursor();\n      var cursor = cm.getSearchCursor(query, pos);\n\n      for (var i = 0; i < repeat; i++) {\n        var found = cursor.find(prev);\n\n        if (i == 0 && found && cursorEqual(cursor.from(), pos)) {\n          var lastEndPos = prev ? cursor.from() : cursor.to();\n          found = cursor.find(prev);\n\n          if (found && !found[0] && cursorEqual(cursor.from(), lastEndPos)) {\n            if (cm.getLine(lastEndPos.line).length == lastEndPos.ch) found = cursor.find(prev);\n          }\n        }\n\n        if (!found) {\n          // SearchCursor may have returned null because it hit EOF, wrap\n          // around and try again.\n          cursor = cm.getSearchCursor(query, prev ? new Pos(cm.lastLine()) : new Pos(cm.firstLine(), 0));\n\n          if (!cursor.find(prev)) {\n            return;\n          }\n        }\n      }\n\n      return cursor.from();\n    });\n  }\n  /**\n   * Pretty much the same as `findNext`, except for the following differences:\n   *\n   * 1. Before starting the search, move to the previous search. This way if our cursor is\n   * already inside a match, we should return the current match.\n   * 2. Rather than only returning the cursor's from, we return the cursor's from and to as a tuple.\n   */\n\n\n  function findNextFromAndToInclusive(cm, prev, query, repeat, vim) {\n    if (repeat === undefined) {\n      repeat = 1;\n    }\n\n    return cm.operation(function () {\n      var pos = cm.getCursor();\n      var cursor = cm.getSearchCursor(query, pos); // Go back one result to ensure that if the cursor is currently a match, we keep it.\n\n      var found = cursor.find(!prev); // If we haven't moved, go back one more (similar to if i==0 logic in findNext).\n\n      if (!vim.visualMode && found && cursorEqual(cursor.from(), pos)) {\n        cursor.find(!prev);\n      }\n\n      for (var i = 0; i < repeat; i++) {\n        found = cursor.find(prev);\n\n        if (!found) {\n          // SearchCursor may have returned null because it hit EOF, wrap\n          // around and try again.\n          cursor = cm.getSearchCursor(query, prev ? new Pos(cm.lastLine()) : new Pos(cm.firstLine(), 0));\n\n          if (!cursor.find(prev)) {\n            return;\n          }\n        }\n      }\n\n      return [cursor.from(), cursor.to()];\n    });\n  }\n\n  function clearSearchHighlight(cm) {\n    var state = getSearchState(cm);\n    cm.removeOverlay(getSearchState(cm).getOverlay());\n    state.setOverlay(null);\n\n    if (state.getScrollbarAnnotate()) {\n      state.getScrollbarAnnotate().clear();\n      state.setScrollbarAnnotate(null);\n    }\n  }\n  /**\n   * Check if pos is in the specified range, INCLUSIVE.\n   * Range can be specified with 1 or 2 arguments.\n   * If the first range argument is an array, treat it as an array of line\n   * numbers. Match pos against any of the lines.\n   * If the first range argument is a number,\n   *   if there is only 1 range argument, check if pos has the same line\n   *       number\n   *   if there are 2 range arguments, then check if pos is in between the two\n   *       range arguments.\n   */\n\n\n  function isInRange(pos, start, end) {\n    if (typeof pos != \"number\") {\n      // Assume it is a cursor position. Get the line number.\n      pos = pos.line;\n    }\n\n    if (start instanceof Array) {\n      return inArray(pos, start);\n    } else {\n      if (typeof end == \"number\") {\n        return pos >= start && pos <= end;\n      } else {\n        return pos == start;\n      }\n    }\n  }\n\n  function getUserVisibleLines(cm) {\n    var scrollInfo = cm.getScrollInfo();\n    var occludeToleranceTop = 6;\n    var occludeToleranceBottom = 10;\n    var from = cm.coordsChar({\n      left: 0,\n      top: occludeToleranceTop + scrollInfo.top\n    }, \"local\");\n    var bottomY = scrollInfo.clientHeight - occludeToleranceBottom + scrollInfo.top;\n    var to = cm.coordsChar({\n      left: 0,\n      top: bottomY\n    }, \"local\");\n    return {\n      top: from.line,\n      bottom: to.line\n    };\n  }\n\n  function getMarkPos(cm, vim, markName) {\n    if (markName == \"'\" || markName == \"`\") {\n      return vimGlobalState.jumpList.find(cm, -1) || new Pos(0, 0);\n    } else if (markName == \".\") {\n      return getLastEditPos(cm);\n    }\n\n    var mark = vim.marks[markName];\n    return mark && mark.find();\n  }\n\n  function getLastEditPos(cm) {\n    var done = cm.doc.history.done;\n\n    for (var i = done.length; i--;) {\n      if (done[i].changes) {\n        return copyCursor(done[i].changes[0].to);\n      }\n    }\n  }\n\n  var ExCommandDispatcher = function ExCommandDispatcher() {\n    this.buildCommandMap_();\n  };\n\n  ExCommandDispatcher.prototype = {\n    processCommand: function processCommand(cm, input, opt_params) {\n      var that = this;\n      cm.operation(function () {\n        cm.curOp.isVimOp = true;\n\n        that._processCommand(cm, input, opt_params);\n      });\n    },\n    _processCommand: function _processCommand(cm, input, opt_params) {\n      var vim = cm.state.vim;\n      var commandHistoryRegister = vimGlobalState.registerController.getRegister(\":\");\n      var previousCommand = commandHistoryRegister.toString();\n\n      if (vim.visualMode) {\n        exitVisualMode(cm);\n      }\n\n      var inputStream = new _cm_adapter[\"default\"].StringStream(input); // update \": with the latest command whether valid or invalid\n\n      commandHistoryRegister.setText(input);\n      var params = opt_params || {};\n      params.input = input;\n\n      try {\n        this.parseInput_(cm, inputStream, params);\n      } catch (e) {\n        showConfirm(cm, e.toString());\n        throw e;\n      }\n\n      var command;\n      var commandName;\n\n      if (!params.commandName) {\n        // If only a line range is defined, move to the line.\n        if (params.line !== undefined) {\n          commandName = \"move\";\n        }\n      } else {\n        command = this.matchCommand_(params.commandName);\n\n        if (command) {\n          commandName = command.name;\n\n          if (command.excludeFromCommandHistory) {\n            commandHistoryRegister.setText(previousCommand);\n          }\n\n          this.parseCommandArgs_(inputStream, params, command);\n\n          if (command.type == \"exToKey\") {\n            // Handle Ex to Key mapping.\n            for (var i = 0; i < command.toKeys.length; i++) {\n              vimApi.handleKey(cm, command.toKeys[i], \"mapping\");\n            }\n\n            return;\n          } else if (command.type == \"exToEx\") {\n            // Handle Ex to Ex mapping.\n            this.processCommand(cm, command.toInput);\n            return;\n          }\n        }\n      }\n\n      if (!commandName) {\n        showConfirm(cm, 'Not an editor command \":' + input + '\"');\n        return;\n      }\n\n      try {\n        exCommands[commandName](cm, params); // Possibly asynchronous commands (e.g. substitute, which might have a\n        // user confirmation), are responsible for calling the callback when\n        // done. All others have it taken care of for them here.\n\n        if ((!command || !command.possiblyAsync) && params.callback) {\n          params.callback();\n        }\n      } catch (e) {\n        showConfirm(cm, e.toString());\n        throw e;\n      }\n    },\n    parseInput_: function parseInput_(cm, inputStream, result) {\n      inputStream.eatWhile(\":\"); // Parse range.\n\n      if (inputStream.eat(\"%\")) {\n        result.line = cm.firstLine();\n        result.lineEnd = cm.lastLine();\n      } else {\n        result.line = this.parseLineSpec_(cm, inputStream);\n\n        if (result.line !== undefined && inputStream.eat(\",\")) {\n          result.lineEnd = this.parseLineSpec_(cm, inputStream);\n        }\n      } // Parse command name.\n\n\n      var commandMatch = inputStream.match(/^(\\w+|!!|@@|[!#&*<=>@~])/);\n\n      if (commandMatch) {\n        result.commandName = commandMatch[1];\n      } else {\n        result.commandName = inputStream.match(/.*/)[0];\n      }\n\n      return result;\n    },\n    parseLineSpec_: function parseLineSpec_(cm, inputStream) {\n      var numberMatch = inputStream.match(/^(\\d+)/);\n\n      if (numberMatch) {\n        // Absolute line number plus offset (N+M or N-M) is probably a typo,\n        // not something the user actually wanted. (NB: vim does allow this.)\n        return parseInt(numberMatch[1], 10) - 1;\n      }\n\n      switch (inputStream.next()) {\n        case \".\":\n          return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);\n\n        case \"$\":\n          return this.parseLineSpecOffset_(inputStream, cm.lastLine());\n\n        case \"'\":\n          var markName = inputStream.next();\n          var markPos = getMarkPos(cm, cm.state.vim, markName);\n          if (!markPos) throw new Error(\"Mark not set\");\n          return this.parseLineSpecOffset_(inputStream, markPos.line);\n\n        case \"-\":\n        case \"+\":\n          inputStream.backUp(1); // Offset is relative to current line if not otherwise specified.\n\n          return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);\n\n        default:\n          inputStream.backUp(1);\n          return undefined;\n      }\n    },\n    parseLineSpecOffset_: function parseLineSpecOffset_(inputStream, line) {\n      var offsetMatch = inputStream.match(/^([+-])?(\\d+)/);\n\n      if (offsetMatch) {\n        var offset = parseInt(offsetMatch[2], 10);\n\n        if (offsetMatch[1] == \"-\") {\n          line -= offset;\n        } else {\n          line += offset;\n        }\n      }\n\n      return line;\n    },\n    parseCommandArgs_: function parseCommandArgs_(inputStream, params, command) {\n      if (inputStream.eol()) {\n        return;\n      }\n\n      params.argString = inputStream.match(/.*/)[0]; // Parse command-line arguments\n\n      var delim = command.argDelimiter || /\\s+/;\n      var args = trim(params.argString).split(delim);\n\n      if (args.length && args[0]) {\n        params.args = args;\n      }\n    },\n    matchCommand_: function matchCommand_(commandName) {\n      // Return the command in the command map that matches the shortest\n      // prefix of the passed in command name. The match is guaranteed to be\n      // unambiguous if the defaultExCommandMap's shortNames are set up\n      // correctly. (see @code{defaultExCommandMap}).\n      for (var i = commandName.length; i > 0; i--) {\n        var prefix = commandName.substring(0, i);\n\n        if (this.commandMap_[prefix]) {\n          var command = this.commandMap_[prefix];\n\n          if (command.name.indexOf(commandName) === 0) {\n            return command;\n          }\n        }\n      }\n\n      return null;\n    },\n    buildCommandMap_: function buildCommandMap_() {\n      this.commandMap_ = {};\n\n      for (var i = 0; i < defaultExCommandMap.length; i++) {\n        var command = defaultExCommandMap[i];\n        var key = command.shortName || command.name;\n        this.commandMap_[key] = command;\n      }\n    },\n    map: function map(lhs, rhs, ctx) {\n      if (lhs != \":\" && lhs.charAt(0) == \":\") {\n        if (ctx) {\n          throw Error(\"Mode not supported for ex mappings\");\n        }\n\n        var commandName = lhs.substring(1);\n\n        if (rhs != \":\" && rhs.charAt(0) == \":\") {\n          // Ex to Ex mapping\n          this.commandMap_[commandName] = {\n            name: commandName,\n            type: \"exToEx\",\n            toInput: rhs.substring(1),\n            user: true\n          };\n        } else {\n          // Ex to key mapping\n          this.commandMap_[commandName] = {\n            name: commandName,\n            type: \"exToKey\",\n            toKeys: rhs,\n            user: true\n          };\n        }\n      } else {\n        if (rhs != \":\" && rhs.charAt(0) == \":\") {\n          // Key to Ex mapping.\n          var mapping = {\n            keys: lhs,\n            type: \"keyToEx\",\n            exArgs: {\n              input: rhs.substring(1)\n            }\n          };\n\n          if (ctx) {\n            mapping.context = ctx;\n          }\n\n          defaultKeymap.unshift(mapping);\n        } else {\n          // Key to key mapping\n          var mapping = {\n            keys: lhs,\n            type: \"keyToKey\",\n            toKeys: rhs\n          };\n\n          if (ctx) {\n            mapping.context = ctx;\n          }\n\n          defaultKeymap.unshift(mapping);\n        }\n      }\n    },\n    unmap: function unmap(lhs, ctx) {\n      if (lhs != \":\" && lhs.charAt(0) == \":\") {\n        // Ex to Ex or Ex to key mapping\n        if (ctx) {\n          throw Error(\"Mode not supported for ex mappings\");\n        }\n\n        var commandName = lhs.substring(1);\n\n        if (this.commandMap_[commandName] && this.commandMap_[commandName].user) {\n          delete this.commandMap_[commandName];\n          return true;\n        }\n      } else {\n        // Key to Ex or key to key mapping\n        var keys = lhs;\n\n        for (var i = 0; i < defaultKeymap.length; i++) {\n          if (keys == defaultKeymap[i].keys && defaultKeymap[i].context === ctx) {\n            defaultKeymap.splice(i, 1);\n            return true;\n          }\n        }\n      }\n    }\n  };\n  var exCommands = {\n    colorscheme: function colorscheme(cm, params) {\n      if (!params.args || params.args.length < 1) {\n        showConfirm(cm, cm.getOption(\"theme\"));\n        return;\n      }\n\n      cm.setOption(\"theme\", params.args[0]);\n    },\n    map: function map(cm, params, ctx) {\n      var mapArgs = params.args;\n\n      if (!mapArgs || mapArgs.length < 2) {\n        if (cm) {\n          showConfirm(cm, \"Invalid mapping: \" + params.input);\n        }\n\n        return;\n      }\n\n      exCommandDispatcher.map(mapArgs[0], mapArgs[1], ctx);\n    },\n    imap: function imap(cm, params) {\n      this.map(cm, params, \"insert\");\n    },\n    nmap: function nmap(cm, params) {\n      this.map(cm, params, \"normal\");\n    },\n    vmap: function vmap(cm, params) {\n      this.map(cm, params, \"visual\");\n    },\n    unmap: function unmap(cm, params, ctx) {\n      var mapArgs = params.args;\n\n      if (!mapArgs || mapArgs.length < 1 || !exCommandDispatcher.unmap(mapArgs[0], ctx)) {\n        if (cm) {\n          showConfirm(cm, \"No such mapping: \" + params.input);\n        }\n      }\n    },\n    move: function move(cm, params) {\n      commandDispatcher.processCommand(cm, cm.state.vim, {\n        type: \"motion\",\n        motion: \"moveToLineOrEdgeOfDocument\",\n        motionArgs: {\n          forward: false,\n          explicitRepeat: true,\n          linewise: true\n        },\n        repeatOverride: params.line + 1\n      });\n    },\n    set: function set(cm, params) {\n      var setArgs = params.args; // Options passed through to the setOption/getOption calls. May be passed in by the\n      // local/global versions of the set command\n\n      var setCfg = params.setCfg || {};\n\n      if (!setArgs || setArgs.length < 1) {\n        if (cm) {\n          showConfirm(cm, \"Invalid mapping: \" + params.input);\n        }\n\n        return;\n      }\n\n      var expr = setArgs[0].split(\"=\");\n      var optionName = expr[0];\n      var value = expr[1];\n      var forceGet = false;\n\n      if (optionName.charAt(optionName.length - 1) == \"?\") {\n        // If post-fixed with ?, then the set is actually a get.\n        if (value) {\n          throw Error(\"Trailing characters: \" + params.argString);\n        }\n\n        optionName = optionName.substring(0, optionName.length - 1);\n        forceGet = true;\n      }\n\n      if (value === undefined && optionName.substring(0, 2) == \"no\") {\n        // To set boolean options to false, the option name is prefixed with\n        // 'no'.\n        optionName = optionName.substring(2);\n        value = false;\n      }\n\n      var optionIsBoolean = options[optionName] && options[optionName].type == \"boolean\";\n\n      if (optionIsBoolean && value == undefined) {\n        // Calling set with a boolean option sets it to true.\n        value = true;\n      } // If no value is provided, then we assume this is a get.\n\n\n      if (!optionIsBoolean && value === undefined || forceGet) {\n        var oldValue = getOption(optionName, cm, setCfg);\n\n        if (oldValue instanceof Error) {\n          showConfirm(cm, oldValue.message);\n        } else if (oldValue === true || oldValue === false) {\n          showConfirm(cm, \" \" + (oldValue ? \"\" : \"no\") + optionName);\n        } else {\n          showConfirm(cm, \"  \" + optionName + \"=\" + oldValue);\n        }\n      } else {\n        var setOptionReturn = setOption(optionName, value, cm, setCfg);\n\n        if (setOptionReturn instanceof Error) {\n          showConfirm(cm, setOptionReturn.message);\n        }\n      }\n    },\n    setlocal: function setlocal(cm, params) {\n      // setCfg is passed through to setOption\n      params.setCfg = {\n        scope: \"local\"\n      };\n      this.set(cm, params);\n    },\n    setglobal: function setglobal(cm, params) {\n      // setCfg is passed through to setOption\n      params.setCfg = {\n        scope: \"global\"\n      };\n      this.set(cm, params);\n    },\n    registers: function registers(cm, params) {\n      var regArgs = params.args;\n      var registers = vimGlobalState.registerController.registers;\n      var regInfo = \"----------Registers----------\\n\\n\";\n\n      if (!regArgs) {\n        for (var registerName in registers) {\n          var text = registers[registerName].toString();\n\n          if (text.length) {\n            regInfo += '\"' + registerName + \"    \" + text + \"\\n\";\n          }\n        }\n      } else {\n        var registerName;\n        regArgs = regArgs.join(\"\");\n\n        for (var i = 0; i < regArgs.length; i++) {\n          registerName = regArgs.charAt(i);\n\n          if (!vimGlobalState.registerController.isValidRegister(registerName)) {\n            continue;\n          }\n\n          var register = registers[registerName] || new Register();\n          regInfo += '\"' + registerName + \"    \" + register.toString() + \"\\n\";\n        }\n      }\n\n      showConfirm(cm, regInfo);\n    },\n    sort: function sort(cm, params) {\n      var reverse, ignoreCase, unique, number, pattern;\n\n      function parseArgs() {\n        if (params.argString) {\n          var args = new _cm_adapter[\"default\"].StringStream(params.argString);\n\n          if (args.eat(\"!\")) {\n            reverse = true;\n          }\n\n          if (args.eol()) {\n            return;\n          }\n\n          if (!args.eatSpace()) {\n            return \"Invalid arguments\";\n          }\n\n          var opts = args.match(/([dinuox]+)?\\s*(\\/.+\\/)?\\s*/);\n\n          if (!opts && !args.eol()) {\n            return \"Invalid arguments\";\n          }\n\n          if (opts[1]) {\n            ignoreCase = opts[1].indexOf(\"i\") != -1;\n            unique = opts[1].indexOf(\"u\") != -1;\n            var decimal = opts[1].indexOf(\"d\") != -1 || opts[1].indexOf(\"n\") != -1 && 1;\n            var hex = opts[1].indexOf(\"x\") != -1 && 1;\n            var octal = opts[1].indexOf(\"o\") != -1 && 1;\n\n            if (decimal + hex + octal > 1) {\n              return \"Invalid arguments\";\n            }\n\n            number = decimal && \"decimal\" || hex && \"hex\" || octal && \"octal\";\n          }\n\n          if (opts[2]) {\n            pattern = new RegExp(opts[2].substr(1, opts[2].length - 2), ignoreCase ? \"i\" : \"\");\n          }\n        }\n      }\n\n      var err = parseArgs();\n\n      if (err) {\n        showConfirm(cm, err + \": \" + params.argString);\n        return;\n      }\n\n      var lineStart = params.line || cm.firstLine();\n      var lineEnd = params.lineEnd || params.line || cm.lastLine();\n\n      if (lineStart == lineEnd) {\n        return;\n      }\n\n      var curStart = new Pos(lineStart, 0);\n      var curEnd = new Pos(lineEnd, lineLength(cm, lineEnd));\n      var text = cm.getRange(curStart, curEnd).split(\"\\n\");\n      var numberRegex = pattern ? pattern : number == \"decimal\" ? /(-?)([\\d]+)/ : number == \"hex\" ? /(-?)(?:0x)?([0-9a-f]+)/i : number == \"octal\" ? /([0-7]+)/ : null;\n      var radix = number == \"decimal\" ? 10 : number == \"hex\" ? 16 : number == \"octal\" ? 8 : null;\n      var numPart = [],\n          textPart = [];\n\n      if (number || pattern) {\n        for (var i = 0; i < text.length; i++) {\n          var matchPart = pattern ? text[i].match(pattern) : null;\n\n          if (matchPart && matchPart[0] != \"\") {\n            numPart.push(matchPart);\n          } else if (!pattern && numberRegex.exec(text[i])) {\n            numPart.push(text[i]);\n          } else {\n            textPart.push(text[i]);\n          }\n        }\n      } else {\n        textPart = text;\n      }\n\n      function compareFn(a, b) {\n        if (reverse) {\n          var tmp;\n          tmp = a;\n          a = b;\n          b = tmp;\n        }\n\n        if (ignoreCase) {\n          a = a.toLowerCase();\n          b = b.toLowerCase();\n        }\n\n        var anum = number && numberRegex.exec(a);\n        var bnum = number && numberRegex.exec(b);\n\n        if (!anum) {\n          return a < b ? -1 : 1;\n        }\n\n        anum = parseInt((anum[1] + anum[2]).toLowerCase(), radix);\n        bnum = parseInt((bnum[1] + bnum[2]).toLowerCase(), radix);\n        return anum - bnum;\n      }\n\n      function comparePatternFn(a, b) {\n        if (reverse) {\n          var tmp;\n          tmp = a;\n          a = b;\n          b = tmp;\n        }\n\n        if (ignoreCase) {\n          a[0] = a[0].toLowerCase();\n          b[0] = b[0].toLowerCase();\n        }\n\n        return a[0] < b[0] ? -1 : 1;\n      }\n\n      numPart.sort(pattern ? comparePatternFn : compareFn);\n\n      if (pattern) {\n        for (var i = 0; i < numPart.length; i++) {\n          numPart[i] = numPart[i].input;\n        }\n      } else if (!number) {\n        textPart.sort(compareFn);\n      }\n\n      text = !reverse ? textPart.concat(numPart) : numPart.concat(textPart);\n\n      if (unique) {\n        // Remove duplicate lines\n        var textOld = text;\n        var lastLine;\n        text = [];\n\n        for (var i = 0; i < textOld.length; i++) {\n          if (textOld[i] != lastLine) {\n            text.push(textOld[i]);\n          }\n\n          lastLine = textOld[i];\n        }\n      }\n\n      cm.replaceRange(text.join(\"\\n\"), curStart, curEnd);\n    },\n    vglobal: function vglobal(cm, params) {\n      // global inspects params.commandName\n      this.global(cm, params);\n    },\n    global: function global(cm, params) {\n      // a global command is of the form\n      // :[range]g/pattern/[cmd]\n      // argString holds the string /pattern/[cmd]\n      var argString = params.argString;\n\n      if (!argString) {\n        showConfirm(cm, \"Regular Expression missing from global\");\n        return;\n      }\n\n      var inverted = params.commandName[0] === \"v\"; // range is specified here\n\n      var lineStart = params.line !== undefined ? params.line : cm.firstLine();\n      var lineEnd = params.lineEnd || params.line || cm.lastLine(); // get the tokens from argString\n\n      var tokens = splitBySlash(argString);\n      var regexPart = argString,\n          cmd;\n\n      if (tokens.length) {\n        regexPart = tokens[0];\n        cmd = tokens.slice(1, tokens.length).join(\"/\");\n      }\n\n      if (regexPart) {\n        // If regex part is empty, then use the previous query. Otherwise\n        // use the regex part as the new query.\n        try {\n          updateSearchQuery(cm, regexPart, true\n          /** ignoreCase */\n          , true\n          /** smartCase */\n          );\n        } catch (e) {\n          showConfirm(cm, \"Invalid regex: \" + regexPart);\n          return;\n        }\n      } // now that we have the regexPart, search for regex matches in the\n      // specified range of lines\n\n\n      var query = getSearchState(cm).getQuery();\n      var matchedLines = [];\n\n      for (var i = lineStart; i <= lineEnd; i++) {\n        var line = cm.getLineHandle(i);\n        var matched = query.test(line.text);\n\n        if (matched !== inverted) {\n          matchedLines.push(cmd ? line : line.text);\n        }\n      } // if there is no [cmd], just display the list of matched lines\n\n\n      if (!cmd) {\n        showConfirm(cm, matchedLines.join(\"\\n\"));\n        return;\n      }\n\n      var index = 0;\n\n      var nextCommand = function nextCommand() {\n        if (index < matchedLines.length) {\n          var line = matchedLines[index++];\n          var lineNum = cm.getLineNumber(line);\n\n          if (lineNum == null) {\n            nextCommand();\n            return;\n          }\n\n          var command = lineNum + 1 + cmd;\n          exCommandDispatcher.processCommand(cm, command, {\n            callback: nextCommand\n          });\n        }\n      };\n\n      nextCommand();\n    },\n    substitute: function substitute(cm, params) {\n      if (!cm.getSearchCursor) {\n        throw new Error(\"Search feature not available. Requires searchcursor.js or \" + \"any other getSearchCursor implementation.\");\n      }\n\n      var argString = params.argString;\n      var tokens = argString ? splitBySeparator(argString, argString[0]) : [];\n      var regexPart,\n          replacePart = \"\",\n          trailing,\n          flagsPart,\n          count;\n      var confirm = false; // Whether to confirm each replace.\n\n      var global = false; // True to replace all instances on a line, false to replace only 1.\n\n      if (tokens.length) {\n        regexPart = tokens[0];\n\n        if (getOption(\"pcre\") && regexPart !== \"\") {\n          regexPart = new RegExp(regexPart).source; //normalize not escaped characters\n        }\n\n        replacePart = tokens[1];\n\n        if (replacePart !== undefined) {\n          if (getOption(\"pcre\")) {\n            replacePart = unescapeRegexReplace(replacePart.replace(/([^\\\\])&/g, \"$1$$&\"));\n          } else {\n            replacePart = translateRegexReplace(replacePart);\n          }\n\n          vimGlobalState.lastSubstituteReplacePart = replacePart;\n        }\n\n        trailing = tokens[2] ? tokens[2].split(\" \") : [];\n      } else {\n        // either the argString is empty or its of the form ' hello/world'\n        // actually splitBySlash returns a list of tokens\n        // only if the string starts with a '/'\n        if (argString && argString.length) {\n          showConfirm(cm, \"Substitutions should be of the form \" + \":s/pattern/replace/\");\n          return;\n        }\n      } // After the 3rd slash, we can have flags followed by a space followed\n      // by count.\n\n\n      if (trailing) {\n        flagsPart = trailing[0];\n        count = parseInt(trailing[1]);\n\n        if (flagsPart) {\n          if (flagsPart.indexOf(\"c\") != -1) {\n            confirm = true;\n          }\n\n          if (flagsPart.indexOf(\"g\") != -1) {\n            global = true;\n          }\n\n          if (getOption(\"pcre\")) {\n            regexPart = regexPart + \"/\" + flagsPart;\n          } else {\n            regexPart = regexPart.replace(/\\//g, \"\\\\/\") + \"/\" + flagsPart;\n          }\n        }\n      }\n\n      if (regexPart) {\n        // If regex part is empty, then use the previous query. Otherwise use\n        // the regex part as the new query.\n        try {\n          updateSearchQuery(cm, regexPart, true\n          /** ignoreCase */\n          , true\n          /** smartCase */\n          );\n        } catch (e) {\n          showConfirm(cm, \"Invalid regex: \" + regexPart);\n          return;\n        }\n      }\n\n      replacePart = replacePart || vimGlobalState.lastSubstituteReplacePart;\n\n      if (replacePart === undefined) {\n        showConfirm(cm, \"No previous substitute regular expression\");\n        return;\n      }\n\n      var state = getSearchState(cm);\n      var query = state.getQuery();\n      var lineStart = params.line !== undefined ? params.line : cm.getCursor().line;\n      var lineEnd = params.lineEnd || lineStart;\n\n      if (lineStart == cm.firstLine() && lineEnd == cm.lastLine()) {\n        lineEnd = Infinity;\n      }\n\n      if (count) {\n        lineStart = lineEnd;\n        lineEnd = lineStart + count - 1;\n      }\n\n      var startPos = clipCursorToContent(cm, new Pos(lineStart, 0));\n      var cursor = cm.getSearchCursor(query, startPos);\n      cm.pushUndoStop();\n      doReplace(cm, confirm, global, lineStart, lineEnd, cursor, query, replacePart, params.callback);\n    },\n    redo: _cm_adapter[\"default\"].commands.redo,\n    undo: _cm_adapter[\"default\"].commands.undo,\n    write: function write(cm) {\n      if (_cm_adapter[\"default\"].commands.save) {\n        // If a save command is defined, call it.\n        _cm_adapter[\"default\"].commands.save(cm);\n      } else if (cm.save) {\n        // Saves to text area if no save command is defined and cm.save() is available.\n        cm.save();\n      }\n    },\n    nohlsearch: function nohlsearch(cm) {\n      clearSearchHighlight(cm);\n    },\n    yank: function yank(cm) {\n      var cur = copyCursor(cm.getCursor());\n      var line = cur.line;\n      var lineText = cm.getLine(line);\n      vimGlobalState.registerController.pushText(\"0\", \"yank\", lineText, true, true);\n    },\n    delmarks: function delmarks(cm, params) {\n      if (!params.argString || !trim(params.argString)) {\n        showConfirm(cm, \"Argument required\");\n        return;\n      }\n\n      var state = cm.state.vim;\n      var stream = new _cm_adapter[\"default\"].StringStream(trim(params.argString));\n\n      while (!stream.eol()) {\n        stream.eatSpace(); // Record the streams position at the beginning of the loop for use\n        // in error messages.\n\n        var count = stream.pos;\n\n        if (!stream.match(/[a-zA-Z]/, false)) {\n          showConfirm(cm, \"Invalid argument: \" + params.argString.substring(count));\n          return;\n        }\n\n        var sym = stream.next(); // Check if this symbol is part of a range\n\n        if (stream.match(\"-\", true)) {\n          // This symbol is part of a range.\n          // The range must terminate at an alphabetic character.\n          if (!stream.match(/[a-zA-Z]/, false)) {\n            showConfirm(cm, \"Invalid argument: \" + params.argString.substring(count));\n            return;\n          }\n\n          var startMark = sym;\n          var finishMark = stream.next(); // The range must terminate at an alphabetic character which\n          // shares the same case as the start of the range.\n\n          if (isLowerCase(startMark) && isLowerCase(finishMark) || isUpperCase(startMark) && isUpperCase(finishMark)) {\n            var start = startMark.charCodeAt(0);\n            var finish = finishMark.charCodeAt(0);\n\n            if (start >= finish) {\n              showConfirm(cm, \"Invalid argument: \" + params.argString.substring(count));\n              return;\n            } // Because marks are always ASCII values, and we have\n            // determined that they are the same case, we can use\n            // their char codes to iterate through the defined range.\n\n\n            for (var j = 0; j <= finish - start; j++) {\n              var mark = String.fromCharCode(start + j);\n              delete state.marks[mark];\n            }\n          } else {\n            showConfirm(cm, \"Invalid argument: \" + startMark + \"-\");\n            return;\n          }\n        } else {\n          // This symbol is a valid mark, and is not part of a range.\n          delete state.marks[sym];\n        }\n      }\n    }\n  };\n  var exCommandDispatcher = new ExCommandDispatcher();\n  /**\n   * @param {CodeMirror} cm CodeMirror instance we are in.\n   * @param {boolean} confirm Whether to confirm each replace.\n   * @param {Cursor} lineStart Line to start replacing from.\n   * @param {Cursor} lineEnd Line to stop replacing at.\n   * @param {RegExp} query Query for performing matches with.\n   * @param {string} replaceWith Text to replace matches with. May contain $1,\n   *     $2, etc for replacing captured groups using JavaScript replace.\n   * @param {function()} callback A callback for when the replace is done.\n   */\n\n  function doReplace(cm, confirm, global, lineStart, lineEnd, searchCursor, query, replaceWith, callback) {\n    // Set up all the functions.\n    cm.state.vim.exMode = true;\n    var done = false;\n    var lastPos, modifiedLineNumber, joined;\n\n    function replaceAll() {\n      cm.operation(function () {\n        while (!done) {\n          replace();\n          next();\n        }\n\n        stop();\n      });\n    }\n\n    function replace() {\n      var text = cm.getRange(searchCursor.from(), searchCursor.to());\n      var newText = text.replace(query, replaceWith);\n      var unmodifiedLineNumber = searchCursor.to().line;\n      searchCursor.replace(newText);\n      modifiedLineNumber = searchCursor.to().line;\n      lineEnd += modifiedLineNumber - unmodifiedLineNumber;\n      joined = modifiedLineNumber < unmodifiedLineNumber;\n    }\n\n    function findNextValidMatch() {\n      var lastMatchTo = lastPos && copyCursor(searchCursor.to());\n      var match = searchCursor.findNext();\n\n      if (match && !match[0] && lastMatchTo && cursorEqual(searchCursor.from(), lastMatchTo)) {\n        match = searchCursor.findNext();\n      }\n\n      return match;\n    }\n\n    function next() {\n      // The below only loops to skip over multiple occurrences on the same\n      // line when 'global' is not true.\n      while (findNextValidMatch() && isInRange(searchCursor.from(), lineStart, lineEnd)) {\n        if (!global && searchCursor.from().line == modifiedLineNumber && !joined) {\n          continue;\n        }\n\n        cm.scrollIntoView(searchCursor.from(), 30);\n        cm.setSelection(searchCursor.from(), searchCursor.to());\n        lastPos = searchCursor.from();\n        done = false;\n        return;\n      }\n\n      done = true;\n    }\n\n    function stop(close) {\n      if (close) {\n        close();\n      }\n\n      cm.focus();\n\n      if (lastPos) {\n        cm.setCursor(lastPos);\n        var vim = cm.state.vim;\n        vim.exMode = false;\n        vim.lastHPos = vim.lastHSPos = lastPos.ch;\n      }\n\n      if (callback) {\n        callback();\n      }\n    }\n\n    function onPromptKeyDown(e, _value, close) {\n      // Swallow all keys.\n      _cm_adapter[\"default\"].e_stop(e);\n\n      var keyName = _cm_adapter[\"default\"].keyName(e);\n\n      switch (keyName) {\n        case \"Y\":\n          replace();\n          next();\n          break;\n\n        case \"N\":\n          next();\n          break;\n\n        case \"A\":\n          // replaceAll contains a call to close of its own. We don't want it\n          // to fire too early or multiple times.\n          var savedCallback = callback;\n          callback = undefined;\n          cm.operation(replaceAll);\n          callback = savedCallback;\n          break;\n\n        case \"L\":\n          replace();\n        // fall through and exit.\n\n        case \"Q\":\n        case \"Esc\":\n        case \"Ctrl-C\":\n        case \"Ctrl-[\":\n          stop(close);\n          break;\n      }\n\n      if (done) {\n        stop(close);\n      }\n\n      return true;\n    } // Actually do replace.\n\n\n    next();\n\n    if (done) {\n      showConfirm(cm, \"No matches for \" + query.source);\n      return;\n    }\n\n    if (!confirm) {\n      replaceAll();\n\n      if (callback) {\n        callback();\n      }\n\n      return;\n    }\n\n    showPrompt(cm, {\n      prefix: dom(\"span\", \"replace with \", dom(\"strong\", replaceWith), \" (y/n/a/q/l)\"),\n      onKeyDown: onPromptKeyDown\n    });\n  }\n\n  _cm_adapter[\"default\"].keyMap.vim = {\n    attach: attachVimMap,\n    detach: detachVimMap,\n    call: cmKey\n  };\n\n  function exitInsertMode(cm) {\n    var vim = cm.state.vim;\n    var macroModeState = vimGlobalState.macroModeState;\n    var insertModeChangeRegister = vimGlobalState.registerController.getRegister(\".\");\n    var isPlaying = macroModeState.isPlaying;\n    var lastChange = macroModeState.lastInsertModeChanges;\n\n    if (!isPlaying) {\n      cm.off(\"change\", onChange);\n\n      _cm_adapter[\"default\"].off(cm.getInputField(), \"keydown\", onKeyEventTargetKeyDown);\n    }\n\n    if (!isPlaying && vim.insertModeRepeat > 1) {\n      // Perform insert mode repeat for commands like 3,a and 3,o.\n      _repeatLastEdit(cm, vim, vim.insertModeRepeat - 1, true\n      /** repeatForInsert */\n      );\n\n      vim.lastEditInputState.repeatOverride = vim.insertModeRepeat;\n    }\n\n    delete vim.insertModeRepeat;\n    vim.insertMode = false;\n    cm.setCursor(cm.getCursor().line, cm.getCursor().ch - 1);\n    cm.setOption(\"keyMap\", \"vim\");\n    cm.setOption(\"disableInput\", true);\n    cm.toggleOverwrite(false); // exit replace mode if we were in it.\n    // update the \". register before exiting insert mode\n\n    insertModeChangeRegister.setText(lastChange.changes.join(\"\"));\n\n    _cm_adapter[\"default\"].signal(cm, \"vim-mode-change\", {\n      mode: \"normal\"\n    });\n\n    if (macroModeState.isRecording) {\n      logInsertModeChange(macroModeState);\n    }\n\n    cm.enterVimMode();\n  }\n\n  function _mapCommand(command) {\n    defaultKeymap.unshift(command);\n  }\n\n  function mapCommand(keys, type, name, args, extra) {\n    var command = {\n      keys: keys,\n      type: type\n    };\n    command[type] = name;\n    command[type + \"Args\"] = args;\n\n    for (var key in extra) {\n      command[key] = extra[key];\n    }\n\n    _mapCommand(command);\n  } // The timeout in milliseconds for the two-character ESC keymap should be\n  // adjusted according to your typing speed to prevent false positives.\n\n\n  defineOption(\"insertModeEscKeysTimeout\", 200, \"number\");\n  _cm_adapter[\"default\"].keyMap[\"vim-insert\"] = {\n    // TODO: override navigation keys so that Esc will cancel automatic\n    // indentation from o, O, i_<CR>\n    fallthrough: [\"default\"],\n    attach: attachVimMap,\n    detach: detachVimMap,\n    call: cmKey\n  };\n  _cm_adapter[\"default\"].keyMap[\"vim-replace\"] = {\n    Backspace: \"goCharLeft\",\n    fallthrough: [\"vim-insert\"],\n    attach: attachVimMap,\n    detach: detachVimMap,\n    call: cmKey\n  };\n\n  function executeMacroRegister(cm, vim, macroModeState, registerName) {\n    var register = vimGlobalState.registerController.getRegister(registerName);\n\n    if (registerName == \":\") {\n      // Read-only register containing last Ex command.\n      if (register.keyBuffer[0]) {\n        exCommandDispatcher.processCommand(cm, register.keyBuffer[0]);\n      }\n\n      macroModeState.isPlaying = false;\n      return;\n    }\n\n    var keyBuffer = register.keyBuffer;\n    var imc = 0;\n    macroModeState.isPlaying = true;\n    macroModeState.replaySearchQueries = register.searchQueries.slice(0);\n\n    for (var i = 0; i < keyBuffer.length; i++) {\n      var text = keyBuffer[i];\n      var match, key;\n\n      while (text) {\n        // Pull off one command key, which is either a single character\n        // or a special sequence wrapped in '<' and '>', e.g. '<Space>'.\n        match = /<\\w+-.+?>|<\\w+>|./.exec(text);\n        key = match[0];\n        text = text.substring(match.index + key.length);\n        vimApi.handleKey(cm, key, \"macro\");\n\n        if (vim.insertMode) {\n          var changes = register.insertModeChanges[imc++].changes;\n          vimGlobalState.macroModeState.lastInsertModeChanges.changes = changes;\n          repeatInsertModeChanges(cm, changes, 1);\n          exitInsertMode(cm);\n        }\n      }\n    }\n\n    macroModeState.isPlaying = false;\n  }\n\n  function logKey(macroModeState, key) {\n    if (macroModeState.isPlaying) {\n      return;\n    }\n\n    var registerName = macroModeState.latestRegister;\n    var register = vimGlobalState.registerController.getRegister(registerName);\n\n    if (register) {\n      register.pushText(key);\n    }\n  }\n\n  function logInsertModeChange(macroModeState) {\n    if (macroModeState.isPlaying) {\n      return;\n    }\n\n    var registerName = macroModeState.latestRegister;\n    var register = vimGlobalState.registerController.getRegister(registerName);\n\n    if (register && register.pushInsertModeChanges) {\n      register.pushInsertModeChanges(macroModeState.lastInsertModeChanges);\n    }\n  }\n\n  function logSearchQuery(macroModeState, query) {\n    if (macroModeState.isPlaying) {\n      return;\n    }\n\n    var registerName = macroModeState.latestRegister;\n    var register = vimGlobalState.registerController.getRegister(registerName);\n\n    if (register && register.pushSearchQuery) {\n      register.pushSearchQuery(query);\n    }\n  }\n  /**\n   * Listens for changes made in insert mode.\n   * Should only be active in insert mode.\n   */\n\n\n  function onChange(cm, changeObj) {\n    var macroModeState = vimGlobalState.macroModeState;\n    var lastChange = macroModeState.lastInsertModeChanges;\n\n    if (!macroModeState.isPlaying) {\n      while (changeObj) {\n        lastChange.expectCursorActivityForChange = true;\n\n        if (lastChange.ignoreCount > 1) {\n          lastChange.ignoreCount--;\n        } else if (changeObj.origin == \"+input\" || changeObj.origin == \"paste\" || changeObj.origin === undefined\n        /* only in testing */\n        ) {\n          var selectionCount = cm.listSelections().length;\n          if (selectionCount > 1) lastChange.ignoreCount = selectionCount;\n          var text = changeObj.text.join(\"\\n\");\n\n          if (lastChange.maybeReset) {\n            lastChange.changes = [];\n            lastChange.maybeReset = false;\n          }\n\n          if (text) {\n            if (cm.state.overwrite && !/\\n/.test(text)) {\n              lastChange.changes.push([text]);\n            } else {\n              lastChange.changes.push(text);\n            }\n          }\n        } // Change objects may be chained with next.\n\n\n        changeObj = changeObj.next;\n      }\n    }\n  }\n  /**\n   * Listens for any kind of cursor activity on CodeMirror.\n   */\n\n\n  function onCursorActivity(cm) {\n    var vim = cm.state.vim;\n\n    if (vim.insertMode) {\n      // Tracking cursor activity in insert mode (for macro support).\n      var macroModeState = vimGlobalState.macroModeState;\n\n      if (macroModeState.isPlaying) {\n        return;\n      }\n\n      var lastChange = macroModeState.lastInsertModeChanges;\n\n      if (lastChange.expectCursorActivityForChange) {\n        lastChange.expectCursorActivityForChange = false;\n      } else {\n        // Cursor moved outside the context of an edit. Reset the change.\n        lastChange.maybeReset = true;\n      }\n    } else if (!cm.curOp.isVimOp) {\n      handleExternalSelection(cm, vim);\n    }\n  }\n\n  function handleExternalSelection(cm, vim) {\n    var anchor = cm.getCursor(\"anchor\");\n    var head = cm.getCursor(\"head\"); // Enter or exit visual mode to match mouse selection.\n\n    if (vim.visualMode && !cm.somethingSelected()) {\n      exitVisualMode(cm, false);\n    } else if (!vim.visualMode && !vim.insertMode && cm.somethingSelected()) {\n      vim.visualMode = true;\n      vim.visualLine = false;\n\n      _cm_adapter[\"default\"].signal(cm, \"vim-mode-change\", {\n        mode: \"visual\"\n      });\n    }\n\n    if (vim.visualMode) {\n      // Bind CodeMirror selection model to vim selection model.\n      // Mouse selections are considered visual characterwise.\n      var headOffset = !cursorIsBefore(head, anchor) ? -1 : 0;\n      var anchorOffset = cursorIsBefore(head, anchor) ? -1 : 0;\n      head = offsetCursor(head, 0, headOffset);\n      anchor = offsetCursor(anchor, 0, anchorOffset);\n      vim.sel = {\n        anchor: anchor,\n        head: head\n      };\n      updateMark(cm, vim, \"<\", cursorMin(head, anchor));\n      updateMark(cm, vim, \">\", cursorMax(head, anchor));\n    } else if (!vim.insertMode) {\n      // Reset lastHPos if selection was modified by something outside of vim mode e.g. by mouse.\n      vim.lastHPos = cm.getCursor().ch;\n    }\n  }\n  /** Wrapper for special keys pressed in insert mode */\n\n\n  function InsertModeKey(keyName) {\n    this.keyName = keyName;\n  }\n  /**\n   * Handles raw key down events from the text area.\n   * - Should only be active in insert mode.\n   * - For recording deletes in insert mode.\n   */\n\n\n  function onKeyEventTargetKeyDown(e) {\n    var macroModeState = vimGlobalState.macroModeState;\n    var lastChange = macroModeState.lastInsertModeChanges;\n\n    var keyName = _cm_adapter[\"default\"].keyName(e);\n\n    if (!keyName) {\n      return;\n    }\n\n    function onKeyFound() {\n      if (lastChange.maybeReset) {\n        lastChange.changes = [];\n        lastChange.maybeReset = false;\n      }\n\n      lastChange.changes.push(new InsertModeKey(keyName));\n      return true;\n    }\n\n    if (keyName.indexOf(\"Delete\") != -1 || keyName.indexOf(\"Backspace\") != -1) {\n      _cm_adapter[\"default\"].lookupKey(keyName, \"vim-insert\", onKeyFound);\n    }\n  }\n  /**\n   * Repeats the last edit, which includes exactly 1 command and at most 1\n   * insert. Operator and motion commands are read from lastEditInputState,\n   * while action commands are read from lastEditActionCommand.\n   *\n   * If repeatForInsert is true, then the function was called by\n   * exitInsertMode to repeat the insert mode changes the user just made. The\n   * corresponding enterInsertMode call was made with a count.\n   */\n\n\n  function _repeatLastEdit(cm, vim, repeat, repeatForInsert) {\n    var macroModeState = vimGlobalState.macroModeState;\n    macroModeState.isPlaying = true;\n    var isAction = !!vim.lastEditActionCommand;\n    var cachedInputState = vim.inputState;\n\n    function repeatCommand() {\n      if (isAction) {\n        commandDispatcher.processAction(cm, vim, vim.lastEditActionCommand);\n      } else {\n        commandDispatcher.evalInput(cm, vim);\n      }\n    }\n\n    function repeatInsert(repeat) {\n      if (macroModeState.lastInsertModeChanges.changes.length > 0) {\n        // For some reason, repeat cw in desktop VIM does not repeat\n        // insert mode changes. Will conform to that behavior.\n        repeat = !vim.lastEditActionCommand ? 1 : repeat;\n        var changeObject = macroModeState.lastInsertModeChanges;\n        repeatInsertModeChanges(cm, changeObject.changes, repeat);\n      }\n    }\n\n    vim.inputState = vim.lastEditInputState;\n\n    if (isAction && vim.lastEditActionCommand.interlaceInsertRepeat) {\n      // o and O repeat have to be interlaced with insert repeats so that the\n      // insertions appear on separate lines instead of the last line.\n      for (var i = 0; i < repeat; i++) {\n        repeatCommand();\n        repeatInsert(1);\n      }\n    } else {\n      if (!repeatForInsert) {\n        // Hack to get the cursor to end up at the right place. If I is\n        // repeated in insert mode repeat, cursor will be 1 insert\n        // change set left of where it should be.\n        repeatCommand();\n      }\n\n      repeatInsert(repeat);\n    }\n\n    vim.inputState = cachedInputState;\n\n    if (vim.insertMode && !repeatForInsert) {\n      // Don't exit insert mode twice. If repeatForInsert is set, then we\n      // were called by an exitInsertMode call lower on the stack.\n      exitInsertMode(cm);\n    }\n\n    macroModeState.isPlaying = false;\n  }\n\n  function repeatInsertModeChanges(cm, changes, repeat) {\n    function keyHandler(binding) {\n      if (typeof binding == \"string\") {\n        _cm_adapter[\"default\"].commands[binding](cm);\n      } else {\n        binding(cm);\n      }\n\n      return true;\n    }\n\n    var head = cm.getCursor(\"head\");\n    var visualBlock = vimGlobalState.macroModeState.lastInsertModeChanges.visualBlock;\n\n    if (visualBlock) {\n      // Set up block selection again for repeating the changes.\n      selectForInsert(cm, head, visualBlock + 1);\n      repeat = cm.listSelections().length;\n      cm.setCursor(head);\n    }\n\n    for (var i = 0; i < repeat; i++) {\n      if (visualBlock) {\n        cm.setCursor(offsetCursor(head, i, 0));\n      }\n\n      for (var j = 0; j < changes.length; j++) {\n        var change = changes[j];\n\n        if (change instanceof InsertModeKey) {\n          _cm_adapter[\"default\"].lookupKey(change.keyName, \"vim-insert\", keyHandler);\n        } else if (typeof change == \"string\") {\n          window.cm = cm;\n          cm.replaceSelections(change);\n        } else {\n          var start = cm.getCursor();\n          var end = offsetCursor(start, 0, change[0].length);\n          cm.replaceRange(change[0], start, end);\n          cm.setCursor(end);\n        }\n      }\n    }\n\n    if (visualBlock) {\n      cm.setCursor(offsetCursor(head, 0, 1));\n    }\n  }\n\n  resetVimGlobalState();\n  return vimApi;\n}; // Initialize Vim and make it available as an API.\n\n\nexports.Vim = Vim;\n_cm_adapter[\"default\"].Vim = Vim();\nvar _default = _cm_adapter[\"default\"];\nexports[\"default\"] = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _editor = require(\"monaco-editor/esm/vs/editor/editor.api\");\n\nvar _shiftCommand = require(\"monaco-editor/esm/vs/editor/common/commands/shiftCommand\");\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nvar VerticalRevealType = {\n  Bottom: 4\n}; // for monaco 0.19.x where x < 3\n\nvar EditorOptConstants = {\n  readOnly: 65,\n  cursorWidth: 20,\n  fontInfo: 32\n};\nvar nonASCIISingleCaseWordChar = /[\\u00df\\u0587\\u0590-\\u05f4\\u0600-\\u06ff\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\uac00-\\ud7af]/;\n\nfunction isWordCharBasic(ch) {\n  return /\\w/.test(ch) || ch > \"\\x80\" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));\n}\n\nfunction Pos(line, column) {\n  if (!(this instanceof Pos)) {\n    return new Pos(line, column);\n  }\n\n  this.line = line;\n  this.ch = column;\n}\n\nfunction signal(cm, signal, args) {\n  cm.dispatch(signal, args);\n}\n\nfunction dummy(key) {\n  return function () {// console.log(key, 'dummy function called with', Array.prototype.slice.call(arguments));\n  };\n}\n\nvar doFold, noFold;\n\nif (String.prototype.normalize) {\n  doFold = function doFold(str) {\n    return str.normalize(\"NFD\").toLowerCase();\n  };\n\n  noFold = function noFold(str) {\n    return str.normalize(\"NFD\");\n  };\n} else {\n  doFold = function doFold(str) {\n    return str.toLowerCase();\n  };\n\n  noFold = function noFold(str) {\n    return str;\n  };\n}\n\nvar StringStream = function StringStream(string, tabSize) {\n  this.pos = this.start = 0;\n  this.string = string;\n  this.tabSize = tabSize || 8;\n  this.lastColumnPos = this.lastColumnValue = 0;\n  this.lineStart = 0;\n};\n\nStringStream.prototype = {\n  eol: function eol() {\n    return this.pos >= this.string.length;\n  },\n  sol: function sol() {\n    return this.pos == this.lineStart;\n  },\n  peek: function peek() {\n    return this.string.charAt(this.pos) || undefined;\n  },\n  next: function next() {\n    if (this.pos < this.string.length) return this.string.charAt(this.pos++);\n  },\n  eat: function eat(match) {\n    var ch = this.string.charAt(this.pos);\n    if (typeof match == \"string\") var ok = ch == match;else var ok = ch && (match.test ? match.test(ch) : match(ch));\n\n    if (ok) {\n      ++this.pos;\n      return ch;\n    }\n  },\n  eatWhile: function eatWhile(match) {\n    var start = this.pos;\n\n    while (this.eat(match)) {}\n\n    return this.pos > start;\n  },\n  eatSpace: function eatSpace() {\n    var start = this.pos;\n\n    while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) {\n      ++this.pos;\n    }\n\n    return this.pos > start;\n  },\n  skipToEnd: function skipToEnd() {\n    this.pos = this.string.length;\n  },\n  skipTo: function skipTo(ch) {\n    var found = this.string.indexOf(ch, this.pos);\n\n    if (found > -1) {\n      this.pos = found;\n      return true;\n    }\n  },\n  backUp: function backUp(n) {\n    this.pos -= n;\n  },\n  column: function column() {\n    throw \"not implemented\";\n  },\n  indentation: function indentation() {\n    throw \"not implemented\";\n  },\n  match: function match(pattern, consume, caseInsensitive) {\n    if (typeof pattern == \"string\") {\n      var cased = function cased(str) {\n        return caseInsensitive ? str.toLowerCase() : str;\n      };\n\n      var substr = this.string.substr(this.pos, pattern.length);\n\n      if (cased(substr) == cased(pattern)) {\n        if (consume !== false) this.pos += pattern.length;\n        return true;\n      }\n    } else {\n      var match = this.string.slice(this.pos).match(pattern);\n      if (match && match.index > 0) return null;\n      if (match && consume !== false) this.pos += match[0].length;\n      return match;\n    }\n  },\n  current: function current() {\n    return this.string.slice(this.start, this.pos);\n  },\n  hideFirstChars: function hideFirstChars(n, inner) {\n    this.lineStart += n;\n\n    try {\n      return inner();\n    } finally {\n      this.lineStart -= n;\n    }\n  }\n};\n\nfunction toCmPos(pos) {\n  return new Pos(pos.lineNumber - 1, pos.column - 1);\n}\n\nfunction toMonacoPos(pos) {\n  return new _editor.Position(pos.line + 1, pos.ch + 1);\n}\n\nvar Marker = /*#__PURE__*/function () {\n  function Marker(cm, id, line, ch) {\n    _classCallCheck(this, Marker);\n\n    this.cm = cm;\n    this.id = id;\n    this.lineNumber = line + 1;\n    this.column = ch + 1;\n    cm.marks[this.id] = this;\n  }\n\n  _createClass(Marker, [{\n    key: \"clear\",\n    value: function clear() {\n      delete this.cm.marks[this.id];\n    }\n  }, {\n    key: \"find\",\n    value: function find() {\n      return toCmPos(this);\n    }\n  }]);\n\n  return Marker;\n}();\n\nfunction monacoToCmKey(e) {\n  var skip = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var addQuotes = true;\n  var keyName = _editor.KeyCode[e.keyCode];\n\n  if (e.key) {\n    keyName = e.key;\n    addQuotes = false;\n  }\n\n  var key = keyName;\n  var skipOnlyShiftCheck = skip;\n\n  switch (e.keyCode) {\n    case _editor.KeyCode.Shift:\n    case _editor.KeyCode.Meta:\n    case _editor.KeyCode.Alt:\n    case _editor.KeyCode.Ctrl:\n      return key;\n\n    case _editor.KeyCode.Escape:\n      skipOnlyShiftCheck = true;\n      key = \"Esc\";\n      break;\n\n    case _editor.KeyCode.Space:\n      skipOnlyShiftCheck = true;\n      break;\n  } // `Key` check for monaco >= 0.30.0\n\n\n  if (keyName.startsWith(\"Key\") || keyName.startsWith(\"KEY_\")) {\n    key = keyName[keyName.length - 1].toLowerCase();\n  } else if (keyName.startsWith(\"Digit\")) {\n    key = keyName.slice(5, 6);\n  } else if (keyName.startsWith(\"Numpad\")) {\n    key = keyName.slice(6, 7);\n  } else if (keyName.endsWith(\"Arrow\")) {\n    skipOnlyShiftCheck = true;\n    key = keyName.substring(0, keyName.length - 5);\n  } else if (keyName.startsWith(\"US_\") || // `Bracket` check for monaco >= 0.30.0\n  keyName.startsWith(\"Bracket\") || !key) {\n    key = e.browserEvent.key;\n  }\n\n  if (!skipOnlyShiftCheck && !e.altKey && !e.ctrlKey && !e.metaKey) {\n    key = e.key || e.browserEvent.key;\n  } else {\n    if (e.altKey) {\n      key = \"Alt-\".concat(key);\n    }\n\n    if (e.ctrlKey) {\n      key = \"Ctrl-\".concat(key);\n    }\n\n    if (e.metaKey) {\n      key = \"Meta-\".concat(key);\n    }\n\n    if (e.shiftKey) {\n      key = \"Shift-\".concat(key);\n    }\n  }\n\n  if (key.length === 1 && addQuotes) {\n    key = \"'\".concat(key, \"'\");\n  }\n\n  return key;\n}\n\nvar CMAdapter = /*#__PURE__*/function () {\n  function CMAdapter(editor) {\n    _classCallCheck(this, CMAdapter);\n\n    _initialiseProps.call(this);\n\n    this.editor = editor;\n    this.state = {\n      keyMap: \"vim\"\n    };\n    this.marks = {};\n    this.$uid = 0;\n    this.disposables = [];\n    this.listeners = {};\n    this.curOp = {};\n    this.attached = false;\n    this.statusBar = null;\n    this.options = {};\n    this.addLocalListeners();\n    this.ctxInsert = this.editor.createContextKey(\"insertMode\", true);\n  }\n\n  _createClass(CMAdapter, [{\n    key: \"attach\",\n    value: function attach() {\n      CMAdapter.keyMap.vim.attach(this);\n    }\n  }, {\n    key: \"addLocalListeners\",\n    value: function addLocalListeners() {\n      this.disposables.push(this.editor.onDidChangeCursorPosition(this.handleCursorChange), this.editor.onDidChangeModelContent(this.handleChange), this.editor.onKeyDown(this.handleKeyDown));\n    }\n  }, {\n    key: \"handleReplaceMode\",\n    value: function handleReplaceMode(key, e) {\n      var fromReplace = false;\n      var _char = key;\n      var pos = this.editor.getPosition();\n      var range = new _editor.Range(pos.lineNumber, pos.column, pos.lineNumber, pos.column + 1);\n      var forceMoveMarkers = true;\n\n      if (key.startsWith(\"'\")) {\n        _char = key[1];\n      } else if (_char === \"Enter\") {\n        _char = \"\\n\";\n      } else if (_char === \"Backspace\") {\n        var lastItem = this.replaceStack.pop();\n\n        if (!lastItem) {\n          return;\n        }\n\n        fromReplace = true;\n        _char = lastItem;\n        range = new _editor.Range(pos.lineNumber, pos.column, pos.lineNumber, pos.column - 1);\n      } else {\n        return;\n      }\n\n      e.preventDefault();\n      e.stopPropagation();\n\n      if (!this.replaceStack) {\n        this.replaceStack = [];\n      }\n\n      if (!fromReplace) {\n        this.replaceStack.push(this.editor.getModel().getValueInRange(range));\n      }\n\n      this.editor.executeEdits(\"vim\", [{\n        text: _char,\n        range: range,\n        forceMoveMarkers: forceMoveMarkers\n      }]);\n\n      if (fromReplace) {\n        this.editor.setPosition(range.getStartPosition());\n      }\n    }\n  }, {\n    key: \"setOption\",\n    value: function setOption(key, value) {\n      this.state[key] = value;\n\n      if (key === \"theme\") {\n        _editor.editor.setTheme(value);\n      }\n    }\n  }, {\n    key: \"getConfiguration\",\n    value: function getConfiguration() {\n      var editor = this.editor;\n      var opts = EditorOptConstants;\n\n      if (typeof editor.getConfiguration === \"function\") {\n        return editor.getConfiguration();\n      } else if (\"EditorOption\" in _editor.editor) {\n        // for monaco 0.19.3 onwards\n        opts = _editor.editor.EditorOption;\n      }\n\n      return {\n        readOnly: editor.getOption(opts.readOnly),\n        viewInfo: {\n          cursorWidth: editor.getOption(opts.cursorWidth)\n        },\n        fontInfo: editor.getOption(opts.fontInfo)\n      };\n    }\n  }, {\n    key: \"getOption\",\n    value: function getOption(key) {\n      if (key === \"readOnly\") {\n        return this.getConfiguration().readOnly;\n      } else if (key === \"firstLineNumber\") {\n        return this.firstLine() + 1;\n      } else if (key === \"indentWithTabs\") {\n        return !this.editor.getModel().getOptions().insertSpaces;\n      } else {\n        if (typeof this.editor.getConfiguration === \"function\") {\n          return this.editor.getRawConfiguration()[key];\n        }\n\n        return this.editor.getRawOptions()[key];\n      }\n    }\n  }, {\n    key: \"dispatch\",\n    value: function dispatch(signal) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      var listeners = this.listeners[signal];\n\n      if (!listeners) {\n        return;\n      }\n\n      listeners.forEach(function (handler) {\n        return handler.apply(void 0, args);\n      });\n    }\n  }, {\n    key: \"on\",\n    value: function on(event, handler) {\n      if (!this.listeners[event]) {\n        this.listeners[event] = [];\n      }\n\n      this.listeners[event].push(handler);\n    }\n  }, {\n    key: \"off\",\n    value: function off(event, handler) {\n      var listeners = this.listeners[event];\n\n      if (!listeners) {\n        return;\n      }\n\n      this.listeners[event] = listeners.filter(function (l) {\n        return l !== handler;\n      });\n    }\n  }, {\n    key: \"firstLine\",\n    value: function firstLine() {\n      return 0;\n    }\n  }, {\n    key: \"lastLine\",\n    value: function lastLine() {\n      return this.lineCount() - 1;\n    }\n  }, {\n    key: \"lineCount\",\n    value: function lineCount() {\n      return this.editor.getModel().getLineCount();\n    }\n  }, {\n    key: \"defaultTextHeight\",\n    value: function defaultTextHeight() {\n      return 1;\n    }\n  }, {\n    key: \"getLine\",\n    value: function getLine(line) {\n      if (line < 0) {\n        return \"\";\n      }\n\n      var model = this.editor.getModel();\n      var maxLines = model.getLineCount();\n\n      if (line + 1 > maxLines) {\n        line = maxLines - 1;\n      }\n\n      return this.editor.getModel().getLineContent(line + 1);\n    }\n  }, {\n    key: \"getAnchorForSelection\",\n    value: function getAnchorForSelection(selection) {\n      if (selection.isEmpty()) {\n        return selection.getPosition();\n      }\n\n      var selDir = selection.getDirection();\n      return selDir === _editor.SelectionDirection.LTR ? selection.getStartPosition() : selection.getEndPosition();\n    }\n  }, {\n    key: \"getHeadForSelection\",\n    value: function getHeadForSelection(selection) {\n      if (selection.isEmpty()) {\n        return selection.getPosition();\n      }\n\n      var selDir = selection.getDirection();\n      return selDir === _editor.SelectionDirection.LTR ? selection.getEndPosition() : selection.getStartPosition();\n    }\n  }, {\n    key: \"getCursor\",\n    value: function getCursor() {\n      var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n      if (!type) {\n        return toCmPos(this.editor.getPosition());\n      }\n\n      var sel = this.editor.getSelection();\n      var pos;\n\n      if (sel.isEmpty()) {\n        pos = sel.getPosition();\n      } else if (type === \"anchor\") {\n        pos = this.getAnchorForSelection(sel);\n      } else {\n        pos = this.getHeadForSelection(sel);\n      }\n\n      return toCmPos(pos);\n    }\n  }, {\n    key: \"getRange\",\n    value: function getRange(start, end) {\n      var p1 = toMonacoPos(start);\n      var p2 = toMonacoPos(end);\n      return this.editor.getModel().getValueInRange(_editor.Range.fromPositions(p1, p2));\n    }\n  }, {\n    key: \"getSelection\",\n    value: function getSelection() {\n      var list = [];\n      var editor = this.editor;\n      editor.getSelections().map(function (sel) {\n        list.push(editor.getModel().getValueInRange(sel));\n      });\n      return list.join(\"\\n\");\n    }\n  }, {\n    key: \"replaceRange\",\n    value: function replaceRange(text, start, end) {\n      var p1 = toMonacoPos(start);\n      var p2 = !end ? p1 : toMonacoPos(end);\n      this.editor.executeEdits(\"vim\", [{\n        text: text,\n        range: _editor.Range.fromPositions(p1, p2)\n      }]); // @TODO - Check if this breaks any other expectation\n\n      this.pushUndoStop();\n    }\n  }, {\n    key: \"pushUndoStop\",\n    value: function pushUndoStop() {\n      this.editor.pushUndoStop();\n    }\n  }, {\n    key: \"setCursor\",\n    value: function setCursor(line, ch) {\n      var pos = line;\n\n      if (_typeof(line) !== \"object\") {\n        pos = {};\n        pos.line = line;\n        pos.ch = ch;\n      }\n\n      var monacoPos = this.editor.getModel().validatePosition(toMonacoPos(pos));\n      this.editor.setPosition(toMonacoPos(pos));\n      this.editor.revealPosition(monacoPos);\n    }\n  }, {\n    key: \"somethingSelected\",\n    value: function somethingSelected() {\n      return !this.editor.getSelection().isEmpty();\n    }\n  }, {\n    key: \"operation\",\n    value: function operation(fn, force) {\n      return fn();\n    }\n  }, {\n    key: \"listSelections\",\n    value: function listSelections() {\n      var _this = this;\n\n      var selections = this.editor.getSelections();\n\n      if (!selections.length || this.inVirtualSelectionMode) {\n        return [{\n          anchor: this.getCursor(\"anchor\"),\n          head: this.getCursor(\"head\")\n        }];\n      }\n\n      return selections.map(function (sel) {\n        var pos = sel.getPosition();\n        var start = sel.getStartPosition();\n        var end = sel.getEndPosition();\n        return {\n          anchor: _this.clipPos(toCmPos(_this.getAnchorForSelection(sel))),\n          head: _this.clipPos(toCmPos(_this.getHeadForSelection(sel)))\n        };\n      });\n    }\n  }, {\n    key: \"focus\",\n    value: function focus() {\n      this.editor.focus();\n    }\n  }, {\n    key: \"setSelections\",\n    value: function setSelections(selections, primIndex) {\n      var hasSel = !!this.editor.getSelections().length;\n      var sels = selections.map(function (sel, index) {\n        var anchor = sel.anchor,\n            head = sel.head;\n\n        if (hasSel) {\n          return _editor.Selection.fromPositions(toMonacoPos(anchor), toMonacoPos(head));\n        } else {\n          return _editor.Selection.fromPositions(toMonacoPos(head), toMonacoPos(anchor));\n        }\n      });\n\n      if (!primIndex) {} else if (sels[primIndex]) {\n        sels.push(sels.splice(primIndex, 1)[0]);\n      }\n\n      if (!sels.length) {\n        return;\n      }\n\n      var sel = sels[0];\n      var posToReveal;\n\n      if (sel.getDirection() === _editor.SelectionDirection.LTR) {\n        posToReveal = sel.getEndPosition();\n      } else {\n        posToReveal = sel.getStartPosition();\n      }\n\n      this.editor.setSelections(sels);\n      this.editor.revealPosition(posToReveal);\n    }\n  }, {\n    key: \"setSelection\",\n    value: function setSelection(frm, to) {\n      var range = _editor.Range.fromPositions(toMonacoPos(frm), toMonacoPos(to));\n\n      this.editor.setSelection(range);\n    }\n  }, {\n    key: \"getSelections\",\n    value: function getSelections() {\n      var editor = this.editor;\n      return editor.getSelections().map(function (sel) {\n        return editor.getModel().getValueInRange(sel);\n      });\n    }\n  }, {\n    key: \"replaceSelections\",\n    value: function replaceSelections(texts) {\n      var editor = this.editor;\n      editor.getSelections().forEach(function (sel, index) {\n        editor.executeEdits(\"vim\", [{\n          range: sel,\n          text: texts[index],\n          forceMoveMarkers: false\n        }]);\n      });\n    }\n  }, {\n    key: \"toggleOverwrite\",\n    value: function toggleOverwrite(toggle) {\n      if (toggle) {\n        this.enterVimMode();\n        this.replaceMode = true;\n      } else {\n        this.leaveVimMode();\n        this.replaceMode = false;\n        this.replaceStack = [];\n      }\n    }\n  }, {\n    key: \"charCoords\",\n    value: function charCoords(pos, mode) {\n      return {\n        top: pos.line,\n        left: pos.ch\n      };\n    }\n  }, {\n    key: \"coordsChar\",\n    value: function coordsChar(pos, mode) {\n      if (mode === \"local\") {}\n    }\n  }, {\n    key: \"clipPos\",\n    value: function clipPos(p) {\n      var pos = this.editor.getModel().validatePosition(toMonacoPos(p));\n      return toCmPos(pos);\n    }\n  }, {\n    key: \"setBookmark\",\n    value: function setBookmark(cursor, options) {\n      var bm = new Marker(this, this.$uid++, cursor.line, cursor.ch);\n\n      if (!options || !options.insertLeft) {\n        bm.$insertRight = true;\n      }\n\n      this.marks[bm.id] = bm;\n      return bm;\n    }\n  }, {\n    key: \"getScrollInfo\",\n    value: function getScrollInfo() {\n      var editor = this.editor;\n\n      var _editor$getVisibleRan = editor.getVisibleRanges(),\n          _editor$getVisibleRan2 = _slicedToArray(_editor$getVisibleRan, 1),\n          range = _editor$getVisibleRan2[0];\n\n      return {\n        left: 0,\n        top: range.startLineNumber - 1,\n        height: editor.getModel().getLineCount(),\n        clientHeight: range.endLineNumber - range.startLineNumber + 1\n      };\n    }\n  }, {\n    key: \"triggerEditorAction\",\n    value: function triggerEditorAction(action) {\n      this.editor.trigger(\"vim\", action);\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this.dispatch(\"dispose\");\n      this.removeOverlay();\n\n      if (CMAdapter.keyMap.vim) {\n        CMAdapter.keyMap.vim.detach(this);\n      }\n\n      this.disposables.forEach(function (d) {\n        return d.dispose();\n      });\n    }\n  }, {\n    key: \"getInputField\",\n    value: function getInputField() {}\n  }, {\n    key: \"getWrapperElement\",\n    value: function getWrapperElement() {}\n  }, {\n    key: \"enterVimMode\",\n    value: function enterVimMode() {\n      var toVim = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      this.ctxInsert.set(false);\n      var config = this.getConfiguration();\n      this.initialCursorWidth = config.viewInfo.cursorWidth || 0;\n      this.editor.updateOptions({\n        cursorWidth: config.fontInfo.typicalFullwidthCharacterWidth,\n        cursorBlinking: \"solid\"\n      });\n    }\n  }, {\n    key: \"leaveVimMode\",\n    value: function leaveVimMode() {\n      this.ctxInsert.set(true);\n      this.editor.updateOptions({\n        cursorWidth: this.initialCursorWidth || 0,\n        cursorBlinking: \"blink\"\n      });\n    }\n  }, {\n    key: \"virtualSelectionMode\",\n    value: function virtualSelectionMode() {\n      return this.inVirtualSelectionMode;\n    }\n  }, {\n    key: \"markText\",\n    value: function markText() {\n      // only used for fat-cursor, not needed\n      return {\n        clear: function clear() {},\n        find: function find() {}\n      };\n    }\n  }, {\n    key: \"getUserVisibleLines\",\n    value: function getUserVisibleLines() {\n      var ranges = this.editor.getVisibleRanges();\n\n      if (!ranges.length) {\n        return {\n          top: 0,\n          bottom: 0\n        };\n      }\n\n      var res = {\n        top: Infinity,\n        bottom: 0\n      };\n      ranges.reduce(function (acc, range) {\n        if (range.startLineNumber < acc.top) {\n          acc.top = range.startLineNumber;\n        }\n\n        if (range.endLineNumber > acc.bottom) {\n          acc.bottom = range.endLineNumber;\n        }\n\n        return acc;\n      }, res);\n      res.top -= 1;\n      res.bottom -= 1;\n      return res;\n    }\n  }, {\n    key: \"findPosV\",\n    value: function findPosV(startPos, amount, unit) {\n      var editor = this.editor;\n      var finalAmount = amount;\n      var finalUnit = unit;\n      var pos = toMonacoPos(startPos);\n\n      if (unit === \"page\") {\n        var editorHeight = editor.getLayoutInfo().height;\n        var lineHeight = this.getConfiguration().fontInfo.lineHeight;\n        finalAmount = finalAmount * Math.floor(editorHeight / lineHeight);\n        finalUnit = \"line\";\n      }\n\n      if (finalUnit === \"line\") {\n        pos.lineNumber += finalAmount;\n      }\n\n      return toCmPos(pos);\n    }\n  }, {\n    key: \"findMatchingBracket\",\n    value: function findMatchingBracket(pos) {\n      var mPos = toMonacoPos(pos);\n      var model = this.editor.getModel();\n      var res; // for monaco versions >= 0.28.0\n\n      if (model.bracketPairs) {\n        res = model.bracketPairs.matchBracket(mPos);\n      } else {\n        var _model$matchBracket;\n\n        res = (_model$matchBracket = model.matchBracket) === null || _model$matchBracket === void 0 ? void 0 : _model$matchBracket.call(model, mPos);\n      }\n\n      if (!res || !(res.length === 2)) {\n        return {\n          to: null\n        };\n      }\n\n      return {\n        to: toCmPos(res[1].getStartPosition())\n      };\n    }\n  }, {\n    key: \"findFirstNonWhiteSpaceCharacter\",\n    value: function findFirstNonWhiteSpaceCharacter(line) {\n      return this.editor.getModel().getLineFirstNonWhitespaceColumn(line + 1) - 1;\n    }\n  }, {\n    key: \"scrollTo\",\n    value: function scrollTo(x, y) {\n      if (!x && !y) {\n        return;\n      }\n\n      if (!x) {\n        if (y < 0) {\n          y = this.editor.getPosition().lineNumber - y;\n        }\n\n        this.editor.setScrollTop(this.editor.getTopForLineNumber(y + 1));\n      }\n    }\n  }, {\n    key: \"moveCurrentLineTo\",\n    value: function moveCurrentLineTo(viewPosition) {\n      var _editor$_revealRange;\n\n      var editor = this.editor;\n      var pos = editor.getPosition();\n\n      var range = _editor.Range.fromPositions(pos, pos);\n\n      switch (viewPosition) {\n        case \"top\":\n          editor.revealRangeAtTop(range);\n          return;\n\n        case \"center\":\n          editor.revealRangeInCenter(range);\n          return;\n\n        case \"bottom\":\n          // private api. no other way\n          (_editor$_revealRange = editor._revealRange) === null || _editor$_revealRange === void 0 ? void 0 : _editor$_revealRange.call(editor, range, VerticalRevealType.Bottom);\n          return;\n      }\n    }\n  }, {\n    key: \"getSearchCursor\",\n    value: function getSearchCursor(query, pos) {\n      var matchCase = false;\n      var isRegex = false;\n\n      if (query instanceof RegExp && !query.global) {\n        matchCase = !query.ignoreCase;\n        query = query.source;\n        isRegex = true;\n      }\n\n      if (pos.ch == undefined) pos.ch = Number.MAX_VALUE;\n      var monacoPos = toMonacoPos(pos);\n      var context = this;\n      var editor = this.editor;\n      var lastSearch = null;\n      var model = editor.getModel();\n      var matches = model.findMatches(query, false, isRegex, matchCase) || [];\n      return {\n        getMatches: function getMatches() {\n          return matches;\n        },\n        findNext: function findNext() {\n          return this.find(false);\n        },\n        findPrevious: function findPrevious() {\n          return this.find(true);\n        },\n        jumpTo: function jumpTo(index) {\n          if (!matches || !matches.length) {\n            return false;\n          }\n\n          var match = matches[index];\n          lastSearch = match.range;\n          context.highlightRanges([lastSearch], \"currentFindMatch\");\n          context.highlightRanges(matches.map(function (m) {\n            return m.range;\n          }).filter(function (r) {\n            return !r.equalsRange(lastSearch);\n          }));\n          return lastSearch;\n        },\n        find: function find(back) {\n          if (!matches || !matches.length) {\n            return false;\n          }\n\n          var match;\n\n          if (back) {\n            var _pos = lastSearch ? lastSearch.getStartPosition() : monacoPos;\n\n            match = model.findPreviousMatch(query, _pos, isRegex, matchCase);\n\n            if (!match || !match.range.getStartPosition().isBeforeOrEqual(_pos)) {\n              return false;\n            }\n          } else {\n            var _pos2 = lastSearch ? model.getPositionAt(model.getOffsetAt(lastSearch.getEndPosition()) + 1) : monacoPos;\n\n            match = model.findNextMatch(query, _pos2, isRegex, matchCase);\n\n            if (!match || !_pos2.isBeforeOrEqual(match.range.getStartPosition())) {\n              return false;\n            }\n          }\n\n          lastSearch = match.range;\n          context.highlightRanges([lastSearch], \"currentFindMatch\");\n          context.highlightRanges(matches.map(function (m) {\n            return m.range;\n          }).filter(function (r) {\n            return !r.equalsRange(lastSearch);\n          }));\n          return lastSearch;\n        },\n        from: function from() {\n          return lastSearch && toCmPos(lastSearch.getStartPosition());\n        },\n        to: function to() {\n          return lastSearch && toCmPos(lastSearch.getEndPosition());\n        },\n        replace: function replace(text) {\n          if (lastSearch) {\n            editor.executeEdits(\"vim\", [{\n              range: lastSearch,\n              text: text,\n              forceMoveMarkers: true\n            }], function (edits) {\n              var _edits$0$range = edits[0].range,\n                  endLineNumber = _edits$0$range.endLineNumber,\n                  endColumn = _edits$0$range.endColumn;\n              lastSearch = lastSearch.setEndPosition(endLineNumber, endColumn);\n            });\n            editor.setPosition(lastSearch.getStartPosition());\n          }\n        }\n      };\n    }\n  }, {\n    key: \"highlightRanges\",\n    value: function highlightRanges(ranges) {\n      var className = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"findMatch\";\n      var decorationKey = \"decoration\".concat(className);\n      this[decorationKey] = this.editor.deltaDecorations(this[decorationKey] || [], ranges.map(function (range) {\n        return {\n          range: range,\n          options: {\n            stickiness: _editor.editor.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,\n            zIndex: 13,\n            className: className,\n            showIfCollapsed: true\n          }\n        };\n      }));\n      return this[decorationKey];\n    }\n  }, {\n    key: \"addOverlay\",\n    value: function addOverlay(_ref, hasBoundary, style) {\n      var query = _ref.query;\n      var matchCase = false;\n      var isRegex = false;\n\n      if (query && query instanceof RegExp && !query.global) {\n        isRegex = true;\n        matchCase = !query.ignoreCase;\n        query = query.source;\n      }\n\n      var match = this.editor.getModel().findNextMatch(query, this.editor.getPosition(), isRegex, matchCase);\n\n      if (!match || !match.range) {\n        return;\n      }\n\n      this.highlightRanges([match.range]);\n    }\n  }, {\n    key: \"removeOverlay\",\n    value: function removeOverlay() {\n      var _this2 = this;\n\n      [\"currentFindMatch\", \"findMatch\"].forEach(function (key) {\n        _this2.editor.deltaDecorations(_this2[\"decoration\".concat(key)] || [], []);\n      });\n    }\n  }, {\n    key: \"scrollIntoView\",\n    value: function scrollIntoView(pos) {\n      if (!pos) {\n        return;\n      }\n\n      this.editor.revealPosition(toMonacoPos(pos));\n    }\n  }, {\n    key: \"moveH\",\n    value: function moveH(units, type) {\n      if (type !== \"char\") {\n        return;\n      }\n\n      var pos = this.editor.getPosition();\n      this.editor.setPosition(new _editor.Position(pos.lineNumber, pos.column + units));\n    }\n  }, {\n    key: \"scanForBracket\",\n    value: function scanForBracket(pos, dir, dd, config) {\n      var bracketRegex = config.bracketRegex;\n      var mPos = toMonacoPos(pos);\n      var model = this.editor.getModel();\n      var searchFunc = (dir === -1 ? model.findPreviousMatch : model.findNextMatch).bind(model);\n      var stack = [];\n      var iterations = 0;\n\n      while (true) {\n        if (iterations > 10) {\n          // Searched too far, give up.\n          return undefined;\n        }\n\n        var match = searchFunc(bracketRegex.source, mPos, true, true, null, true);\n        var thisBracket = match.matches[0];\n\n        if (match === undefined) {\n          return undefined;\n        }\n\n        var matchingBracket = CMAdapter.matchingBrackets[thisBracket];\n\n        if (matchingBracket && matchingBracket.charAt(1) === \">\" == dir > 0) {\n          stack.push(thisBracket);\n        } else if (stack.length === 0) {\n          var res = match.range.getStartPosition();\n          return {\n            pos: toCmPos(res)\n          };\n        } else {\n          stack.pop();\n        }\n\n        mPos = model.getPositionAt(model.getOffsetAt(match.range.getStartPosition()) + dir);\n        iterations += 1;\n      }\n    }\n  }, {\n    key: \"indexFromPos\",\n    value: function indexFromPos(pos) {\n      return this.editor.getModel().getOffsetAt(toMonacoPos(pos));\n    }\n  }, {\n    key: \"posFromIndex\",\n    value: function posFromIndex(offset) {\n      return toCmPos(this.editor.getModel().getPositionAt(offset));\n    }\n  }, {\n    key: \"indentLine\",\n    value: function indentLine(line) {\n      var indentRight = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var editor = this.editor;\n      var cursorConfig; // Monaco >= 0.21.x\n\n      if (editor._getViewModel) {\n        cursorConfig = editor._getViewModel().cursorConfig;\n      } else {\n        cursorConfig = editor._getCursors().context.config;\n      }\n\n      var pos = new _editor.Position(line + 1, 1);\n\n      var sel = _editor.Selection.fromPositions(pos, pos); // no other way than to use internal apis to preserve the undoStack for a batch of indents\n\n\n      editor.executeCommand(\"vim\", new _shiftCommand.ShiftCommand(sel, {\n        isUnshift: !indentRight,\n        tabSize: cursorConfig.tabSize,\n        indentSize: cursorConfig.indentSize,\n        insertSpaces: cursorConfig.insertSpaces,\n        useTabStops: cursorConfig.useTabStops,\n        autoIndent: cursorConfig.autoIndent\n      }));\n    }\n  }, {\n    key: \"setStatusBar\",\n    value: function setStatusBar(statusBar) {\n      this.statusBar = statusBar;\n    }\n  }, {\n    key: \"openDialog\",\n    value: function openDialog(html, callback, options) {\n      if (!this.statusBar) {\n        return;\n      }\n\n      return this.statusBar.setSec(html, callback, options);\n    }\n  }, {\n    key: \"openNotification\",\n    value: function openNotification(html) {\n      if (!this.statusBar) {\n        return;\n      }\n\n      this.statusBar.showNotification(html);\n    }\n  }, {\n    key: \"smartIndent\",\n    value: function smartIndent() {\n      // Only works if a formatter is added for the current language.\n      // reindentselectedlines does not work here.\n      this.editor.getAction(\"editor.action.formatSelection\").run();\n    }\n  }, {\n    key: \"moveCursorTo\",\n    value: function moveCursorTo(to) {\n      var newPos = this.editor.getPosition();\n\n      if (to === \"start\") {\n        newPos.column = 1;\n      } else if (to === \"end\") {\n        newPos.column = this.editor.getModel().getLineMaxColumn(newPos.lineNumber);\n      }\n\n      this.editor.setPosition(newPos);\n    }\n  }, {\n    key: \"execCommand\",\n    value: function execCommand(command) {\n      switch (command) {\n        case \"goLineLeft\":\n          this.moveCursorTo(\"start\");\n          break;\n\n        case \"goLineRight\":\n          this.moveCursorTo(\"end\");\n          break;\n\n        case \"indentAuto\":\n          this.smartIndent();\n          break;\n      }\n    }\n  }]);\n\n  return CMAdapter;\n}();\n\nCMAdapter.Pos = Pos;\nCMAdapter.signal = signal;\nCMAdapter.on = dummy(\"on\");\nCMAdapter.off = dummy(\"off\");\nCMAdapter.addClass = dummy(\"addClass\");\nCMAdapter.rmClass = dummy(\"rmClass\");\nCMAdapter.defineOption = dummy(\"defineOption\");\nCMAdapter.keyMap = {\n  \"default\": function _default(key) {\n    return function (cm) {\n      return true;\n    };\n  }\n};\nCMAdapter.matchingBrackets = {\n  \"(\": \")>\",\n  \")\": \"(<\",\n  \"[\": \"]>\",\n  \"]\": \"[<\",\n  \"{\": \"}>\",\n  \"}\": \"{<\",\n  \"<\": \">>\",\n  \">\": \"<<\"\n};\nCMAdapter.isWordChar = isWordCharBasic;\nCMAdapter.keyName = monacoToCmKey;\nCMAdapter.StringStream = StringStream;\n\nCMAdapter.e_stop = function (e) {\n  if (e.stopPropagation) {\n    e.stopPropagation();\n  } else {\n    e.cancelBubble = true;\n  }\n\n  CMAdapter.e_preventDefault(e);\n  return false;\n};\n\nCMAdapter.e_preventDefault = function (e) {\n  if (e.preventDefault) {\n    e.preventDefault();\n\n    if (e.browserEvent) {\n      e.browserEvent.preventDefault();\n    }\n  } else {\n    e.returnValue = false;\n  }\n\n  return false;\n};\n\nCMAdapter.commands = {\n  redo: function redo(cm) {\n    cm.editor.getModel().redo();\n  },\n  undo: function undo(cm) {\n    cm.editor.getModel().undo();\n  },\n  newlineAndIndent: function newlineAndIndent(cm) {\n    cm.triggerEditorAction(\"editor.action.insertLineAfter\");\n  }\n};\n\nCMAdapter.lookupKey = function lookupKey(key, map, handle) {\n  if (typeof map === \"string\") {\n    map = CMAdapter.keyMap[map];\n  }\n\n  var found = typeof map == \"function\" ? map(key) : map[key];\n  if (found === false) return \"nothing\";\n  if (found === \"...\") return \"multi\";\n  if (found != null && handle(found)) return \"handled\";\n\n  if (map.fallthrough) {\n    if (!Array.isArray(map.fallthrough)) return lookupKey(key, map.fallthrough, handle);\n\n    for (var i = 0; i < map.fallthrough.length; i++) {\n      var result = lookupKey(key, map.fallthrough[i], handle);\n      if (result) return result;\n    }\n  }\n};\n\nCMAdapter.defineExtension = function (name, fn) {\n  CMAdapter.prototype[name] = fn;\n};\n\nvar _initialiseProps = function _initialiseProps() {\n  var _this3 = this;\n\n  this.handleKeyDown = function (e) {\n    // Allow previously registered keydown listeners to handle the event and\n    // prevent this extension from also handling it.\n    if (e.browserEvent.defaultPrevented & e.keyCode !== _editor.KeyCode.Escape) {\n      return;\n    }\n\n    if (!_this3.attached) {\n      return;\n    }\n\n    var key = monacoToCmKey(e);\n\n    if (_this3.replaceMode) {\n      _this3.handleReplaceMode(key, e);\n    }\n\n    if (!key) {\n      return;\n    }\n\n    var keymap = _this3.state.keyMap;\n\n    if (CMAdapter.keyMap[keymap] && CMAdapter.keyMap[keymap].call) {\n      var cmd = CMAdapter.keyMap[keymap].call(key, _this3);\n\n      if (cmd) {\n        e.preventDefault();\n        e.stopPropagation();\n\n        try {\n          cmd();\n        } catch (err) {\n          console.error(err);\n        }\n      }\n    }\n  };\n\n  this.handleCursorChange = function (e) {\n    var position = e.position,\n        source = e.source;\n    var editor = _this3.editor;\n    var selection = editor.getSelection();\n\n    if (!_this3.ctxInsert.get() && e.source === \"mouse\" && selection.isEmpty()) {\n      var maxCol = editor.getModel().getLineMaxColumn(position.lineNumber);\n\n      if (e.position.column === maxCol) {\n        editor.setPosition(new _editor.Position(e.position.lineNumber, maxCol - 1));\n        return;\n      }\n    }\n\n    _this3.dispatch(\"cursorActivity\", _this3, e);\n  };\n\n  this.handleChange = function (e) {\n    var changes = e.changes;\n    var change = {\n      text: changes.reduce(function (acc, change) {\n        acc.push(change.text);\n        return acc;\n      }, []),\n      origin: \"+input\"\n    };\n    var curOp = _this3.curOp = _this3.curOp || {};\n\n    if (!curOp.changeHandlers) {\n      curOp.changeHandlers = _this3.listeners[\"change\"] && _this3.listeners[\"change\"].slice();\n    }\n\n    if (_this3.virtualSelectionMode()) {\n      return;\n    }\n\n    if (!curOp.lastChange) {\n      curOp.lastChange = curOp.change = change;\n    } else {\n      curOp.lastChange.next = curOp.lastChange = change;\n    }\n\n    _this3.dispatch(\"change\", _this3, change);\n  };\n};\n\nvar _default2 = CMAdapter;\nexports[\"default\"] = _default2;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"StatusBar\", {\n  enumerable: true,\n  get: function get() {\n    return _statusbar[\"default\"];\n  }\n});\nObject.defineProperty(exports, \"VimMode\", {\n  enumerable: true,\n  get: function get() {\n    return _keymap_vim[\"default\"];\n  }\n});\nexports.initVimMode = initVimMode;\n\nvar _keymap_vim = _interopRequireDefault(require(\"./cm/keymap_vim\"));\n\nvar _statusbar = _interopRequireDefault(require(\"./statusbar\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction initVimMode(editor) {\n  var statusbarNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var StatusBarClass = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _statusbar[\"default\"];\n  var sanitizer = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var vimAdapter = new _keymap_vim[\"default\"](editor);\n\n  if (!statusbarNode) {\n    vimAdapter.attach();\n    return vimAdapter;\n  }\n\n  var statusBar = new StatusBarClass(statusbarNode, editor, sanitizer);\n  var keyBuffer = \"\";\n  vimAdapter.on(\"vim-mode-change\", function (mode) {\n    statusBar.setMode(mode);\n  });\n  vimAdapter.on(\"vim-keypress\", function (key) {\n    if (key === \":\") {\n      keyBuffer = \"\";\n    } else {\n      keyBuffer += key;\n    }\n\n    statusBar.setKeyBuffer(keyBuffer);\n  });\n  vimAdapter.on(\"vim-command-done\", function () {\n    keyBuffer = \"\";\n    statusBar.setKeyBuffer(keyBuffer);\n  });\n  vimAdapter.on(\"dispose\", function () {\n    statusBar.toggleVisibility(false);\n    statusBar.closeInput();\n    statusBar.clear();\n  });\n  statusBar.toggleVisibility(true);\n  vimAdapter.setStatusBar(statusBar);\n  vimAdapter.attach();\n  return vimAdapter;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nvar VimStatusBar = /*#__PURE__*/function () {\n  function VimStatusBar(node, editor) {\n    var _this = this;\n\n    var sanitizer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n    _classCallCheck(this, VimStatusBar);\n\n    this.closeInput = function () {\n      _this.removeInputListeners();\n\n      _this.input = null;\n\n      _this.setSec(\"\");\n\n      if (_this.editor) {\n        _this.editor.focus();\n      }\n    };\n\n    this.clear = function () {\n      _this.setInnerHtml_(_this.node, \"\");\n    };\n\n    this.inputKeyUp = function (e) {\n      var options = _this.input.options;\n\n      if (options && options.onKeyUp) {\n        options.onKeyUp(e, e.target.value, _this.closeInput);\n      }\n    };\n\n    this.inputKeyInput = function (e) {\n      var options = _this.input.options;\n\n      if (options && options.onKeyInput) {\n        options.onKeyUp(e, e.target.value, _this.closeInput);\n      }\n    };\n\n    this.inputBlur = function () {\n      var options = _this.input.options;\n\n      if (options.closeOnBlur) {\n        _this.closeInput();\n      }\n    };\n\n    this.inputKeyDown = function (e) {\n      var _this$input = _this.input,\n          options = _this$input.options,\n          callback = _this$input.callback;\n\n      if (options && options.onKeyDown && options.onKeyDown(e, e.target.value, _this.closeInput)) {\n        return;\n      }\n\n      if (e.keyCode === 27 || options && options.closeOnEnter !== false && e.keyCode == 13) {\n        _this.input.node.blur();\n\n        e.stopPropagation();\n\n        _this.closeInput();\n      }\n\n      if (e.keyCode === 13 && callback) {\n        e.stopPropagation();\n        e.preventDefault();\n        callback(e.target.value);\n      }\n    };\n\n    this.node = node;\n    this.modeInfoNode = document.createElement(\"span\");\n    this.secInfoNode = document.createElement(\"span\");\n    this.notifNode = document.createElement(\"span\");\n    this.notifNode.className = \"vim-notification\";\n    this.keyInfoNode = document.createElement(\"span\");\n    this.keyInfoNode.setAttribute(\"style\", \"float: right\");\n    this.node.appendChild(this.modeInfoNode);\n    this.node.appendChild(this.secInfoNode);\n    this.node.appendChild(this.notifNode);\n    this.node.appendChild(this.keyInfoNode);\n    this.toggleVisibility(false);\n    this.editor = editor;\n    this.sanitizer = sanitizer;\n  }\n\n  _createClass(VimStatusBar, [{\n    key: \"setMode\",\n    value: function setMode(ev) {\n      if (ev.mode === \"visual\") {\n        if (ev.subMode === \"linewise\") {\n          this.setText(\"--VISUAL LINE--\");\n        } else if (ev.subMode === \"blockwise\") {\n          this.setText(\"--VISUAL BLOCK--\");\n        } else {\n          this.setText(\"--VISUAL--\");\n        }\n\n        return;\n      }\n\n      this.setText(\"--\".concat(ev.mode.toUpperCase(), \"--\"));\n    }\n  }, {\n    key: \"setKeyBuffer\",\n    value: function setKeyBuffer(key) {\n      this.keyInfoNode.textContent = key;\n    }\n  }, {\n    key: \"setSec\",\n    value: function setSec(text, callback, options) {\n      this.notifNode.textContent = \"\";\n\n      if (text === undefined) {\n        return this.closeInput;\n      }\n\n      this.setInnerHtml_(this.secInfoNode, text);\n      var input = this.secInfoNode.querySelector(\"input\");\n\n      if (input) {\n        input.focus();\n        this.input = {\n          callback: callback,\n          options: options,\n          node: input\n        };\n\n        if (options) {\n          if (options.selectValueOnOpen) {\n            input.select();\n          }\n\n          if (options.value) {\n            input.value = options.value;\n          }\n        }\n\n        this.addInputListeners();\n      }\n\n      return this.closeInput;\n    }\n  }, {\n    key: \"setText\",\n    value: function setText(text) {\n      this.modeInfoNode.textContent = text;\n    }\n  }, {\n    key: \"toggleVisibility\",\n    value: function toggleVisibility(toggle) {\n      if (toggle) {\n        this.node.style.display = \"block\";\n      } else {\n        this.node.style.display = \"none\";\n      }\n\n      if (this.input) {\n        this.removeInputListeners();\n      }\n\n      clearInterval(this.notifTimeout);\n    }\n  }, {\n    key: \"addInputListeners\",\n    value: function addInputListeners() {\n      var node = this.input.node;\n      node.addEventListener(\"keyup\", this.inputKeyUp);\n      node.addEventListener(\"keydown\", this.inputKeyDown);\n      node.addEventListener(\"input\", this.inputKeyInput);\n      node.addEventListener(\"blur\", this.inputBlur);\n    }\n  }, {\n    key: \"removeInputListeners\",\n    value: function removeInputListeners() {\n      if (!this.input || !this.input.node) {\n        return;\n      }\n\n      var node = this.input.node;\n      node.removeEventListener(\"keyup\", this.inputKeyUp);\n      node.removeEventListener(\"keydown\", this.inputKeyDown);\n      node.removeEventListener(\"input\", this.inputKeyInput);\n      node.removeEventListener(\"blur\", this.inputBlur);\n    }\n  }, {\n    key: \"showNotification\",\n    value: function showNotification(text) {\n      var _this2 = this;\n\n      var sp = document.createElement(\"span\");\n      this.setInnerHtml_(sp, text);\n      this.notifNode.textContent = sp.textContent;\n      this.notifTimeout = setTimeout(function () {\n        _this2.notifNode.textContent = \"\";\n      }, 5000);\n    }\n  }, {\n    key: \"setInnerHtml_\",\n    value: function setInnerHtml_(element, htmlContents) {\n      // Clear out previous contents first.\n      while (element.childNodes.length) {\n        element.removeChild(element.childNodes[0]);\n      }\n\n      if (!htmlContents) {\n        return;\n      }\n\n      if (this.sanitizer) {\n        element.appendChild(this.sanitizer(htmlContents));\n      } else {\n        element.appendChild(htmlContents);\n      }\n    }\n  }]);\n\n  return VimStatusBar;\n}();\n\nexports[\"default\"] = VimStatusBar;"],"names":[],"sourceRoot":""}